# .NStar
<font size=20>**Фреймворк .NStar**</font> - основной фреймворк прототипа языка <a href="https://github.com/Etyuhibosecyu/CSharp.NStar">C#.NStar</a>. Но также он доступен и для подключения к абсолютному большинству "нормальных" языков! ("Нормальных" - значит не эзотерических/игрушечных и не каких-то слишком упрощенных конструкторов.) (Но проще всего подключить этот фреймворк к языкам (не считая, разумеется, собственно C#.NStar) C#.NET, Visual Basic.NET и F#.NET.) Разумеется, в нем недоступны возможности, специфичные для языка, такие как практически полное отсутствие StackOverflow благодаря симуляции стека вызовов в куче или escape-последовательности &#92;! и &#92;q, но большинство возможностей реализуемы и в виде набора библиотек для большинства языков. На момент написания этих строк фреймворк уже содержал 11 библиотек, например, NStar.Core (ядро фреймворка), NStar.BigCollections и NStar.ParallelHS. Чтобы добавить фреймворк в свою программу, см. раздел "Установка и настройка".<br><br>
## Основные коллекции
<tt>BigBitList</tt> и <tt>BigList&lt;T&gt;</tt> (NStar.BigCollections) - коллекции (список бит (см. <tt>BitList</tt>) и типизированный список), в которые теоретически можно добавить до 2<sup>int.MaxValue</sup> - 1 элементов благодаря индексу типа <tt>MpzT</tt>, а не <tt>int</tt> (а то, что ни у одного суперкомпьютера в мире нет столько памяти, это проблемы этого суперкомпьютера, а не наши).<br>
<tt>BitList</tt> (NStar.Core) - компактный список значений битов, которые представлены в виде логических значений, где true указывает, что бит включен (1), а false указывает, что бит выключен (0). Благодаря неоценимому участию Элд Хасп способен копировать фрагменты своих экземпляров существенно быстрее, чем бит за битом. Сам я с этим бы не справился. **Элд Хасп**, еще раз благодарю вас, вы сделали очень много хорошего!<br>
<tt>Chain</tt> (NStar.Core) - цепь целых чисел, которая не хранится полностью, а только начало и длина. По ней можно даже итерироваться, не загружая в память полностью. Она создается полностью только при преобразовании в другой тип.<br>
<tt>List&lt;T&gt;</tt> (NStar.Core) - обычный список, но со всеми методами, которые есть в <tt>BaseIndexable&lt;T, TCertain&gt;</tt> и <tt>BaseList&lt;T, TCertain&gt;</tt>. Кроме того, метод <tt>Insert()</tt> со вторым параметром типа <tt>IEnumerable</tt>, но не <tt>ICollection</tt> занимает линейное время (аналог от Microsoft - квадратичное).<br>
<tt>ListHashSet&lt;T&gt;</tt> (NStar.Core) - коллекция, в которой можно получать по индексу, устанавливать по индексу, добавлять, вставлять и удалять элементы, как в списке, но элементы не повторяются и можно проверить существование элемента за Õ(1), как в хэш-множестве (удаление занимает O(n), множество элементов можно удалить также за O(n) методом <tt>FilterInPlace()</tt>).<br>
<tt>NList&lt;T&gt;</tt> (NStar.Core) - список, способный иметь внутренним типом только примитивный тип, перечисление или структуру (включая кортеж), все поля которой - примитивные типы, перечисления или аналогичные структуры, нигде, ни на каком уровне вложенности нет ссылочных типов (кратко такие типы называются нативными), зато способный исчезнуть из памяти моментально, не дожидаясь, пока сработает жирный и тормозной сборщик мусора. Крайне рекомендуется заменять <tt>List&lt;T&gt;</tt> на <tt>NList&lt;T&gt;</tt> везде, где только можно! Не забудьте только добавить инструкцию using при объявлении (<tt>using NList&lt;T&gt; = ...;</tt>) или вручную вызвать <tt>Dispose()</tt>. (В редких случаях возникают проблемы с сортировкой <tt>NList&lt;T&gt;</tt> с нечисловым T, в этом случае придется переключиться обратно на <tt>List&lt;T&gt;</tt>.)<br>
<tt>ParallelHashSet&lt;T&gt;</tt> (NStar.ParallelHS) - супер-быстрое благодаря распараллеливанию хэш-множество, на нашем компьютере с 24 потоками - в 10 раз быстрее хэш-множества от Microsoft (к сожалению, такой супер-скоростью владеет только добавление элементов, удаление, хотя тоже распараллеливается, существенно медленнее) (формально имеет индексацию, но фактически на нее лучше забить).<br>
<tt>String</tt> (NStar.Core) - строка, способная добавлять к себе символ за Õ(1), а не O(n), а также, в отличие от <tt>StringBuilder</tt>, исчезать из памяти моментально, не дожидаясь, пока сработает сборщик мусора.<br>
<br>
## Основные экстенты
Назначение большинства экстентов понятно из названия. Названия сделаны более понятными непосвященному, чем в классическом LINQ, где они взяты из SQL, который точно мало кому понятен. Методы, которые мне не удалось реализовать, просто вызывают методы классического LINQ (но тоже иногда переименованы).<br>
<tt>Any</tt> без параметров (только последовательность) - проверяет, что последовательность не пуста.<br>
<tt>CopyDoubleList</tt>, <tt>CopyTripleList</tt> - копирует двумерный или трехмерный список полностью, а не только ссылки на (n - 1)-мерные списки, как new List&lt;T&gt;().<br>
<tt>Count</tt> - возвращает количество элементов коллекции, удовлетворяющих определенному условию. Этот экстент НЕ возвращает длину последовательности, для этого есть <tt>Length()</tt>.<br>
<tt>Fill</tt> - заполняет список одинаковыми значениями или функциями от номера элемента, позволяя не вычислять каждый раз пустой элемент. К сожалению, если вы укажете в elem объект ссылочного типа, список будет заполнен ссылками на один и тот же объект. Если кто знает, как исправить эту проблему - пишите в обсуждении. Для временного обхода используйте вторую функцию с _ вместо номера.<br>
<tt>FrequencyTable</tt> - группирует элементы последовательности, возвращая ключи и количество элементов с каждым ключом, но не сами элементы. Этот экстент можно вызвать без параметров, что дает просто количество повторений каждого элемента - с экстентом <tt>Group()</tt>, начиная с обновления 19, такое не проходит.<br>
IndexesOfX - возвращает сразу ВСЕ индексы, в которых находится нужный элемент, а не только первый или последний.<br>
<tt>Median</tt> - сортирует последовательность и возвращает значение, находящееся в середине.<br>
Max/Mean/Median/Min(params &lt;type&gt;[] source) - позволяет вычислить нужную функцию, передав ей параметры один за другим, а не в виде коллекции - как Math.Max и Math.Min, только для произвольного числа параметров (но не меньше трех, так как для одного элемента функция тривиальна, а при двух функция существенно медленнее функции из Math). Рекомендуется указывать имя класса хотя бы одной буквой, так как иначе для двух элементов возникнет конфликт методов.<br>
<tt>OfType</tt> - возвращает ТОЛЬКО элементы требуемого типа, игнорируя остальные. Этот метод работает с нетипизированным IEnumerable.<br>
<tt>RepresentIntoNumbers</tt> - присваивает элементам последовательности номера, одинаковые для равных элементов и разные - для отличающихся, и возвращает список этих номеров. Нумерация начинается с нуля.<br>
<tt>SetInnerType</tt> - приводит каждый элемент последовательности к нужному типу с помощью либо оператора явного приведения, либо пользовательской функции. Может выбросить InvalidCastException. Этот метод работает с нетипизированным IEnumerable.<br>
<tt>ToArray</tt> поддерживает реализации как без параметров (прямой аналог метода классического LINQ), так и с параметрами - опять же для экономии количества проходов по последовательности. Еще больше самых разных реализаций доступно в методе ToDictionary.<br>
<tt>TryGetLengthEasily</tt> - пробует получить количество элементов без полного перебора коллекции. В отличие от метода классического LINQ, возвращает true для существенно большего множества типов. Этот метод работает как с типизированным, так и с нетипизированным IEnumerable.<br>
<tt>Wrap</tt> и <tt>TryWrap</tt> - позволяют избежать как лишних действий, так и лишней строки кода в случае, когда результат вычисления очередного LINQ-метода используется в следующем несколько раз. По сути ничего функционального не делают, а только кэшируют поданную им последовательность, позволяя написать x вместо громоздкого выражения, и вызывают внутреннюю функцию.<br><br>
Все методы, у которых есть функция конверсии, поставляются с двумя ее версиями - только от элементов и от элементов и номера. Даже вызывающие классический LINQ.<br>
Метод JoinIntoSingle необходимо вызывать, либо предварительно приведя средний тип двумерной коллекции к List, либо указывая в угловых скобках сначала этот средний тип вместе со внутренним, а затем целевой тип - если хоть один не указать, метод не работает!<br><br>
Также списки (в том числе BitList) поддерживают несколько методов, которых нет в классических реализациях:<br>
<br>
## Основные методы BaseList
<tt>Contains</tt>, <tt>IndexOf</tt>, <tt>LastIndexOf</tt> с поиском последовательности.<br>
<tt>ContainsAny</tt>, <tt>IndexOfAny</tt>, <tt>LastIndexOfAny</tt> - поиск в исходном списке любого из элементов целевой последовательности.<br>
<tt>ContainsAnyExcluding</tt>, <tt>IndexOfAnyExcluding</tt>, <tt>LastIndexOfAnyExcluding</tt> - поиск в исходном списке любого из элементов, отсутствующих в целевой последовательности.<br>
<tt>Filter</tt>, <tt>FilterInPlace</tt>.<br>
<tt>GetAfter</tt>, <tt>GetAfterLast</tt> - возвращает фрагмент исходного списка после целевой последовательности, либо, если ее нет в исходном списке, пустую коллекцию.<br>
<tt>GetBefore</tt>, <tt>GetBeforeLast</tt> - возвращает фрагмент исходного списка перед целевой последовательностью, либо, если ее нет в исходном списке, весь этот список.<br>
<tt>GetRange</tt>, принимающий именно Range, а не index и count, а также индексатор такой же формы.<br>
<tt>Pad</tt>, <tt>PadLeft</tt>, <tt>PadRight</tt> (аналогичны методам строки с такими же названиями).<br>
<tt>ReplaceRange</tt> - по форме удаляет диапазон и вставляет в место его бывшего начала нужную коллекцию, а по содержанию общие индексы копирует, а только отличающиеся удаляет или вставляет. Метод не проверял, могут быть ошибки.<br>
<tt>SetRange</tt> - записывает коллекцию элементов "поверх" того, что было в списке, начиная с index.<br>
<tt>StartsWith</tt>, <tt>EndsWith</tt> - проверяет, начинается ли или заканчивается ли исходный список на целевую последовательность.<br>
<br>
## Список обновлений
### Обновления библиотеки Corlib.NStar
**Обновление 1.** Добавилось огромное количество новых методов для работы с переменными типов Span&lt;T&gt; и ReadOnlySpan&lt;T&gt;, которые по неизвестным мне и не зависящим от меня причинам не наследуются от IEnumerable&lt;T&gt;. Число строк перешагнуло "круглую" отметку в 50k.<br><br>
**Обновление 2.** Методы нахождения экстремумов теперь являются non-nullable, возвращая 0 в случае пустой коллекции. Исправлена критическая ошибка в поведении словаря, из-за которой функция TryGetValue возвращала false, а прямое обращение по ключу могло вызвать исключение.<br><br>
**Обновление 3.** Добавлен небольшой и легкий в создании, но иногда нужный класс **LimitedQueue**, представляющий собой очередь ограниченной емкости, по достижению которой при попытке добавить еще один элемент - элементы из начала очереди будут удаляться.<br><br>
**Обновление 4.** Большое обновление, в ходе которого: старая библиотека BigCollections была объединена со стандартной библиотекой языка C# .NStar, и результат объединения стал называться Corlib .NStar; добавилась новая категория коллекций - множества, пока что только в виде всего одного конкретного класса HashSet&lt;T&gt;, а также абстрактного класса SetBase&lt;T, TCertain&gt;; в отличие от множеств, созданных Microsoft, множества от Red-Star-Soft могут работать не только как множества, но и как списки: их элементы имеют индексы, и для них можно вызвать большинство методов, которые можно вызвать для списков; переименованы некоторые методы и свойства, ключевое из которых - Count в Length - благодаря тому, что метод Count реализован в базовом интерфейсе явно, ни в одной коллекции от Red-Star-Soft свойства Count нет (разве что в какой-то забыл убрать); экспериментальные функции теперь выбрасывают исключение ExperimentalException, которое не прерывает работу программы, а служит только для оповещения - нажмите F5 для продолжения; модификатор доступа у непубличных членов списков был заменен с protected на private protected, чтобы их нельзя было переопределить вне нашей библиотеки; добавлен класс String, в котором конкатенация строк в цикле выполняется существенно быстрее, чем в строке от Microsoft, при этом строка от Microsoft неявно преобразуется в нашу, а ToString() выполняет обратное преобразование; наконец, во все типы списков добавлено множество новых методов: Equals с индексом (проверяется, равен ли диапазон списка какой-либо последовательности, не копируя этот диапазон) и основанные на нем (Last)IndexOf с последовательностью, GetBefore/After(Last), GetBeforeSetAfter(Last) и Starts/EndsWith, а также (Last)IndexOfAny и (Last)IndexOfAnyExcluding. Хронология изменений не соблюдена.<br><br>
**Обновление 5.** Corlib.NStar достигла "чугунного" уровня! Добавлен новый оптимизированный класс - ParallelHashSet&lt;T&gt;, в котором можно добавлять и удалять элементы параллельно (но либо добавлять, либо удалять, иначе могут быть ошибки!), и большинство стандартных методов уже делают это. Кроме того, как в новом классе, так теперь и в добавленном немного раньше HashSet&lt;T&gt;, хэш-коды и "корзины" (buckets, hashCode, next и freeList) теперь хранятся побитово инвертированными, что позволяет оптимизировать еще больше, так как в эти разнообразные "корзины" не нужно при инициализации и при каждом расширении записывать -1, а сама операция ~ занимает мизер времени. Тесты показали, что добавление 10<sup>8</sup> целых чисел, среди которых 65536 уникальных, в ParallelHashSet&lt;T&gt; при 4 потоках может быть до 32% быстрее, чем в System.Collections.Generic.HashSet&lt;T&gt;.<br><br>
**Обновление 6.** OptimizedLinq переименован в RedStarLinq, в котором максимально уменьшено количество конструирований новых списков, в том числе с помощью перебора последовательностей не через <tt>foreach</tt>, а напрямую через <tt>IEnumerator</tt>; в ParallelHashSet&lt;T&gt; устранен <tt>Parallel.ForEach</tt>, остался только <tt>Parallel.For</tt>; некоторые методы расширения теперь могут выполняться параллельно.<br><br>
**Обновление 7.** Добавлена новая категория коллекций - хэш-списки, которые могут содержать одинаковые элементы и искать элемент как по хэшам, так и линейным поиском, в том числе с возможностью автоматически определить более оптимальный вариант.<br><br>
**Обновление 8.** Важный патч, в котором существенно улучшена стабильность BitList, теперь вероятность ошибки составляет примерно 0.1%, и добавлен комплексный unit-тест с 1000 (псевдо)случайных итераций для предотвращения подобных поломок в будущем. Теперь, надеюсь, созданный в соавторстве с **Элд Хасп** метод копирования фрагментов списка бит работает полноценно! Хотя, конечно, на 100% гарантировать это нельзя никогда.<br><br>
**Обновление 9.** Добавлено множество на основе дерева, которое работает медленнее хэш-множеств, потребляет больше памяти, но всегда является отсортированным. А также TreeHashSet&lt;T&gt; - особая разновидность хэш-множества, в котором всегда корректные индексы, элементы добавляются и удаляются за O(logn), а поиск занимает Õ(1) - все благодаря внутреннему множеству-дереву удаленных элементов.<br><br>
**Обновление 10.** Corlib.NStar достигла "алюминиевого" уровня! Некоторые коллекции были переименованы, в частности, хэш-множества теперь называются FastDelHashSet&lt;T&gt; (с фейковыми индексами) и ListHashSet&lt;T&gt; (с медленным удалением), а хэш-списки - FastDelHashList&lt;T&gt; и просто HashList&lt;T&gt;, соответственно. Список бит теперь основан только на указателях, а не на массивах, благодаря чему создается меньше мусора, но никогда нельзя забывать после того, как список бит уже не нужен, вызвать метод Dispose().<br><br>
**Обновление 11.** Во все типы списков и множеств в NStar.Core наконец добавлены методы для замены элементов или целых блоков, как в строках от Microsoft. Хотя, конечно, еще многие их функции в нашей строке будут реализованы неизвестно когда...<br><br>
**Обновление 12.** Добавлены суммирующее множество (элементы имеют ключи, по которым отсортированы, и значения, организованные так, что легко посчитать их сумму от начала до любого заданного ключа), и суммирующий список (почти то же самое, только вместо ключей используются индексы). Все старые верифицируемые методы обычного списка, списка бит и нативного списка покрыты unit-тестами, благодаря чему эти классы, по сути, уже находятся на этапе беты.<br><br>
**Обновление 13.** Добавлены <s>большой массив и большой массив бит - благодаря чему пройдена значительная часть пути к тому, для чего эта библиотека, собственно, и проектировалась - к большому списку, но создание его самого́ будет нетривиальной задачей</s> - и зеркало - это что-то в стиле двунаправленного словаря, где ключ может быть значением, а значение - ключом, что можно было бы достичь с помощью двух симметричных друг другу словарей, обновляемых синхронно, но тогда все ключи и значения хранились бы по два раза, а в зеркале от Red-Star-Soft они хранятся по одному разу; с помощью индексатора можно получить или установить как значение по ключу, так и ключ по значению, но если они одного типа, возникнет ошибка из-за неоднозначности, и на этот случай в запасе есть методы GetValue(), SetValue(), GetKey() и SetKey(). Также, метод RedStarLinq Count() без параметров переименован в Length(), а старое название теперь принадлежит только методам подсчета количества элементов, соответствующих некоторому условию.<br><br>
**Обновление 14.** Новые классы - Slice&lt;T&gt; или срез - похож на Span&lt;T&gt;, но, в отличие от него, реализует интерфейс IEnumerable&lt;T&gt; - и Buffer&lt;T&gt; - коллекция фиксированной емкости, при превышении элементы удаляются из начала. Срез не наследуется от BaseList&lt;T, TCertain&gt;, вместо этого часть базового функционала выделена в еще более базовый класс BaseIndexable&lt;T, TCertain&gt;, от которого наследуются, кроме базового списка, все коллекции, в которых есть индексация, но которые нельзя изменять, в том числе и срез. RedStarLinq обновлен с учетом BaseIndexable&lt;T, TCertain&gt;, вследствие чего его длина превысила 70 тысяч строк. Также все индексируемые коллекции теперь имеют метод поэлементного сравнения двух коллекций, возвращающий индекс первого отличающегося элемента.<br><br>
**Обновление 15.** Corlib.NStar достигла "бронзового" уровня! Mpir.NET был переписан под .NET 7, вследствие чего компилятор больше не генерирует по надоедливому предупреждению, выдаваемому в тексте каждой сборки и постоянно "висящему" в списке ошибок, для каждого проекта в решении, ссылающегося на NStar.Core! Это был ПРОРЫВ!!! Впрочем, переписана только обертка, сама библиотека (GMP/Mpir) осталась в старой версии, и вряд ли когда-то я смогу сам написать обертку на новую. Тип большого числа теперь является не классом, а структурой, а его имя соответствует рекомендациям для языка C# - не **m**pz**&#95;t**, а **M**pz**T**. Кроме того, обновлен комплексный тест для ParallelHashSet&lt;T&gt; и написаны тест конструирования и тест на "вылет" для него же, а для корректности теста на "вылет" добавлены Debug.Assert после добавления и удаления элемента. Благодаря всему этому самое быстрое из существующих хэш-множество наконец достигло версии Alpha!<br><br>
**Обновление 16.** Все списки в NStar.Core получили новые варианты метода Replace() - можно заменить не только один диапазон на один, но и все пары в целом словаре! Поддерживаются словари из элемента в элемент, из элемента в диапазон, из пары элементов (задается кортежом, List&lt;T&gt; и NList&lt;T&gt; легко преобразуются в кортеж) в диапазон и из триады элементов в диапазон. Замена по словарю из диапазона в диапазон в разработке.<br><br>
**Обновление 17.** Добавлены экстенты Shuffle() и NShuffle() для перемешивания любой последовательности (по факту создают новую последовательность, являющуюся случайным порядком старой, так как ясно, что напрямую произвольный IEnumerable (например, цепь или коллекцию ключей словаря, которая бессмысленна без оригинального словаря) перемешать нельзя), а также ToParallelHashSet() для нашего супер-быстрого удаления дубликатов в последовательности).<br><br>
**Обновление 18.** Добавлены экстенты AllEqual(), AllUnique(), Product() и NGroup().<br><br>
**Обновление 19.** Исправлены основные экстенты RedStarLinq, потреблявшие неадекватное количество памяти, в том числе удалены перегрузки экстента Group() без параметров - они не имеют смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в последовательности, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их. Наконец осуществлена мечта, с которой начиналась библиотека BigCollections - **доведены до рабочего состояния классы BigList&ltT&gt; и BigBitList!** Они поддерживают добавление элемента или диапазона в конец, удаление элемента или диапазона из любого места, удаление от некоторого индекса и до конца, обрезку избытка емкости, копирование диапазона, в том числе в список с другой размерностью внутреннего дерева (а у него внутри дерево, так как создать массив длиной более 2 миллиардов элементов нельзя) и примерно 60 типов конструирования, но пока не поддерживает вставку в любое место (это в разработке). Есть ломающие изменения: из списка бит удален конструктор из нетипизированного IEnumerable, а из всех списков и множеств - метод Remove() с указанием только индекса как имеющий неоднозначное и вводящее в заблуждение название - взамен необходимо использовать Remove() с указанием диапазона, RemoveAt(), RemoveEnd() или RemoveValue().<br><br>
**Обновление 20.** Библиотека BigCollections.NStar вторично отделилась от Corlib.NStar, теперь .NStar по-настоящему является прототипом фреймворка, а не одной библиотекой. Это историческое событие для Red-Star-Soft!<br><br>
### Обновления фреймворка .NStar
**Обновление 1.** К сожалению, снова ломающие изменения, причем даже более серьезные, чем в обновлении 19 из истории библиотеки: удалены целых два класса - BigArray&lt;T&gt; и BigBitArray. Мы вынуждены признать, что наши предыдущие сообщения (например, в обновлении 13 из истории библиотеки) оказались ошибочными - эти классы никогда не работали корректно из-за серьезных ошибок в unit-тестах (по факту они ничего не проверяли, вот ничего и не работало). В большие списки (BigList&lt;T&gt; и BigBitList) добавлены методы Insert() (для одного элемента и для диапазона), Clear() (для диапазона) (формально был и раньше, но по факту стал рабочим только сейчас) и Reverse() (для всего списка), улучшены методы Contains(), IndexOf() и LastIndexOf().<br><br>
**Обновление 2.** Большое обновление, в ходе которого: многократно увеличилось количество библиотек; удалены многие методы поиска оптимумов, такие как FindMean(), FindMedian(), FindMedianIndex(); удалены хэш-списки - они нужны крайне редко, кому надо, может откопать их из истории; LINQ-подобные методы "разнесены" по множеству библиотек в зависимости от связи с каким-либо аспектом функционала фреймворка. Также библиотека EasyEval стала частью фреймворка и теперь называется EasyEval.NStar. Словари, параллельное хэш-множество, удаление дубликатов, отсортированные множества, суммирующие коллекции, множества на основе дерева получили собственные библиотеки. И наконец, огромный файл RedStarLinq.cs разбит на части, самый крупный кусок - RedStarLinqExtras.cs в проекте LINQ.NStar.<br><br>
**Обновление 3.** Были переименованы все пространства имен, связанные с .NStar - в их названии слово "NStar" теперь стоит в начале: NStar.Core (вместо Corlib.NStar), NStar.BigCollections, NStar.Linq, NStar.ParallelHS и т. д. Чтобы обновиться, включите "Найти и заменить" и пройдите по всем файлам следующими паттернами с регулярными выражениями (в таком порядке): "Corlib\.NStar" => "NStar.Core", "LINQ\.NStar" => "NStar.Linq", "([0-9A-Za-z&#95;]+?)\.NStar" => "NStar.$1". Не забудьте сделать это, иначе .NStar работать не будет!<br><br>
**Обновление 4.** Титаническая работа с большими списками завершилась успехом - тест на реверс части списка выполняется без ошибок! Это был последний из фундаментальных методов больших списков, все остальные текущие и будущие методы представляют собой комбинацию добавления одного элемента и диапазона, вставки одного элемента и диапазона, удаления одного элемента, диапазона от элемента до конца и диапазона в середине, очистки всего списка и диапазона, получения элемента и диапазона, установки элемента, проверки на равенство со списком того же типа, с произвольным большим списком, с "обычным" списком и с произвольным IEnumerable&lt;T&gt;, изменения емкости и реверса всего списка и диапазона, а также "супер-фундаментального" копирования диапазона, которое включают в себя многие "фундаментальные" операции. Но, к сожалению, пометить текущую версию как Alpha Vista мешают ужасные тормоза при попытке совершить больше нескольких десятков операций со списком хотя бы из тысячи элементов. Не знаю, сколько времени займет оптимизация - несколько дней или несколько лет, но это фундаментальный шаг при текущем раскладе. Очередная титаническая работа еще впереди!<br><br>
## Установка и настройка
**1.** В "Обозревателе решений" выделить основной проект и нажать "Показать все файлы".<br>
**2.** Открыть файл <tt>obj&#92;Debug&#92;net6.0&#92;&lt;ProjectName&gt;.GlobalUsings.g.cs</tt>.<br>
**3.** Скопировать содержимое и вставить его в любой пользовательский файл (например, Program.cs), удалив строки <tt>global using global::System.Collections.Generic;</tt> и <tt>global using global::System.Linq;</tt>.<br>
**4.** Если некоторые типы из этих пространств имен вам все же нужны (например, HashSet), добавьте в конец вставленного на предыдущем шаге блока <tt>global using G = global::System.Collections.Generic;</tt> и перед именами этих типов вставьте <tt>G.</tt>.<br>
**5.** Открыть файл &lt;ProjectName&gt;.csproj и удалить строку <tt>&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;</tt>.<br>
**6.** Если вам нужен класс String, его нужно подключать особым способом - в конец списка GlobalUsings добавьте следующую строку: <tt>global using String = NStar.Core.String;</tt>.<br>
**7.** При необходимости добавить экстра-библиотеки и подключить соответствующие пространства имен (название пространства имен совпадает с названием библиотеки).<br>
Примечание: точность всех названий до бита не гарантируется. Но вы же владеете интеллектом, а не только алгоритмом? На всякий случай проверяйте другие названия, похожие на вышеуказанные.<br>
<br>
## Контакты
Payeer: P19926501<br>
Monero: 49JGnrjidSzFF6Gi9CSNhDWeYWJcTnEkEXs4Bao6Da6peCjgvaUJ33m7Afmtz8qTAU2gMiLKvnxyDgA8QTNCVs7q79Shhph<br>
TRC20 (TRX, USDT etc.): TUKh42VHJNTSCmCdu5rnGo8fDotDK8rHA5<br>
Вопросы: adminATred-star-softDOTcom<br>
