<FONT size=20><B>Corlib .NStar</B></FONT> - стандартная библиотека фреймворка .NStar, изначально разрабатывавшаяся для языка под названием C# .NStar (а еще раньше сам язык сменил множество названий, пока не установилось это). Но теперь эта библиотека доступна для подключения к абсолютному большинству "нормальных" языков! ("Нормальных" - значит не эзотерических/игрушечных и не каких-то слишком упрощенных конструкторов.) Разумеется, в ней недоступны возможности, специфичные для языка, такие как практически полное отсутствие StackOverflow благодаря симуляции стека вызовов в куче или escape-последовательности \! и \q, но большинство возможностей реализуемы и в виде библиотеки для большинства языков. В библиотеку также полностью вошла старая библиотека BigCollections - запрос этого имени в GitHub перенаправляет сюда. Чтобы библиотека работала, необходимо:
<OL><LI>В "Обозревателе решений" выделить основной проект и нажать "Показать все файлы".</LI>
<LI>Открыть файл <TT>obj\Debug\net6.0\&lt;ProjectName&gt;.GlobalUsings.g.cs</TT>.</LI>
<LI>Скопировать содержимое и вставить его в любой пользовательский файл (например, Program.cs), удалив строки <TT>global using global::System.Collections.Generic;</TT> и <TT>global using global::System.Linq;</TT>.</LI>
<LI>Если некоторые типы из этих пространств имен вам все же нужны (например, HashSet), добавьте в конец вставленного на предыдущем шаге блока <TT>global using G = global::System.Collections.Generic;</TT> и перед именами этих типов вставьте <TT>G.</TT>.</LI>
<LI>Открыть файл &lt;ProjectName&gt;.csproj и удалить строку <TT>&lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;</TT>.</LI>
<LI>Если вам нужен класс String, его нужно подключать особым способом - в конец списка GlobalUsings добавьте следующую строку: <TT>global using String = Corlib.NStar.String;</TT>.<BR></LI></OL>
Примечание: точность всех названий до бита не гарантируется. Но вы же человек, а не машина? На всякий случай проверяйте другие названия, похожие на вышеуказанные.<BR><BR>
Библиотека содержит несколько типов коллекций - List, BitList, Dictionary и прочие. Классы похожи на соответствующие классы mscorlib, но в некоторых случаях более оптимизированы (а в некоторых - наоборот, это же The Fastest .NET Yet!). Оригинал взят с https://referencesource.microsoft.com/. В частности, оптимизированы для устранения лишних проходов по коллекциям методы List.Insert, List.InsertRange, SortedDictionary.Add, SortedDictionary.Search и прочие. Исправлен баг, вследствие которого InsertRange с IEnumerable, но не ICollection занимало квадратичное время.<BR>
Возможно, не всем понятно назначение класса <B>Chain</B>, так как у него нет аналогов в mscorlib. Он представляет собой цепь целых чисел, которая не хранится полностью, а только начало и длина. По ней можно даже итерироваться, не загружая в память полностью. Она создается полностью только при преобразовании в другой тип.<BR><BR>
Отдельного внимания заслуживает файл <B>OptimizedLinq.cs</B>. Он делает именно то, что в нем написано. Его код похож на автогенерируемый и по факту на 80% таким является. 19% - код, скопированный с автогенерирумемого, в котором произведены некоторые замены, и лишь 1% написан вручную. Также в нем существенно больше методов и разных их реализаций, чем в классическом LINQ.<BR>
Назначение большинства методов понятно из названия. Названия сделаны более понятными непосвященному, чем в классическом LINQ, где они взяты из SQL, который точно мало кому понятен. Методы, которые мне не удалось реализовать, просто вызывают методы классического LINQ (но тоже иногда переименованы).<BR>
В отличие от классического LINQ, реализованные мной методы возвращают List, а не IEnumerable (кроме преобразующих в конкретный тип коллекции), вследствие чего следующий метод выполняется существенно быстрее, чем в классическом LINQ. А некоторые методы вообще выполняются с другой асимптотикой - например, Count() для строки.<BR>
Все методы, у которых есть функция конверсии, поставляются с двумя ее версиями - только от элементов и от элементов и номера. Даже вызывающие классический LINQ.<BR><BR>
Вот описание методов, назначение которых может быть непонятно:<BR>
Any без параметров (только последовательность) - проверяет, что последовательность не пуста.<BR>
CopyDoubleList, CopyTripleList - копирует двумерный или трехмерный список полностью, а не только ссылки на (n - 1)-мерные списки, как new List<T>().<BR>
Fill - заполняет список одинаковыми значениями или функциями от номера элемента, позволяя не вычислять каждый раз пустой элемент. К сожалению, если вы укажете в elem объект ссылочного типа, список будет заполнен ссылками на один и тот же объект. Если кто знает, как исправить эту проблему - пишите в обсуждении. Для временного обхода используйте вторую функцию с _ вместо номера.<BR>
FindXIndexes, IndexesOfX - возвращает сразу ВСЕ индексы, в которых находится нужный элемент, а не только первый или последний.<BR>
Median - сортирует последовательность и возвращает значение, находящееся в середине.<BR>
Max/Mean/Median/Min(params &lt;type&gt;[] source) - позволяет вычислить нужную функцию, передав ей параметры один за другим, а не в виде коллекции - как Math.Max и Math.Min, только для произвольного числа параметров (но не меньше трех, так как для одного элемента функция тривиальна, а при двух функция существенно медленнее функции из Math). Рекомендуется указывать имя класса хотя бы одной буквой, так как иначе для двух элементов возникнет конфликт методов.<BR>
OfType - возвращает ТОЛЬКО элементы требуемого типа, игнорируя остальные. Этот метод работает с нетипизированным IEnumerable.<BR>
RepresentIntoNumbers - присваивает элементам последовательности номера, одинаковые для равных элементов и разные - для отличающихся, и возвращает список этих номеров. Нумерация начинается с нуля.<BR>
SetInnerType - приводит каждый элемент последовательности к нужному типу с помощью либо оператора явного приведения, либо пользовательской функции. Может выбросить InvalidCastException. Этот метод работает с нетипизированным IEnumerable.<BR>
ToArray поддерживает реализации как без параметров (прямой аналог метода классического LINQ), так и с параметрами - опять же для экономии количества проходов по последовательности. Еще больше самых разных реализаций доступно в методе ToDictionary.<BR>
TryGetCountEasily - пробует получить количество элементов без полного перебора коллекции. В отличие от метода классического LINQ, возвращает true для существенно большего множества типов. Этот метод работает как с типизированным, так и с нетипизированным IEnumerable.<BR>
Wrap и TryWrap - позволяют избежать как лишних действий, так и лишней строки кода в случае, когда результат вычисления очередного LINQ-метода используется в следующем несколько раз. По сути ничего функционального не делают, а только кэшируют поданную им последовательность, позволяя написать x вместо громоздкого выражения, и вызывают внутреннюю функцию.<BR><BR>
Тесты показали, что при первом запуске данные методы могут быть даже медленнее классических, становясь быстрее лишь после "разогрева" (и то только те, которые предназначены быть быстрыми).<BR>
Метод JoinIntoSingle необходимо вызывать, либо предварительно приведя средний тип двумерной коллекции к List, либо указывая в угловых скобках сначала этот средний тип вместе со внутренним, а затем целевой тип - если хоть один не указать, метод не работает!<BR>
Благодаря неоценимому участию Элд Хасп класс BitList способен копировать фрагменты своих экземпляров существенно быстрее, чем бит за битом. Сам я с этим бы не справился. <B>Элд Хасп</B>, еще раз благодарю вас, вы сделали очень много хорошего!<BR><BR>
Также списки (в том числе BitList) поддерживают несколько методов, которых нет в классических реализациях:<BR>
GetRange, принимающий именно Range, а не index и count, а также индексатор такой же формы.<BR>
SetRange - записывает коллекцию элементов "поверх" того, что было в списке, начиная с index.<BR>
ReplaceRange - по форме удаляет диапазон и вставляет в место его бывшего начала нужную коллекцию, а по содержанию общие индексы копирует, а только отличающиеся удаляет или вставляет. Метод не проверял, могут быть ошибки.<BR>
Также возможны ошибки и в других не самых популярных классах и методах, так как протестировать всё и во всех случаях невозможно.<BR><BR>
<B>Обновление 1.</B> Добавилось огромное количество новых методов для работы с переменными типов Span<T> и ReadOnlySpan<T>, которые по неизвестным мне и не зависящим от меня причинам не наследуются от IEnumerable<T>. Число строк перешагнуло "круглую" отметку в 50k.<BR><BR>
<B>Обновление 2.</B> Методы нахождения экстремумов теперь являются non-nullable, возвращая 0 в случае пустой коллекции. Исправлена критическая ошибка в поведении словаря, из-за которой функция TryGetValue возвращала false, а прямое обращение по ключу могло вызвать исключение.<BR><BR>
<B>Обновление 3.</B> Добавлен небольшой и легкий в создании, но иногда нужный класс <B>LimitedQueue</B>, представляющий собой очередь ограниченной емкости, по достижению которой при попытке добавить еще один элемент - элементы из начала очереди будут удаляться.<BR><BR>
<B>Обновление 4.</B> Большое обновление, в ходе которого: старая библиотека BigCollections была объединена со стандартной библиотекой языка C# .NStar, и результат объединения стал называться Corlib .NStar; добавилась новая категория коллекций - множества, пока что только в виде всего одного конкретного класса HashSet&lt;T&gt;, а также абстрактного класса SetBase&lt;T, TCertain&gt;; в отличие от множеств, созданных Microsoft, множества от Red-Star-Soft могут работать не только как множества, но и как списки: их элементы имеют индексы, и для них можно вызвать большинство методов, которые можно вызвать для списков; переименованы некоторые методы и свойства, ключевое из которых - Count в Length - благодаря тому, что метод Count реализован в базовом интерфейсе явно, ни в одной коллекции от Red-Star-Soft свойства Count нет (разве что в какой-то забыл убрать); экспериментальные функции теперь выбрасывают исключение ExperimentalException, которое не прерывает работу программы, а служит только для оповещения - нажмите F5 для продолжения; модификатор доступа у непубличных членов списков был заменен с protected на private protected, чтобы их нельзя было переопределить вне нашей библиотеки; добавлен класс String, в котором конкатенация строк в цикле выполняется существенно быстрее, чем в строке от Microsoft, при этом строка от Microsoft неявно преобразуется в нашу, а ToString() выполняет обратное преобразование; наконец, во все типы списков добавлено множество новых методов: Equals с индексом (проверяется, равен ли диапазон списка какой-либо последовательности, не копируя этот диапазон) и основанные на нем (Last)IndexOf с последовательностью, GetBefore/After(Last), GetBeforeSetAfter(Last) и Starts/EndsWith, а также (Last)IndexOfAny и (Last)IndexOfAnyExcluding. Хронология изменений не соблюдена.<BR><BR>
<B>Обновление 5.</B> Добавлен новый оптимизированный класс - ParallelHashSet&lt;T&gt;, в котором можно добавлять и удалять элементы параллельно (но либо добавлять, либо удалять, иначе могут быть ошибки!), и большинство стандартных методов уже делают это. Кроме того, как в новом классе, так теперь и в добавленном немного раньше HashSet&lt;T&gt;, хэш-коды и "корзины" (buckets, hashCode, next и freeList) теперь хранятся побитово инвертированными, что позволяет оптимизировать еще больше, так как в эти разнообразные "корзины" не нужно при инициализации и при каждом расширении записывать -1, а сама операция ~ занимает мизер времени. Тесты показали, что добавление 10<SUP>8</SUP> целых чисел, среди которых 65536 уникальных, в ParallelHashSet&lt;T&gt; при 4 потоках может быть до 32% быстрее, чем в System.Collections.Generic.HashSet&lt;T&gt;.<BR><BR>
Payeer: P19926501<BR>
Monero: 4AHvZX6BHNcZ6T2iCq4Ruu3nGXipEzjdyYPpvLGMqCzXartsMJoFBxRjXEeKRXDu96JCyYvvPunNnSMBeKYTS8iXBw9z6p3<BR>
