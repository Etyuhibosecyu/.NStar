using System.Numerics;
using System.Reflection;

namespace Corlib.NStar;

public partial class List<T, TCertain>
{
	internal static bool AllEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!function(item))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!function(item))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!function(item))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!function(item))
					return false;
			}
			return true;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (!function(item))
					return false;
				i++;
			}
			return true;
		}
	}

	internal static bool AllEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (!function(item, i))
					return false;
				i++;
			}
			return true;
		}
	}

	internal static bool AllEqualEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			var prev = function(list._items[0]);
			for (var i = 1; i < length; i++)
			{
				var item = function(list._items[i]);
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			var prev = function(array[0]);
			for (var i = 1; i < array.Length; i++)
			{
				var item = function(array[i]);
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			var prev = function(list2[0]);
			for (var i = 1; i < length; i++)
			{
				var item = function(list2[i]);
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			var prev = function(list3[0]);
			for (var i = 1; i < length; i++)
			{
				var item = function(list3[i]);
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
				prev = item;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			var prev = function(en.Current);
			while (en.MoveNext())
			{
				var item = function(en.Current);
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
				prev = item;
			}
			return true;
		}
	}

	internal static bool AllEqualEnumerable(IEnumerable<T> source, Func<T, T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			var prev = list._items[0];
			for (var i = 1; i < length; i++)
			{
				var item = list._items[i];
				if (!function(item, prev))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			var prev = array[0];
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				if (!function(item, prev))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			var prev = list2[0];
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				if (!function(item, prev))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			var prev = list3[0];
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				if (!function(item, prev))
					return false;
				prev = item;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			var prev = en.Current;
			while (en.MoveNext())
			{
				var item = en.Current;
				if (!function(item, prev))
					return false;
				prev = item;
			}
			return true;
		}
	}

	internal static bool AllEqualEnumerable(IEnumerable<T> source, Func<T, T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			var prev = list._items[0];
			for (var i = 1; i < length; i++)
			{
				var item = list._items[i];
				if (!function(item, prev, i - 1))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			var prev = array[0];
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				if (!function(item, prev, i - 1))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			var prev = list2[0];
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				if (!function(item, prev, i - 1))
					return false;
				prev = item;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			var prev = list3[0];
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				if (!function(item, prev, i - 1))
					return false;
				prev = item;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			var i = 1;
			var prev = en.Current;
			while (en.MoveNext())
			{
				var item = en.Current;
				if (!function(item, prev, i - 1))
					return false;
				prev = item;
				i++;
			}
			return true;
		}
	}

	internal static bool AllEqualEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			var prev = list._items[0];
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			var prev = array[0];
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			var prev = list2[0];
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			var prev = list3[0];
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			var prev = en.Current;
			while (en.MoveNext())
			{
				var item = en.Current;
				if (!(item?.Equals(prev) ?? prev == null))
					return false;
				prev = item;
			}
			return true;
		}
	}

	internal static bool AllUniqueEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			ListHashSet<TResult> hs = new(length, function(list._items[0]));
			for (var i = 1; i < length; i++)
			{
				var item = function(list._items[i]);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			ListHashSet<TResult> hs = new(array.Length, function(array[0]));
			for (var i = 1; i < array.Length; i++)
			{
				var item = function(array[i]);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			ListHashSet<TResult> hs = new(length, function(list2[0]));
			for (var i = 1; i < length; i++)
			{
				var item = function(list2[i]);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			ListHashSet<TResult> hs = new(length, function(list3[0]));
			for (var i = 1; i < length; i++)
			{
				var item = function(list3[i]);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			ListHashSet<TResult> hs = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 1024, function(en.Current));
			while (en.MoveNext())
			{
				var item = function(en.Current);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
	}

	internal static bool AllUniqueEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			ListHashSet<TResult> hs = new(length, function(list._items[0], 0));
			for (var i = 1; i < length; i++)
			{
				var item = function(list._items[i], i);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			ListHashSet<TResult> hs = new(array.Length, function(array[0], 0));
			for (var i = 1; i < array.Length; i++)
			{
				var item = function(array[i], i);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			ListHashSet<TResult> hs = new(length, function(list2[0], 0));
			for (var i = 1; i < length; i++)
			{
				var item = function(list2[i], i);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			ListHashSet<TResult> hs = new(length, function(list3[0], 0));
			for (var i = 1; i < length; i++)
			{
				var item = function(list3[i], i);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			ListHashSet<TResult> hs = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 1024, function(en.Current, 0));
			var i = 1;
			while (en.MoveNext())
			{
				var item = function(en.Current, i++);
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
	}

	internal static bool AllUniqueEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 1)
				return true;
			ListHashSet<T> hs = new(length, list._items[0]);
			for (var i = 1; i < length; i++)
			{
				var item = list._items[i];
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 1)
				return true;
			ListHashSet<T> hs = new(array.Length, array[0]);
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 1)
				return true;
			ListHashSet<T> hs = new(length, list2[0]);
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 1)
				return true;
			ListHashSet<T> hs = new(length, list3[0]);
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			if (!en.MoveNext())
				return true;
			ListHashSet<T> hs = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 1024, en.Current);
			while (en.MoveNext())
			{
				var item = en.Current;
				if (!hs.TryAdd(item))
					return false;
			}
			return true;
		}
	}

	internal static bool AnyEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					return true;
				i++;
			}
			return false;
		}
	}

	private class AppendList : BaseIndexable<T, AppendList>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly T element;

		public AppendList()
		{
			source = [];
			element = default!;
		}

		public AppendList(G.IReadOnlyList<T> source, T element)
		{
			this.source = source;
			this.element = element;
			_size = source.Count + 1;
		}

		public override Span<T> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, T[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override T GetInternal(int index, bool invoke = true) => index == source.Count ? element : source[index];

		private protected override AppendList GetRangeInternal(int index, int length) => index == _size - length ? new(source.GetROLSlice(index, length - 1), element) : new(source.GetROLSlice(index, length - 1), source[index + length - 1]);

		private protected override Slice<T> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(T item, int index, int length)
		{
			for (var i = index; i < Math.Min(index + length, source.Count); i++)
				if (source[i - 1]?.Equals(item) ?? item == null)
					return i;
			if (index == _size - length && (element?.Equals(item) ?? item == null))
				return source.Count;
			return -1;
		}

		private protected override int LastIndexOfInternal(T item, int index, int length)
		{
			if (index == source.Count && (element?.Equals(item) ?? item == null))
				return 0;
			var endIndex = index - length + 1;
			for (var i = Math.Min(index, source.Count - 1); i >= endIndex; i++)
				if (source[i - 1]?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	internal static Slice<T> AppendEnumerable(G.IReadOnlyList<T> source, T element) => new AppendList(source, element).GetROLSlice();

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<T>, List<T2>) BreakEnumerable<T2>(IEnumerable<(T, T2)> source)
	{
		if (source is List<(T, T2)> list)
		{
			var length = list._size;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list._items[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is (T, T2)[] array)
		{
			var length = array.Length;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<(T, T2)> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<T2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i]) = item;
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, (TResult, TResult2)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i]) = function(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i]) = function(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<T>, List<T2>, List<T3>) BreakEnumerable<T2, T3>(IEnumerable<(T, T2, T3)> source)
	{
		if (source is List<(T, T2, T3)> list)
		{
			var length = list._size;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list._items[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is (T, T2, T3)[] array)
		{
			var length = array.Length;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<(T, T2, T3)> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i], result3._items[i]) = item;
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static List<T> BreakFilterEnumerable(IEnumerable<T> source, Func<T, bool> function, out List<T> result2)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length / 2);
			result2 = new(array.Length / 2);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length / 2 : 0);
			result2 = new(length / 2);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
				i++;
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
	}

	internal static List<T> BreakFilterEnumerable(IEnumerable<T> source, Func<T, int, bool> function, out List<T> result2)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length / 2);
			result2 = new(array.Length / 2);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length / 2 : 0);
			result2 = new(length / 2);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
				i++;
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
	}

	private class CombineList<T2, TResult> : BaseIndexable<TResult, CombineList<T2, TResult>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly G.IReadOnlyList<T2> source2;
		private readonly Func<T, T2, TResult> function;

		public CombineList()
		{
			source = [];
			source2 = [];
			function = (x, y) => default!;
		}

		public CombineList(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, TResult> function)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(source2);
			ArgumentNullException.ThrowIfNull(function);
			this.source = source;
			this.source2 = source2;
			this.function = function;
			_size = Math.Min(source.Count, source2.Count);
		}

		public override Span<TResult> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, TResult[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override TResult GetInternal(int index, bool invoke = true) => function(source[index], source2[index]);

		private protected override CombineList<T2, TResult> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), source2.GetROLSlice(index, length), function);

		private protected override Slice<TResult> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(TResult item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if (function(source[i], source2[i])?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(TResult item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if (function(source[i], source2[i])?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	private class CombineListInt<T2, TResult> : BaseIndexable<TResult, CombineListInt<T2, TResult>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly G.IReadOnlyList<T2> source2;
		private readonly Func<T, T2, int, TResult> function;

		public CombineListInt()
		{
			source = [];
			source2 = [];
			function = (x, y, index) => default!;
		}

		public CombineListInt(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, int, TResult> function)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(source2);
			ArgumentNullException.ThrowIfNull(function);
			this.source = source;
			this.source2 = source2;
			this.function = function;
			_size = Math.Min(source.Count, source2.Count);
		}

		public override Span<TResult> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, TResult[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override TResult GetInternal(int index, bool invoke = true) => function(source[index], source2[index], index);

		private protected override CombineListInt<T2, TResult> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), source2.GetROLSlice(index, length), function);

		private protected override Slice<TResult> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(TResult item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if (function(source[i], source2[i], i)?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(TResult item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if (function(source[i], source2[i], i)?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	private class CombineListPure<T2> : BaseIndexable<(T, T2), CombineListPure<T2>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly G.IReadOnlyList<T2> source2;

		public CombineListPure()
		{
			source = [];
			source2 = [];
		}

		public CombineListPure(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(source2);
			this.source = source;
			this.source2 = source2;
			_size = Math.Min(source.Count, source2.Count);
		}

		public override Span<(T, T2)> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, (T, T2)[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override (T, T2) GetInternal(int index, bool invoke = true) => (source[index], source2[index]);

		private protected override CombineListPure<T2> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), source2.GetROLSlice(index, length));

		private protected override Slice<(T, T2)> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal((T, T2) item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if ((source[i]?.Equals(item.Item1) ?? item.Item1 == null) && (source2[i]?.Equals(item.Item2) ?? item.Item2 == null))
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal((T, T2) item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if ((source[i]?.Equals(item.Item1) ?? item.Item1 == null) && (source2[i]?.Equals(item.Item2) ?? item.Item2 == null))
					return i;
			return -1;
		}
	}

	private class CombineList<T2, T3, TResult> : BaseIndexable<TResult, CombineList<T2, T3, TResult>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly G.IReadOnlyList<T2> source2;
		private readonly G.IReadOnlyList<T3> source3;
		private readonly Func<T, T2, T3, TResult> function;

		public CombineList()
		{
			source = [];
			source2 = [];
			source3 = [];
			function = (x, y, z) => default!;
		}

		public CombineList(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, TResult> function)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(source2);
			ArgumentNullException.ThrowIfNull(source3);
			ArgumentNullException.ThrowIfNull(function);
			this.source = source;
			this.source2 = source2;
			this.source3 = source3;
			this.function = function;
			_size = NList<bool>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count });
		}

		public override Span<TResult> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, TResult[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override TResult GetInternal(int index, bool invoke = true) => function(source[index], source2[index], source3[index]);

		private protected override CombineList<T2, T3, TResult> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), source2.GetROLSlice(index, length), source3.GetROLSlice(index, length), function);

		private protected override Slice<TResult> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(TResult item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if (function(source[i], source2[i], source3[i])?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(TResult item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if (function(source[i], source2[i], source3[i])?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	private class CombineListInt<T2, T3, TResult> : BaseIndexable<TResult, CombineListInt<T2, T3, TResult>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly G.IReadOnlyList<T2> source2;
		private readonly G.IReadOnlyList<T3> source3;
		private readonly Func<T, T2, T3, int, TResult> function;

		public CombineListInt()
		{
			source = [];
			source2 = [];
			source3 = [];
			function = (x, y, z, index) => default!;
		}

		public CombineListInt(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, int, TResult> function)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(source2);
			ArgumentNullException.ThrowIfNull(source3);
			ArgumentNullException.ThrowIfNull(function);
			this.source = source;
			this.source2 = source2;
			this.source3 = source3;
			this.function = function;
			_size = NList<bool>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count });
		}

		public override Span<TResult> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, TResult[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override TResult GetInternal(int index, bool invoke = true) => function(source[index], source2[index], source3[index], index);

		private protected override CombineListInt<T2, T3, TResult> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), source2.GetROLSlice(index, length), source3.GetROLSlice(index, length), function);

		private protected override Slice<TResult> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(TResult item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if (function(source[i], source2[i], source3[i], i)?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(TResult item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if (function(source[i], source2[i], source3[i], i)?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	private class CombineListPure<T2, T3> : BaseIndexable<(T, T2, T3), CombineListPure<T2, T3>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly G.IReadOnlyList<T2> source2;
		private readonly G.IReadOnlyList<T3> source3;

		public CombineListPure()
		{
			source = [];
			source2 = [];
			source3 = [];
		}

		public CombineListPure(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(source2);
			ArgumentNullException.ThrowIfNull(source3);
			this.source = source;
			this.source2 = source2;
			this.source3 = source3;
			_size = NList<bool>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count });
		}

		public override Span<(T, T2, T3)> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, (T, T2, T3)[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override (T, T2, T3) GetInternal(int index, bool invoke = true) => (source[index], source2[index], source3[index]);

		private protected override CombineListPure<T2, T3> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), source2.GetROLSlice(index, length), source3.GetROLSlice(index, length));

		private protected override Slice<(T, T2, T3)> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal((T, T2, T3) item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if ((source[i]?.Equals(item.Item1) ?? item.Item1 == null) && (source2[i]?.Equals(item.Item2) ?? item.Item2 == null) && (source3[i]?.Equals(item.Item3) ?? item.Item3 == null))
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal((T, T2, T3) item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if ((source[i]?.Equals(item.Item1) ?? item.Item1 == null) && (source2[i]?.Equals(item.Item2) ?? item.Item2 == null) && (source3[i]?.Equals(item.Item3) ?? item.Item3 == null))
					return i;
			return -1;
		}
	}

	internal static Slice<TResult> CombineEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, TResult> function) => new CombineList<T2, TResult>(source, source2, function).GetSlice();

	internal static Slice<TResult> CombineEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, int, TResult> function) => new CombineListInt<T2, TResult>(source, source2, function).GetSlice();

	internal static Slice<(T, T2)> CombineEnumerable<T2>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2) => new CombineListPure<T2>(source, source2).GetSlice();

	internal static Slice<TResult> CombineEnumerable<T2, T3, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, TResult> function) => new CombineList<T2, T3, TResult>(source, source2, source3, function).GetSlice();

	internal static Slice<TResult> CombineEnumerable<T2, T3, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, int, TResult> function) => new CombineListInt<T2, T3, TResult>(source, source2, source3, function).GetSlice();

	internal static Slice<(T, T2, T3)> CombineEnumerable<T2, T3>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3) => new CombineListPure<T2, T3>(source, source2, source3).GetSlice();

	internal static IEnumerable<TResult> CombineEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				yield return function(item, item2, i);
			}
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				yield return function(item, item2, i);
			}
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				yield return function(item, item2, i);
			}
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				yield return function(item, item2, i);
			}
		}
		else
		{
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext())
			{
				var item = en.Current;
				var item2 = en2.Current;
				yield return function(item, item2, i);
				i++;
			}
		}
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = MinEnumerable(new[] { list._size, list3._size, list3._size }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				var item3 = list3._items[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2 && source3 is G.IReadOnlyList<T3> list3_3)
		{
			var length = MinEnumerable(new[] { list3_.Count, list3_2.Count, list3_3.Count }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				var item3 = list3_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : TryGetLengthEasilyEnumerable(source3, out length) ? length : 1024);
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			using var en3 = source3.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext() && en3.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				var item3 = en3.Current;
				result._items[i] = function(item, item2, item3);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = MinEnumerable(new[] { list._size, list3._size, list3._size }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				var item3 = list3._items[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2 && source3 is G.IReadOnlyList<T3> list3_3)
		{
			var length = MinEnumerable(new[] { list3_.Count, list3_2.Count, list3_3.Count }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				var item3 = list3_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : TryGetLengthEasilyEnumerable(source3, out length) ? length : 1024);
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			using var en3 = source3.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext() && en3.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				var item3 = en3.Current;
				result._items[i] = function(item, item2, item3, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<T> ConcatEnumerable(IEnumerable<T> source, params IEnumerable<T>[] collections)
	{
		ArgumentNullException.ThrowIfNull(collections);
		List<T> result = new(source);
		for (var i = 0; i < collections.Length; i++)
			result.AddRange(collections[i]);
		return result;
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target, IEqualityComparer<T> comparer)
	{
		ArgumentNullException.ThrowIfNull(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(equalFunction);
		var comparer = new EComparer<T>(equalFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(equalFunction);
		ArgumentNullException.ThrowIfNull(hashCodeFunction);
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	private class ConvertList<TResult> : BaseIndexable<TResult, ConvertList<TResult>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly Func<T, TResult> function;

		public ConvertList()
		{
			source = [];
			function = x => default!;
		}

		public ConvertList(G.IReadOnlyList<T> source, Func<T, TResult> function)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(function);
			this.source = source;
			this.function = function;
			_size = source.Count;
		}

		public override Span<TResult> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, TResult[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override TResult GetInternal(int index, bool invoke = true) => function(source[index]);

		private protected override ConvertList<TResult> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), function);

		private protected override Slice<TResult> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(TResult item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if (function(source[i])?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(TResult item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if (function(source[i])?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	private class ConvertListInt<TResult> : BaseIndexable<TResult, ConvertListInt<TResult>>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly Func<T, int, TResult> function;

		public ConvertListInt()
		{
			source = [];
			function = (x, index) => default!;
		}

		public ConvertListInt(G.IReadOnlyList<T> source, Func<T, int, TResult> function)
		{
			ArgumentNullException.ThrowIfNull(source);
			ArgumentNullException.ThrowIfNull(function);
			this.source = source;
			this.function = function;
			_size = source.Count;
		}

		public override Span<TResult> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, TResult[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override TResult GetInternal(int index, bool invoke = true) => function(source[index], index);

		private protected override ConvertListInt<TResult> GetRangeInternal(int index, int length) => new(source.GetROLSlice(index, length), function);

		private protected override Slice<TResult> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(TResult item, int index, int length)
		{
			for (var i = index; i < index + length; i++)
				if (function(source[i], i)?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(TResult item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= endIndex; i++)
				if (function(source[i], i)?.Equals(item) ?? item == null)
					return i;
			return -1;
		}
	}

	internal static Slice<TResult> ConvertEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function) => new ConvertList<TResult>(source, function).GetSlice();

	internal static Slice<TResult> ConvertEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function) => new ConvertListInt<TResult>(source, function).GetSlice();

	internal static int CountEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list._items[i]))
					n++;
			return n;
		}
		else if (source is T[] array)
		{
			var n = 0;
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					n++;
			return n;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					n++;
			return n;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list3[i]))
					n++;
			return n;
		}
		else
		{
			var n = 0;
			foreach (var item in source)
				if (function(item))
					n++;
			return n;
		}
	}

	internal static int CountEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list._items[i], i))
					n++;
			return n;
		}
		else if (source is T[] array)
		{
			var n = 0;
			for (var i = 0; i < array.Length; i++)
				if (function(array[i], i))
					n++;
			return n;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list2[i], i))
					n++;
			return n;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list3[i], i))
					n++;
			return n;
		}
		else
		{
			var n = 0;
			var i = 0;
			foreach (var item in source)
				if (function(item, i++))
					n++;
			return n;
		}
	}

	internal static int CountEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			var n = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is T[] array)
		{
			var n = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else
		{
			var n = 0;
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					n++;
				i++;
			}
			return n;
		}
	}

	internal static List<T> EmptyListEnumerable(int length) => new(length) { _size = length };

	internal static bool EqualsEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2))
					return false;
			}
			return list._size == list2._size;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			var length = list2_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			if (list3_.Count != list3_2.Count)
				return false;
			var length = list3_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			while (en.MoveNext())
			{
				if (!en2.MoveNext())
					return false;
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2))
					return false;
			}
			return !en2.MoveNext();
		}
	}

	internal static bool EqualsEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size != list2._size)
				return false;
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			var length = list2_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			if (list3_.Count != list3_2.Count)
				return false;
			var length = list3_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext())
			{
				if (!en2.MoveNext())
					return false;
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2, i))
					return false;
				i++;
			}
			return !en2.MoveNext();
		}
	}

	internal static bool EqualsEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size != list2._size)
				return false;
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			var length = list2_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			if (list3_.Count != list3_2.Count)
				return false;
			var length = list3_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else
		{
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			while (en.MoveNext())
			{
				if (!en2.MoveNext())
					return false;
				var item = en.Current;
				var item2 = en2.Current;
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return !en2.MoveNext();
		}
	}

	internal static List<TResult> FillEnumerable<TResult>(TResult elem, int length)
	{
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = elem;
		result._size = length;
		return result;
	}

	internal static List<TResult> FillEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		ArgumentNullException.ThrowIfNull(function);
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(i);
		result._size = length;
		return result;
	}

	internal static TResult[] FillArrayEnumerable<TResult>(TResult elem, int length)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(length);
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = elem;
		return result;
	}

	internal static TResult[] FillArrayEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(length);
		ArgumentNullException.ThrowIfNull(function);
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = function(i);
		return result;
	}

	internal static T? FindEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					return item;
				i++;
			}
			return default;
		}
	}

	internal static T? FindEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					return item;
				i++;
			}
			return default;
		}
	}

	internal static List<T> FindAllEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindAllEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static int FindIndexEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				if (function(list._items[i]))
					return i;
			return default;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					return i;
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					return i;
			return default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
				if (function(list3[i]))
					return i;
			return default;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					return i;
				i++;
			}
			return default;
		}
	}

	internal static int FindIndexEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static T? FindLastEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else
			return FindLastEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else
			return FindLastEnumerable(new List<T>(source), function);
	}

	internal static int FindLastIndexEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
				if (function(list._items[i]))
					return i;
			return -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
				if (function(array[i]))
					return i;
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
				if (function(list2[i]))
					return i;
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
				if (function(list3[i]))
					return i;
			return -1;
		}
		else
			return FindLastIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastIndexEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else
			return FindLastIndexEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindLastEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindLastEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindLastIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function, out indicator);
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			return FindEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(list3, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			indicator = value;
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var value = MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			indicator = value;
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static void ForEachEnumerable(IEnumerable<T> source, Action<T> action)
	{
		ArgumentNullException.ThrowIfNull(action);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				action(list._items[i]);
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				action(array[i]);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				action(list2[i]);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
				action(list3[i]);
		}
		else
		{
			foreach (var item in source)
				action(item);
		}
	}

	internal static void ForEachEnumerable(IEnumerable<T> source, Action<T, int> action)
	{
		ArgumentNullException.ThrowIfNull(action);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				action(list._items[i], i);
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				action(array[i], i);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				action(list2[i], i);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
				action(list3[i], i);
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				action(item, i);
				i++;
			}
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result.Add((f, 1));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new(32, i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result.Add(new(32, i, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target, IEqualityComparer<T> comparer)
	{
		ArgumentNullException.ThrowIfNull(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(equalFunction);
		var comparer = new EComparer<T>(equalFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(equalFunction);
		ArgumentNullException.ThrowIfNull(hashCodeFunction);
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is MpzT[] array)
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<decimal>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<double>.IndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var value = (int)(List<int>.SumEnumerable(list, x => (long)x) / Math.Max(list.Length, 1));
			return List<int>.IndexOfEnumerable(list, value);
		}
		else if (source is int[] array)
		{
			var value = (int)(List<int>.SumEnumerable(array.AsSpan(), x => (long)x) / Math.Max(array.Length, 1));
			return List<int>.IndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<int> list2)
		{
			var value = (int)(List<int>.SumEnumerable(list2, x => (long)x) / Math.Max(list2.Count, 1));
			return List<int>.IndexOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var value = (uint)(List<uint>.SumEnumerable(list, x => (long)x) / Math.Max(list.Length, 1));
			return List<uint>.IndexOfEnumerable(list, value);
		}
		else if (source is uint[] array)
		{
			var value = (uint)(List<uint>.SumEnumerable(array.AsSpan(), x => (long)x) / Math.Max(array.Length, 1));
			return List<uint>.IndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<uint> list2)
		{
			var value = (uint)(List<uint>.SumEnumerable(list2, x => (long)x) / Math.Max(list2.Count, 1));
			return List<uint>.IndexOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var value = (long)(List<long>.SumEnumerable(list, x => (MpzT)x) / Math.Max(list.Length, 1));
			return List<long>.IndexOfEnumerable(list, value);
		}
		else if (source is long[] array)
		{
			var value = (long)(List<long>.SumEnumerable(array.AsSpan(), x => (MpzT)x) / Math.Max(array.Length, 1));
			return List<long>.IndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<long> list2)
		{
			var value = (long)(List<long>.SumEnumerable(list2, x => (MpzT)x) / Math.Max(list2.Count, 1));
			return List<long>.IndexOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var value = NList<bool>.SumEnumerable(list) / Math.Max(list.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list, value);
		}
		else if (source is MpzT[] array)
		{
			var value = SumEnumerable(array.AsSpan()) / Math.Max(array.Length, 1);
			return List<MpzT>.IndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<MpzT> list2)
		{
			var value = NList<bool>.SumEnumerable(list2) / Math.Max(list2.Count, 1);
			return List<MpzT>.IndexOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToListEnumerable(source, function);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is MpzT[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<MpzT> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is MpzT[] array)
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<List<T>> source)
	{
		if (source is List<List<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is List<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<List<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(IEnumerable<TSource> source) where TSource : IEnumerable<TResult>
	{
		if (source is List<TSource> list)
		{
			var length = list._size;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
				result.AddRange(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result.AddRange(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
				result.AddRange(list2[i]);
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<T[]> source)
	{
		if (source is List<T[]> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is T[][] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T[]> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<G.IList<T>> source)
	{
		if (source is List<G.IList<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<G.IList<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<IEnumerable<T>> source)
	{
		if (source is List<IEnumerable<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is IEnumerable<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<IEnumerable<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<List<T>> source, T separator)
	{
		if (source is List<List<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is List<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<List<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.Add(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(IEnumerable<TSource> source, TResult separator) where TSource : IEnumerable<TResult>
	{
		if (source is List<TSource> list)
		{
			var length = list._size;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.Add(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<T[]> source, T separator)
	{
		if (source is List<T[]> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is T[][] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T[]> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.Add(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<G.IList<T>> source, T separator)
	{
		if (source is List<G.IList<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<G.IList<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.Add(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<IEnumerable<T>> source, T separator)
	{
		if (source is List<IEnumerable<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is IEnumerable<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<IEnumerable<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.Add(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.Add(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<List<T>> source, IEnumerable<T> separator)
	{
		if (source is List<List<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is List<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<List<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.AddRange(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(IEnumerable<TSource> source, IEnumerable<TResult> separator) where TSource : IEnumerable<TResult>
	{
		if (source is List<TSource> list)
		{
			var length = list._size;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.AddRange(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<T[]> source, IEnumerable<T> separator)
	{
		if (source is List<T[]> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is T[][] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T[]> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.AddRange(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<G.IList<T>> source, IEnumerable<T> separator)
	{
		if (source is List<G.IList<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<G.IList<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.AddRange(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<IEnumerable<T>> source, IEnumerable<T> separator)
	{
		if (source is List<IEnumerable<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is IEnumerable<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<IEnumerable<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				if (i != 0)
					result.AddRange(separator);
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (i != 0)
					result.AddRange(separator);
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target);
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target, IEqualityComparer<T> comparer)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = array.Length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target, comparer);
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = array.Length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target, equalFunction);
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = array.Length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target, equalFunction, hashCodeFunction);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new NList<decimal>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new NList<double>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new NList<int>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new NList<uint>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new NList<long>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is MpzT[] array)
		{
			var length = array.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new NList<MpzT>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<int>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return List<long>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			var value = NList<bool>.SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new NList<decimal>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.LastIndexOfEnumerable(list_, NList<bool>.MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new NList<double>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var value = (int)(List<int>.SumEnumerable(list, x => (long)x) / Math.Max(list.Length, 1));
			return List<int>.LastIndexOfEnumerable(list, value);
		}
		else if (source is int[] array)
		{
			var value = (int)(List<int>.SumEnumerable(array.AsSpan(), x => (long)x) / Math.Max(array.Length, 1));
			return List<int>.LastIndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<int> list2)
		{
			var value = (int)(List<int>.SumEnumerable(list2, x => (long)x) / Math.Max(list2.Count, 1));
			return List<int>.LastIndexOfEnumerable(list2, value);
		}
		else
			return LastIndexOfMeanEnumerable(new NList<int>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var value = (uint)(List<uint>.SumEnumerable(list, x => (long)x) / Math.Max(list.Length, 1));
			return List<uint>.LastIndexOfEnumerable(list, value);
		}
		else if (source is uint[] array)
		{
			var value = (uint)(List<uint>.SumEnumerable(array.AsSpan(), x => (long)x) / Math.Max(array.Length, 1));
			return List<uint>.LastIndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<uint> list2)
		{
			var value = (uint)(List<uint>.SumEnumerable(list2, x => (long)x) / Math.Max(list2.Count, 1));
			return List<uint>.LastIndexOfEnumerable(list2, value);
		}
		else
			return LastIndexOfMeanEnumerable(new NList<uint>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var value = (long)(List<long>.SumEnumerable(list, x => (MpzT)x) / Math.Max(list.Length, 1));
			return List<long>.LastIndexOfEnumerable(list, value);
		}
		else if (source is long[] array)
		{
			var value = (long)(List<long>.SumEnumerable(array.AsSpan(), x => (MpzT)x) / Math.Max(array.Length, 1));
			return List<long>.LastIndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<long> list2)
		{
			var value = (long)(List<long>.SumEnumerable(list2, x => (MpzT)x) / Math.Max(list2.Count, 1));
			return List<long>.LastIndexOfEnumerable(list2, value);
		}
		else
			return LastIndexOfMeanEnumerable(new NList<long>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var value = NList<bool>.SumEnumerable(list) / Math.Max(list.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(list, value);
		}
		else if (source is MpzT[] array)
		{
			var value = SumEnumerable(array.AsSpan()) / Math.Max(array.Length, 1);
			return List<MpzT>.LastIndexOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<MpzT> list2)
		{
			var value = NList<bool>.SumEnumerable(list2) / Math.Max(list2.Count, 1);
			return List<MpzT>.LastIndexOfEnumerable(list2, value);
		}
		else
			return LastIndexOfMeanEnumerable(new NList<MpzT>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ToListEnumerable(list, function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ToListEnumerable(array.AsSpan(), function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2.GetSlice(), function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var list_ = ConvertEnumerable(list3, function);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new NList<decimal>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new NList<double>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new NList<int>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new NList<uint>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new NList<long>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is MpzT[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<MpzT> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new NList<MpzT>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list3[i];
				if (i == length - 1)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new NList<decimal>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new NList<double>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new NList<int>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new NList<uint>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new NList<long>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list.GetInternal(i);
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is MpzT[] array)
		{
			var length = array.Length;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			var result = -1;
			MpzT indicator = 0;
			MpzT f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == length - 1)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new NList<MpzT>(source));
	}

	internal static int LengthEnumerable(IEnumerable<T> source)
	{
		if (TryGetLengthEasilyEnumerable(source, out var length))
			return length;
		else
		{
			var n = 0;
			using var en = source.GetEnumerator();
			while (en.MoveNext()) n++;
			return n;
		}
	}

	internal static decimal MaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Max(function(list._items[0]), function(list._items[1])),
					3 => Math.Max(Math.Max(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Max(function(array[0]), function(array[1])),
					3 => Math.Max(Math.Max(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Max(function(list2[0]), function(list2[1])),
					3 => Math.Max(Math.Max(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Max(function(list3[0]), function(list3[1])),
					3 => Math.Max(Math.Max(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Max(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Max(Math.Max(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Max(function(array[0], 0), function(array[1], 1)),
					3 => Math.Max(Math.Max(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Max(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Max(Math.Max(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Max(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Max(Math.Max(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Max(function(list._items[0]), function(list._items[1])),
					3 => Math.Max(Math.Max(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Max(function(array[0]), function(array[1])),
					3 => Math.Max(Math.Max(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Max(function(list2[0]), function(list2[1])),
					3 => Math.Max(Math.Max(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Max(function(list3[0]), function(list3[1])),
					3 => Math.Max(Math.Max(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Max(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Max(Math.Max(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Max(function(array[0], 0), function(array[1], 1)),
					3 => Math.Max(Math.Max(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Max(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Max(Math.Max(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Max(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Max(Math.Max(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Max(function(list._items[0]), function(list._items[1])),
					3 => Math.Max(Math.Max(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Max(function(array[0]), function(array[1])),
					3 => Math.Max(Math.Max(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Max(function(list2[0]), function(list2[1])),
					3 => Math.Max(Math.Max(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Max(function(list3[0]), function(list3[1])),
					3 => Math.Max(Math.Max(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Max(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Max(Math.Max(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			var indicator = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Max(function(array[0], 0), function(array[1], 1)),
					3 => Math.Max(Math.Max(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Max(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Max(Math.Max(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Max(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Max(Math.Max(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Max(function(list._items[0]), function(list._items[1])),
					3 => Math.Max(Math.Max(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Max(function(array[0]), function(array[1])),
					3 => Math.Max(Math.Max(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Max(function(list2[0]), function(list2[1])),
					3 => Math.Max(Math.Max(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Max(function(list3[0]), function(list3[1])),
					3 => Math.Max(Math.Max(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Max(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Max(Math.Max(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Max(function(array[0], 0), function(array[1], 1)),
					3 => Math.Max(Math.Max(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Max(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Max(Math.Max(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Max(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Max(Math.Max(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Max(function(list._items[0]), function(list._items[1])),
					3 => Math.Max(Math.Max(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Max(function(array[0]), function(array[1])),
					3 => Math.Max(Math.Max(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Max(function(list2[0]), function(list2[1])),
					3 => Math.Max(Math.Max(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Max(function(list3[0]), function(list3[1])),
					3 => Math.Max(Math.Max(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Max(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Max(Math.Max(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Max(function(array[0], 0), function(array[1], 1)),
					3 => Math.Max(Math.Max(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Max(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Max(Math.Max(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Max(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Max(Math.Max(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static MpzT MaxEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => MpzT.Max(function(list._items[0]), function(list._items[1])),
					3 => MpzT.Max(MpzT.Max(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => MpzT.Max(function(array[0]), function(array[1])),
					3 => MpzT.Max(MpzT.Max(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => MpzT.Max(function(list2[0]), function(list2[1])),
					3 => MpzT.Max(MpzT.Max(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => MpzT.Max(function(list3[0]), function(list3[1])),
					3 => MpzT.Max(MpzT.Max(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static MpzT MaxEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => MpzT.Max(function(list._items[0], 0), function(list._items[1], 1)),
					3 => MpzT.Max(MpzT.Max(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => MpzT.Max(function(array[0], 0), function(array[1], 1)),
					3 => MpzT.Max(MpzT.Max(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => MpzT.Max(function(list2[0], 0), function(list2[1], 1)),
					3 => MpzT.Max(MpzT.Max(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => MpzT.Max(function(list3[0], 0), function(list3[1], 1)),
					3 => MpzT.Max(MpzT.Max(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MeanEnumerable(IEnumerable<T> source, Func<T, decimal> function) => MeanInternal<T, decimal, decimal, decimal>(source, function);

	internal static decimal MeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function) => MeanInternal<T, decimal, decimal, decimal>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, double> function) => MeanInternal<T, double, double, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, double> function) => MeanInternal<T, double, double, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int> function) => MeanInternal<T, int, long, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, int> function) => MeanInternal<T, int, long, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, uint> function) => MeanInternal<T, uint, ulong, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function) => MeanInternal<T, uint, ulong, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, long> function) => MeanInternal<T, long, MpzT, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, long> function) => MeanInternal<T, long, MpzT, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, MpzT> function) => MeanInternal<T, MpzT, MpzT, double>(source, function);

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function) => MeanInternal<T, MpzT, MpzT, double>(source, function);

	private static TResult MeanInternal<TSource, TFunction, TAccumulator, TResult>(IEnumerable<TSource> source, Func<TSource, TFunction> function) where TFunction : struct, INumber<TFunction> where TAccumulator : struct, INumber<TAccumulator> where TResult : struct, INumber<TResult>
	{
		ArgumentNullException.ThrowIfNull(source);
		ArgumentNullException.ThrowIfNull(function);
		using var e = source.GetEnumerator();
		if (!e.MoveNext())
			return TResult.Zero;
		var sum = TAccumulator.CreateChecked(function(e.Current));
		var count = 1;
		while (e.MoveNext())
		{
			checked
			{
				sum += TAccumulator.CreateChecked(function(e.Current));
				count++;
			}
		}
		return TResult.CreateChecked(sum) / TResult.CreateChecked(count);
	}

	private static TResult MeanInternal<TSource, TFunction, TAccumulator, TResult>(IEnumerable<TSource> source, Func<TSource, int, TFunction> function) where TFunction : struct, INumber<TFunction> where TAccumulator : struct, INumber<TAccumulator> where TResult : struct, INumber<TResult>
	{
		ArgumentNullException.ThrowIfNull(source);
		ArgumentNullException.ThrowIfNull(function);
		using var e = source.GetEnumerator();
		if (!e.MoveNext())
			return TResult.Zero;
		var sum = TAccumulator.CreateChecked(function(e.Current, 0));
		var count = 1;
		while (e.MoveNext())
		{
			checked
			{
				sum += TAccumulator.CreateChecked(function(e.Current, count));
				count++;
			}
		}
		return TResult.CreateChecked(sum) / TResult.CreateChecked(count);
	}

	internal static decimal MedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static decimal MedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static double MedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static double MedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static int MedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static int MedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static uint MedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static uint MedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static long MedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static long MedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static MpzT MedianEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static MpzT MedianEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? 0 : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else
			return CreateVar(ToListEnumerable(source, function), out var col).Any() ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static decimal MedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
			return list._size == 0 ? 0 : new List<decimal>(list).Sort()._items[(list._size - 1) / 2];
		else return source is decimal[] array
			? array.Length == 0 ? 0 : new List<decimal>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<decimal> list2
			? list2.Count == 0 ? 0 : new List<decimal>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<decimal>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static double MedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
			return list._size == 0 ? 0 : new List<double>(list).Sort()._items[(list._size - 1) / 2];
		else return source is double[] array
			? array.Length == 0 ? 0 : new List<double>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<double> list2
			? list2.Count == 0 ? 0 : new List<double>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<double>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static int MedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
			return list._size == 0 ? 0 : new List<int>(list).Sort()._items[(list._size - 1) / 2];
		else return source is int[] array
			? array.Length == 0 ? 0 : new List<int>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<int> list2
			? list2.Count == 0 ? 0 : new List<int>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<int>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static uint MedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
			return list._size == 0 ? 0 : new List<uint>(list).Sort()._items[(list._size - 1) / 2];
		else return source is uint[] array
			? array.Length == 0 ? 0 : new List<uint>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<uint> list2
			? list2.Count == 0 ? 0 : new List<uint>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<uint>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static long MedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
			return list._size == 0 ? 0 : new List<long>(list).Sort()._items[(list._size - 1) / 2];
		else return source is long[] array
			? array.Length == 0 ? 0 : new List<long>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<long> list2
			? list2.Count == 0 ? 0 : new List<long>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<long>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static MpzT MedianEnumerable(IEnumerable<MpzT> source)
	{
		if (source is List<MpzT> list)
			return list._size == 0 ? 0 : new List<MpzT>(list).Sort()._items[(list._size - 1) / 2];
		else return source is MpzT[] array
			? array.Length == 0 ? 0 : new List<MpzT>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<MpzT> list2
			? list2.Count == 0 ? 0 : new List<MpzT>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<MpzT>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static TResult? MedianEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? default : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? default : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? default : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? default : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else return TryGetLengthEasilyEnumerable(source, out var length)
			? length == 0 ? default : ToListEnumerable(source, function).Sort()._items[(length - 1) / 2]
			: MedianEnumerable(new List<T>(source), function);
	}

	internal static TResult? MedianEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? default : ToListEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? default : ToListEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? default : ToListEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			return list3.Count == 0 ? default : ToListEnumerable(list3, function).Sort()._items[(list3.Count - 1) / 2];
		}
		else return TryGetLengthEasilyEnumerable(source, out var length)
			? length == 0 ? default : ToListEnumerable(source, function).Sort()._items[(length - 1) / 2]
			: MedianEnumerable(new List<T>(source), function);
	}

	internal static T? MedianEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
			return list._size == 0 ? default : new List<T>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is T[] array)
			return array.Length == 0 ? default : new List<T>(array).Sort()._items[(array.Length - 1) / 2];
		else return source is G.IList<T> list2
			? list2.Count == 0 ? default : new List<T>(list2).Sort()._items[(list2.Count - 1) / 2]
			: TryGetLengthEasilyEnumerable(source, out var length)
			? length == 0 ? default : new List<T>(source).Sort()._items[(length - 1) / 2]
			: MedianEnumerable(new List<T>(source));
	}

	internal static decimal MinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Min(function(list._items[0]), function(list._items[1])),
					3 => Math.Min(Math.Min(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Min(function(array[0]), function(array[1])),
					3 => Math.Min(Math.Min(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Min(function(list2[0]), function(list2[1])),
					3 => Math.Min(Math.Min(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Min(function(list3[0]), function(list3[1])),
					3 => Math.Min(Math.Min(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Min(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Min(Math.Min(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Min(function(array[0], 0), function(array[1], 1)),
					3 => Math.Min(Math.Min(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Min(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Min(Math.Min(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Min(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Min(Math.Min(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Min(function(list._items[0]), function(list._items[1])),
					3 => Math.Min(Math.Min(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Min(function(array[0]), function(array[1])),
					3 => Math.Min(Math.Min(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Min(function(list2[0]), function(list2[1])),
					3 => Math.Min(Math.Min(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Min(function(list3[0]), function(list3[1])),
					3 => Math.Min(Math.Min(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Min(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Min(Math.Min(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Min(function(array[0], 0), function(array[1], 1)),
					3 => Math.Min(Math.Min(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Min(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Min(Math.Min(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Min(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Min(Math.Min(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Min(function(list._items[0]), function(list._items[1])),
					3 => Math.Min(Math.Min(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Min(function(array[0]), function(array[1])),
					3 => Math.Min(Math.Min(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Min(function(list2[0]), function(list2[1])),
					3 => Math.Min(Math.Min(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Min(function(list3[0]), function(list3[1])),
					3 => Math.Min(Math.Min(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Min(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Min(Math.Min(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Min(function(array[0], 0), function(array[1], 1)),
					3 => Math.Min(Math.Min(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Min(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Min(Math.Min(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Min(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Min(Math.Min(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Min(function(list._items[0]), function(list._items[1])),
					3 => Math.Min(Math.Min(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Min(function(array[0]), function(array[1])),
					3 => Math.Min(Math.Min(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Min(function(list2[0]), function(list2[1])),
					3 => Math.Min(Math.Min(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Min(function(list3[0]), function(list3[1])),
					3 => Math.Min(Math.Min(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Min(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Min(Math.Min(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Min(function(array[0], 0), function(array[1], 1)),
					3 => Math.Min(Math.Min(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Min(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Min(Math.Min(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Min(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Min(Math.Min(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => Math.Min(function(list._items[0]), function(list._items[1])),
					3 => Math.Min(Math.Min(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => Math.Min(function(array[0]), function(array[1])),
					3 => Math.Min(Math.Min(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => Math.Min(function(list2[0]), function(list2[1])),
					3 => Math.Min(Math.Min(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => Math.Min(function(list3[0]), function(list3[1])),
					3 => Math.Min(Math.Min(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => Math.Min(function(list._items[0], 0), function(list._items[1], 1)),
					3 => Math.Min(Math.Min(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => Math.Min(function(array[0], 0), function(array[1], 1)),
					3 => Math.Min(Math.Min(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => Math.Min(function(list2[0], 0), function(list2[1], 1)),
					3 => Math.Min(Math.Min(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => Math.Min(function(list3[0], 0), function(list3[1], 1)),
					3 => Math.Min(Math.Min(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static MpzT MinEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => MpzT.Min(function(list._items[0]), function(list._items[1])),
					3 => MpzT.Min(MpzT.Min(function(list._items[0]), function(list._items[1])), function(list._items[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => MpzT.Min(function(array[0]), function(array[1])),
					3 => MpzT.Min(MpzT.Min(function(array[0]), function(array[1])), function(array[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => MpzT.Min(function(list2[0]), function(list2[1])),
					3 => MpzT.Min(MpzT.Min(function(list2[0]), function(list2[1])), function(list2[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => MpzT.Min(function(list3[0]), function(list3[1])),
					3 => MpzT.Min(MpzT.Min(function(list3[0]), function(list3[1])), function(list3[2])),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static MpzT MinEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => MpzT.Min(function(list._items[0], 0), function(list._items[1], 1)),
					3 => MpzT.Min(MpzT.Min(function(list._items[0], 0), function(list._items[1], 1)), function(list._items[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => MpzT.Min(function(array[0], 0), function(array[1], 1)),
					3 => MpzT.Min(MpzT.Min(function(array[0], 0), function(array[1], 1)), function(array[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => MpzT.Min(function(list2[0], 0), function(list2[1], 1)),
					3 => MpzT.Min(MpzT.Min(function(list2[0], 0), function(list2[1], 1)), function(list2[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => MpzT.Min(function(list3[0], 0), function(list3[1], 1)),
					3 => MpzT.Min(MpzT.Min(function(list3[0], 0), function(list3[1], 1)), function(list3[2], 2)),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static Slice<TResult> PairsEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, T, TResult> function, int offset = 1) => new CombineList<T, TResult>(source, source.GetROLSlice(offset), function).GetSlice();

	internal static Slice<TResult> PairsEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, T, int, TResult> function, int offset = 1) => new CombineListInt<T, TResult>(source, source.GetROLSlice(offset), function).GetSlice();

	internal static Slice<(T, T)> PairsEnumerable(G.IReadOnlyList<T> source, int offset = 1) => new CombineListPure<T>(source, source.GetROLSlice(offset)).GetSlice();

	internal static IEnumerable<TResult> PairsEnumerable<TResult>(IEnumerable<T> source, Func<T, T, TResult> function, int offset = 1)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		if (source is List<T> list)
		{
			var length = list._size - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list._items[i + offset];
				yield return function(item, item2);
			}
		}
		else if (source is T[] array)
		{
			var length = array.Length - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array[i + offset];
				yield return function(item, item2);
			}
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				var item2 = list2[i + offset];
				yield return function(item, item2);
			}
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				var item2 = list3[i + offset];
				yield return function(item, item2);
			}
		}
		else
		{
			using var en = source.GetEnumerator();
			using LimitedQueue<T> queue = new(offset);
			while (!queue.IsFull && en.MoveNext())
				queue.Enqueue(en.Current);
			var i = 0;
			while (en.MoveNext())
			{
				var item = queue.Dequeue();
				var item2 = en.Current;
				yield return function(item, item2);
				queue.Enqueue(item2);
				i++;
			}
		}
	}

	internal static IEnumerable<TResult> PairsEnumerable<TResult>(IEnumerable<T> source, Func<T, T, int, TResult> function, int offset = 1)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		if (source is List<T> list)
		{
			var length = list._size - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list._items[i + offset];
				yield return function(item, item2, i);
			}
		}
		else if (source is T[] array)
		{
			var length = array.Length - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array[i + offset];
				yield return function(item, item2, i);
			}
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				var item2 = list2[i + offset];
				yield return function(item, item2, i);
			}
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				var item2 = list3[i + offset];
				yield return function(item, item2, i);
			}
		}
		else
		{
			using var en = source.GetEnumerator();
			using LimitedQueue<T> queue = new(offset);
			while (!queue.IsFull && en.MoveNext())
				queue.Enqueue(en.Current);
			var i = 0;
			while (en.MoveNext())
			{
				var item = queue.Dequeue();
				var item2 = en.Current;
				yield return function(item, item2, i);
				queue.Enqueue(item2);
				i++;
			}
		}
	}

	internal static IEnumerable<(T, T)> PairsEnumerable(IEnumerable<T> source, int offset = 1)
	{
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		if (source is List<T> list)
		{
			var length = list._size - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list._items[i + offset];
				yield return (item, item2);
			}
		}
		else if (source is T[] array)
		{
			var length = array.Length - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array[i + offset];
				yield return (item, item2);
			}
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				var item2 = list2[i + offset];
				yield return (item, item2);
			}
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count - offset;
			if (length <= 0)
				yield break;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				var item2 = list3[i + offset];
				yield return (item, item2);
			}
		}
		else
		{
			using var en = source.GetEnumerator();
			using LimitedQueue<T> queue = new(offset);
			while (!queue.IsFull && en.MoveNext())
				queue.Enqueue(en.Current);
			var i = 0;
			while (en.MoveNext())
			{
				var item = queue.Dequeue();
				var item2 = en.Current;
				yield return (item, item2);
				queue.Enqueue(item2);
				i++;
			}
		}
	}

	private class PrependList : BaseIndexable<T, PrependList>
	{
		private readonly G.IReadOnlyList<T> source;
		private readonly T element;

		public PrependList()
		{
			source = [];
			element = default!;
		}

		public PrependList(G.IReadOnlyList<T> source, T element)
		{
			this.source = source;
			this.element = element;
			_size = source.Count + 1;
		}

		public override Span<T> AsSpan(int index, int length) => RedStarLinq.ToArray(GetSlice(index, length)).AsSpan();

		private protected override void CopyToInternal(int index, T[] array, int arrayIndex, int length)
		{
			for (var i = 0; i < length; i++)
				array[arrayIndex++] = GetInternal(index++);
		}

		public override void Dispose() => GC.SuppressFinalize(this);

		internal override T GetInternal(int index, bool invoke = true) => index == 0 ? element : source[index - 1];

		private protected override PrependList GetRangeInternal(int index, int length) => index == 0 ? new(source.GetROLSlice(0, length - 1), element) : new(source.GetROLSlice(index, length - 1), source[index - 1]);

		private protected override Slice<T> GetSliceInternal(int index, int length) => new(this, index, length);

		private protected override int IndexOfInternal(T item, int index, int length)
		{
			if (index == 0 && (element?.Equals(item) ?? item == null))
				return 0;
			for (var i = Math.Max(index, 1); i < index + length; i++)
				if (source[i - 1]?.Equals(item) ?? item == null)
					return i;
			return -1;
		}

		private protected override int LastIndexOfInternal(T item, int index, int length)
		{
			var endIndex = index - length + 1;
			for (var i = index; i >= Math.Max(endIndex, 1); i++)
				if (source[i - 1]?.Equals(item) ?? item == null)
					return i;
			if (endIndex == 0 && (element?.Equals(item) ?? item == null))
				return 0;
			return -1;
		}
	}

	internal static Slice<T> PrependEnumerable(G.IReadOnlyList<T> source, T element) => new PrependList(source, element).GetROLSlice();

	internal static decimal ProductEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0]),
					2 => function(list._items[0]) * function(list._items[1]),
					3 => function(list._items[0]) * function(list._items[1]) * function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0]),
					2 => function(array[0]) * function(array[1]),
					3 => function(array[0]) * function(array[1]) * function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < array.Length; i++)
				result *= function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0]),
					2 => function(list2[0]) * function(list2[1]),
					3 => function(list2[0]) * function(list2[1]) * function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0]),
					2 => function(list3[0]) * function(list3[1]),
					3 => function(list3[0]) * function(list3[1]) * function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list3[i]);
			return result;
		}
		else
		{
			decimal result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item);
				i++;
			}
			return result;
		}
	}

	internal static decimal ProductEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) * function(list._items[1], 1),
					3 => function(list._items[0], 0) * function(list._items[1], 1) * function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0], 0),
					2 => function(array[0], 0) * function(array[1], 1),
					3 => function(array[0], 0) * function(array[1], 1) * function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) * function(list2[1], 1),
					3 => function(list2[0], 0) * function(list2[1], 1) * function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result *= function(item, i);
			}
			return result;
		}
		else
		{
			decimal result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static double ProductEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0]),
					2 => function(list._items[0]) * function(list._items[1]),
					3 => function(list._items[0]) * function(list._items[1]) * function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0]),
					2 => function(array[0]) * function(array[1]),
					3 => function(array[0]) * function(array[1]) * function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < array.Length; i++)
				result *= function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0]),
					2 => function(list2[0]) * function(list2[1]),
					3 => function(list2[0]) * function(list2[1]) * function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0]),
					2 => function(list3[0]) * function(list3[1]),
					3 => function(list3[0]) * function(list3[1]) * function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list3[i]);
			return result;
		}
		else
		{
			double result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item);
				i++;
			}
			return result;
		}
	}

	internal static double ProductEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) * function(list._items[1], 1),
					3 => function(list._items[0], 0) * function(list._items[1], 1) * function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0], 0),
					2 => function(array[0], 0) * function(array[1], 1),
					3 => function(array[0], 0) * function(array[1], 1) * function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) * function(list2[1], 1),
					3 => function(list2[0], 0) * function(list2[1], 1) * function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result *= function(item, i);
			}
			return result;
		}
		else
		{
			double result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static int ProductEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0]),
					2 => function(list._items[0]) * function(list._items[1]),
					3 => function(list._items[0]) * function(list._items[1]) * function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0]),
					2 => function(array[0]) * function(array[1]),
					3 => function(array[0]) * function(array[1]) * function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < array.Length; i++)
				result *= function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0]),
					2 => function(list2[0]) * function(list2[1]),
					3 => function(list2[0]) * function(list2[1]) * function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0]),
					2 => function(list3[0]) * function(list3[1]),
					3 => function(list3[0]) * function(list3[1]) * function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list3[i]);
			return result;
		}
		else
		{
			var result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item);
				i++;
			}
			return result;
		}
	}

	internal static int ProductEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) * function(list._items[1], 1),
					3 => function(list._items[0], 0) * function(list._items[1], 1) * function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0], 0),
					2 => function(array[0], 0) * function(array[1], 1),
					3 => function(array[0], 0) * function(array[1], 1) * function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) * function(list2[1], 1),
					3 => function(list2[0], 0) * function(list2[1], 1) * function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result *= function(item, i);
			}
			return result;
		}
		else
		{
			var result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static uint ProductEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0]),
					2 => function(list._items[0]) * function(list._items[1]),
					3 => function(list._items[0]) * function(list._items[1]) * function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0]),
					2 => function(array[0]) * function(array[1]),
					3 => function(array[0]) * function(array[1]) * function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < array.Length; i++)
				result *= function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0]),
					2 => function(list2[0]) * function(list2[1]),
					3 => function(list2[0]) * function(list2[1]) * function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0]),
					2 => function(list3[0]) * function(list3[1]),
					3 => function(list3[0]) * function(list3[1]) * function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list3[i]);
			return result;
		}
		else
		{
			uint result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item);
				i++;
			}
			return result;
		}
	}

	internal static uint ProductEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) * function(list._items[1], 1),
					3 => function(list._items[0], 0) * function(list._items[1], 1) * function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0], 0),
					2 => function(array[0], 0) * function(array[1], 1),
					3 => function(array[0], 0) * function(array[1], 1) * function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) * function(list2[1], 1),
					3 => function(list2[0], 0) * function(list2[1], 1) * function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result *= function(item, i);
			}
			return result;
		}
		else
		{
			uint result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static long ProductEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0]),
					2 => function(list._items[0]) * function(list._items[1]),
					3 => function(list._items[0]) * function(list._items[1]) * function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0]),
					2 => function(array[0]) * function(array[1]),
					3 => function(array[0]) * function(array[1]) * function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < array.Length; i++)
				result *= function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0]),
					2 => function(list2[0]) * function(list2[1]),
					3 => function(list2[0]) * function(list2[1]) * function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0]),
					2 => function(list3[0]) * function(list3[1]),
					3 => function(list3[0]) * function(list3[1]) * function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list3[i]);
			return result;
		}
		else
		{
			long result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item);
				i++;
			}
			return result;
		}
	}

	internal static long ProductEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) * function(list._items[1], 1),
					3 => function(list._items[0], 0) * function(list._items[1], 1) * function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0], 0),
					2 => function(array[0], 0) * function(array[1], 1),
					3 => function(array[0], 0) * function(array[1], 1) * function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) * function(list2[1], 1),
					3 => function(list2[0], 0) * function(list2[1], 1) * function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result *= function(item, i);
			}
			return result;
		}
		else
		{
			long result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static MpzT ProductEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0]),
					2 => function(list._items[0]) * function(list._items[1]),
					3 => function(list._items[0]) * function(list._items[1]) * function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0]),
					2 => function(array[0]) * function(array[1]),
					3 => function(array[0]) * function(array[1]) * function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < array.Length; i++)
				result *= function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0]),
					2 => function(list2[0]) * function(list2[1]),
					3 => function(list2[0]) * function(list2[1]) * function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0]),
					2 => function(list3[0]) * function(list3[1]),
					3 => function(list3[0]) * function(list3[1]) * function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
				result *= function(list3[i]);
			return result;
		}
		else
		{
			MpzT result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item);
				i++;
			}
			return result;
		}
	}

	internal static MpzT ProductEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) * function(list._items[1], 1),
					3 => function(list._items[0], 0) * function(list._items[1], 1) * function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => function(array[0], 0),
					2 => function(array[0], 0) * function(array[1], 1),
					3 => function(array[0], 0) * function(array[1], 1) * function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) * function(list2[1], 1),
					3 => function(list2[0], 0) * function(list2[1], 1) * function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) * function(list3[1], 1),
					3 => function(list3[0], 0) * function(list3[1], 1) * function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result *= function(item, i);
			}
			return result;
		}
		else
		{
			MpzT result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static T? ProgressionEnumerable(IEnumerable<T> source, Func<T, T, T> function)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			T? result = default;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else
		{
			T? result = default;
			var i = 0;
			foreach (var item in source)
			{
				result = result == null || i == 0 ? item : function(result, item);
				i++;
			}
			return result;
		}
	}

	internal static TResult? ProgressionEnumerable<TResult>(IEnumerable<T> source, TResult seed, Func<TResult, T, TResult> function)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			var result = seed;
			for (var i = 0; i < length; i++)
				result = function(result, list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			var result = seed;
			for (var i = 0; i < array.Length; i++)
				result = function(result, array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = seed;
			for (var i = 0; i < length; i++)
				result = function(result, list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = seed;
			for (var i = 0; i < length; i++)
				result = function(result, list3[i]);
			return result;
		}
		else
		{
			var result = seed;
			var i = 0;
			foreach (var item in source)
			{
				result = function(result, item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source)
	{
		FastDelHashSet<T> hs = [];
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		FastDelHashSet<T> hs = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = [];
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = [];
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		FastDelHashSet<T> hs = [];
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2));
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, IEqualityComparer<TResult> comparer)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, comparer);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, comparer);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, IEqualityComparer<T> comparer)
	{
		FastDelHashSet<T> hs = new(comparer);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), comparer);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), equalFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction, hashCodeFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction, hashCodeFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Math.Min(list3_.Count, list3_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), equalFunction, hashCodeFunction);
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = [];
		if (source is List<T> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is T[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else
		{
			NList<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
				i++;
			}
			return result;
		}
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is T[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else
		{
			NList<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
				i++;
			}
			return result;
		}
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is T[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else
		{
			NList<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
				i++;
			}
			return result;
		}
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is T[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
			}
			return result;
		}
		else
		{
			NList<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result.Add(!dic.TryAdd(item, out var index) ? index : j++);
				i++;
			}
			return result;
		}
	}

	internal static List<T> ReverseEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[^(i + 1)] = item;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[^(i + 1)] = item;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[^(i + 1)] = item;
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[^(i + 1)] = item;
			}
			result._size = length;
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				result._items[^(i + 1)] = item;
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value)
	{
		if (source is List<T> list)
			return list.SetAll(value);
		else
		{
			for (var i = 0; i < source.Count; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, Index index)
	{
		if (source is List<T> list)
			return list.SetAll(value, index);
		else
		{
			for (var i = index.GetOffset(source.Count); i < source.Count; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, int index)
	{
		if (source is List<T> list)
			return list.SetAll(value, index);
		else
		{
			for (var i = index; i < source.Count; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, int index, int length)
	{
		if (source is List<T> list)
			return list.SetAll(value, index, length);
		else
		{
			var endIndex = index + length;
			for (var i = index; i < endIndex; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, Range range)
	{
		if (source is List<T> list)
			return list.SetAll(value, range);
		else
		{
			var (startIndex, length) = range.GetOffsetAndLength(source.Count);
			for (var i = startIndex; i < startIndex + length; i++)
				source[i] = value;
			return source;
		}
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source)
	{
		List<TResult> result = [];
		foreach (var item in source)
			result.Add((TResult)item);
		return result;
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source, Func<object?, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is ArrayList list)
		{
			var length = list.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list[i]);
			result._size = length;
			return result;
		}
		else if (source is BitArray bitArray)
		{
			List<TResult> result = new(bitArray.Length);
			for (var i = 0; i < bitArray.Length; i++)
				result._items[i] = function(bitArray[i]);
			result._size = bitArray.Length;
			return result;
		}
		else if (source is System.Collections.IList list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<TResult> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<TResult> result = [];
			var i = 0;
			foreach (var item in source)
			{
				result.Add(function(item));
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source, Func<object?, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is ArrayList list)
		{
			var length = list.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list[i], i);
			result._size = length;
			return result;
		}
		else if (source is BitArray bitArray)
		{
			List<TResult> result = new(bitArray.Length);
			for (var i = 0; i < bitArray.Length; i++)
				result._items[i] = function(bitArray[i], i);
			result._size = bitArray.Length;
			return result;
		}
		else if (source is System.Collections.IList list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i], i);
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<TResult> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<TResult> result = [];
			var i = 0;
			foreach (var item in source)
			{
				result.Add(function(item, i));
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> ShuffleEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Random random)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list._items[0]);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list._items[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			if (array.Length == 0)
				return result;
			result._items[0] = function(array[0]);
			int blend;
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list2[0]);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list3[0]);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result.Add(function(item));
				else
				{
					result.Add(result._items[blend]);
					result._items[blend] = function(item);
				}
				i++;
			}
			return result;
		}
	}

	internal static List<TResult> ShuffleEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Random random)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list._items[0], 0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list._items[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			if (array.Length == 0)
				return result;
			result._items[0] = function(array[0], 0);
			int blend;
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list2[0], 0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list3[0], 0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<TResult> result = new(length);
			if (length == 0)
				return result;
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result.Add(function(item, i));
				else
				{
					result.Add(result._items[blend]);
					result._items[blend] = function(item, i);
				}
				i++;
			}
			return result;
		}
	}

	internal static List<T> ShuffleEnumerable(IEnumerable<T> source, Random random)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = list._items[0];
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list._items[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			if (array.Length == 0)
				return result;
			result._items[0] = array[0];
			int blend;
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = list2[0];
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<T> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = list3[0];
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<T> result = new(length);
			if (length == 0)
				return result;
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<T> result = new(1024);
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result.Add(item);
				else
				{
					result.Add(result._items[blend]);
					result._items[blend] = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static Slice<T> SkipEnumerable(IEnumerable<T> source, int length)
	{
		if (source is G.IList<T> list)
			return list.GetSlice(Clamp(length, 0, list.Count));
		else if (length <= 0)
			return new(source.ToList());
		else
		{
			using var en = source.GetEnumerator();
			for (var i = 0; i < length; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var count2) ? Math.Max(count2 - length, 0) : 1024);
			while (en.MoveNext())
				result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipLastEnumerable(IEnumerable<T> source, int length)
	{
		if (source is G.IList<T> list)
			return list.GetSlice(0, Clamp(list.Count - length, 0, list.Count));
		else if (length <= 0)
			return new(source.ToList());
		else if (TryGetLengthEasilyEnumerable(source, out var count2))
		{
			var end = Math.Max(count2 - length, 0);
			List<T> result = new(end);
			using var en = source.GetEnumerator();
			var i = 0;
			for (; i < end && en.MoveNext(); i++)
				result._items[i] = en.Current;
			result._size = i;
			return result.GetSlice();
		}
		else
		{
			List<T> result = [];
			using LimitedQueue<T> queue = new(length);
			using var en = source.GetEnumerator();
			while (en.MoveNext())
				queue.Enqueue(en.Current, result);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is List<T> list)
			return list.SkipWhile(function);
		else
		{
			List<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is List<T> list)
			return list.SkipWhile(function);
		else
		{
			List<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current, i); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static List<List<T>> SplitIntoEqualEnumerable(IEnumerable<T> source, int fragmentLength)
	{
		if (fragmentLength <= 0)
			throw new ArgumentException("Длина фрагмента должна быть положительной.", nameof(fragmentLength));
		if (source is List<T> list)
		{
			var length = GetArrayLength(list._size, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = list._size / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list._items[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = list._size % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = list._items[index++];
				result._items[count2]._size = rest;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			var length = GetArrayLength(array.Length, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = array.Length / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = array[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = array.Length % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = array[index++];
				result._items[count2]._size = rest;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = GetArrayLength(list2.Count, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = list2.Count / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list2[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = list2.Count % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = list2[index++];
				result._items[count2]._size = rest;
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = GetArrayLength(list3.Count, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = list3.Count / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list3[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = list3.Count % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = list3[index++];
				result._items[count2]._size = rest;
			}
			result._size = length;
			return result;
		}
		else
		{
			if (!source.Any())
				return [];
			List<List<T>> result = new(64);
			int i = 0, j = 0, k = 0;
			result.Add(new(fragmentLength));
			foreach (var item in source)
			{
				result._items[j]._items[k++] = item;
				if (k >= fragmentLength)
				{
					result._items[j++]._size = fragmentLength;
					result.Add(new(fragmentLength));
					k = 0;
				}
				i++;
			}
			if (k != 0)
				result._items[j]._size = k;
			return result;
		}
	}

	internal static bool StartsWithEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size < list2._size)
				return false;
			var length = list2._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length < array2.Length)
				return false;
			for (var i = 0; i < array2.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count < list2_2.Count)
				return false;
			var length = list2_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			if (list3_.Count < list3_2.Count)
				return false;
			var length = list3_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else
		{
			bool b2;
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			while (en.MoveNext() & (b2 = en2.MoveNext()))
			{
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2))
					return false;
			}
			return !b2;
		}
	}

	internal static bool StartsWithEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size < list2._size)
				return false;
			var length = list2._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length < array2.Length)
				return false;
			for (var i = 0; i < array2.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count < list2_2.Count)
				return false;
			var length = list2_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			if (list3_.Count < list3_2.Count)
				return false;
			var length = list3_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else
		{
			bool b2;
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext() & (b2 = en2.MoveNext()))
			{
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2, i))
					return false;
				i++;
			}
			return !b2;
		}
	}

	internal static bool StartsWithEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size < list2._size)
				return false;
			var length = list2._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length < array2.Length)
				return false;
			for (var i = 0; i < array2.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count < list2_2.Count)
				return false;
			var length = list2_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			if (list3_.Count < list3_2.Count)
				return false;
			var length = list3_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else
		{
			bool b2;
			using var en = source.GetEnumerator();
			using var en2 = source2.GetEnumerator();
			while (en.MoveNext() & (b2 = en2.MoveNext()))
			{
				var item = en.Current;
				var item2 = en2.Current;
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return !b2;
		}
	}

	internal static decimal SumEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => function(list._items[0]) + function(list._items[1]),
					3 => function(list._items[0]) + function(list._items[1]) + function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => function(array[0]) + function(array[1]),
					3 => function(array[0]) + function(array[1]) + function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => function(list2[0]) + function(list2[1]),
					3 => function(list2[0]) + function(list2[1]) + function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => function(list3[0]) + function(list3[1]),
					3 => function(list3[0]) + function(list3[1]) + function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list3[i]);
			return result;
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static decimal SumEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) + function(list._items[1], 1),
					3 => function(list._items[0], 0) + function(list._items[1], 1) + function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => function(array[0], 0) + function(array[1], 1),
					3 => function(array[0], 0) + function(array[1], 1) + function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) + function(list2[1], 1),
					3 => function(list2[0], 0) + function(list2[1], 1) + function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => function(list._items[0]) + function(list._items[1]),
					3 => function(list._items[0]) + function(list._items[1]) + function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => function(array[0]) + function(array[1]),
					3 => function(array[0]) + function(array[1]) + function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => function(list2[0]) + function(list2[1]),
					3 => function(list2[0]) + function(list2[1]) + function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => function(list3[0]) + function(list3[1]),
					3 => function(list3[0]) + function(list3[1]) + function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list3[i]);
			return result;
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) + function(list._items[1], 1),
					3 => function(list._items[0], 0) + function(list._items[1], 1) + function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => function(array[0], 0) + function(array[1], 1),
					3 => function(array[0], 0) + function(array[1], 1) + function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) + function(list2[1], 1),
					3 => function(list2[0], 0) + function(list2[1], 1) + function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => function(list._items[0]) + function(list._items[1]),
					3 => function(list._items[0]) + function(list._items[1]) + function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => function(array[0]) + function(array[1]),
					3 => function(array[0]) + function(array[1]) + function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => function(list2[0]) + function(list2[1]),
					3 => function(list2[0]) + function(list2[1]) + function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => function(list3[0]) + function(list3[1]),
					3 => function(list3[0]) + function(list3[1]) + function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
				result += function(list3[i]);
			return result;
		}
		else
		{
			var result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) + function(list._items[1], 1),
					3 => function(list._items[0], 0) + function(list._items[1], 1) + function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => function(array[0], 0) + function(array[1], 1),
					3 => function(array[0], 0) + function(array[1], 1) + function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) + function(list2[1], 1),
					3 => function(list2[0], 0) + function(list2[1], 1) + function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			var result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => function(list._items[0]) + function(list._items[1]),
					3 => function(list._items[0]) + function(list._items[1]) + function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => function(array[0]) + function(array[1]),
					3 => function(array[0]) + function(array[1]) + function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => function(list2[0]) + function(list2[1]),
					3 => function(list2[0]) + function(list2[1]) + function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => function(list3[0]) + function(list3[1]),
					3 => function(list3[0]) + function(list3[1]) + function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
				result += function(list3[i]);
			return result;
		}
		else
		{
			uint result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) + function(list._items[1], 1),
					3 => function(list._items[0], 0) + function(list._items[1], 1) + function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => function(array[0], 0) + function(array[1], 1),
					3 => function(array[0], 0) + function(array[1], 1) + function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) + function(list2[1], 1),
					3 => function(list2[0], 0) + function(list2[1], 1) + function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			uint result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => function(list._items[0]) + function(list._items[1]),
					3 => function(list._items[0]) + function(list._items[1]) + function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => function(array[0]) + function(array[1]),
					3 => function(array[0]) + function(array[1]) + function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => function(list2[0]) + function(list2[1]),
					3 => function(list2[0]) + function(list2[1]) + function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => function(list3[0]) + function(list3[1]),
					3 => function(list3[0]) + function(list3[1]) + function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
				result += function(list3[i]);
			return result;
		}
		else
		{
			long result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) + function(list._items[1], 1),
					3 => function(list._items[0], 0) + function(list._items[1], 1) + function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => function(array[0], 0) + function(array[1], 1),
					3 => function(array[0], 0) + function(array[1], 1) + function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) + function(list2[1], 1),
					3 => function(list2[0], 0) + function(list2[1], 1) + function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			long result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static MpzT SumEnumerable(IEnumerable<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0]),
					2 => function(list._items[0]) + function(list._items[1]),
					3 => function(list._items[0]) + function(list._items[1]) + function(list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0]),
					2 => function(array[0]) + function(array[1]),
					3 => function(array[0]) + function(array[1]) + function(array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0]),
					2 => function(list2[0]) + function(list2[1]),
					3 => function(list2[0]) + function(list2[1]) + function(list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0]),
					2 => function(list3[0]) + function(list3[1]),
					3 => function(list3[0]) + function(list3[1]) + function(list3[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
				result += function(list3[i]);
			return result;
		}
		else
		{
			MpzT result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static MpzT SumEnumerable(IEnumerable<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list._items[0], 0),
					2 => function(list._items[0], 0) + function(list._items[1], 1),
					3 => function(list._items[0], 0) + function(list._items[1], 1) + function(list._items[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => function(array[0], 0),
					2 => function(array[0], 0) + function(array[1], 1),
					3 => function(array[0], 0) + function(array[1], 1) + function(array[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list2[0], 0),
					2 => function(list2[0], 0) + function(list2[1], 1),
					3 => function(list2[0], 0) + function(list2[1], 1) + function(list2[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => function(list3[0], 0),
					2 => function(list3[0], 0) + function(list3[1], 1),
					3 => function(list3[0], 0) + function(list3[1], 1) + function(list3[2], 2),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			MpzT result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static Slice<T> TakeEnumerable(IEnumerable<T> source, int length)
	{
		if (length <= 0)
			return new();
		else if (source is G.IList<T> list)
			return list.GetSlice(0, Clamp(length, 0, list.Count));
		else
		{
			List<T> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i++] = item;
				if (i >= length)
					break;
			}
			result._size = i;
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeEnumerable(IEnumerable<T> source, Range range)
	{
		if (source is G.IList<T> list)
		{
			var start = Clamp(range.Start.GetOffset(list.Count), 0, list.Count);
			var end = Clamp(range.End.GetOffset(list.Count), 0, list.Count);
			return start >= end ? new() : list.GetSlice(start, end - start);
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var start = Clamp(range.Start.GetOffset(length), 0, length);
			var end = Clamp(range.End.GetOffset(length), 0, length);
			if (start >= end)
				return new();
			List<T> result = new(end - start);
			var i = 0;
			foreach (var item in source)
			{
				if (i >= start)
					result._items[i - start] = item;
				i++;
				if (i >= end)
					break;
			}
			result._size = end - start;
			return result.GetSlice();
		}
		int index = range.Start.Value, index2 = range.End.Value;
		using var en = source.GetEnumerator();
		if (!range.Start.IsFromEnd && !range.End.IsFromEnd)
		{
			if (index >= index2)
				return new();
			var i = 0;
			for (; i < index; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new(index2 - index);
			for (; i < index2 && en.MoveNext(); i++)
				result._items[i - index] = en.Current;
			result._size = i - index;
			return result.GetSlice();
		}
		else if (!range.Start.IsFromEnd && range.End.IsFromEnd)
		{
			var i = 0;
			for (; i < index; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = [];
			using LimitedQueue<T> queue = new(index2);
			while (en.MoveNext())
				queue.Enqueue(en.Current, result);
			return result.GetSlice();
		}
		else if (range.Start.IsFromEnd && !range.End.IsFromEnd)
		{
			using LimitedQueue<T> queue = new(index);
			var i = 0;
			while (en.MoveNext())
			{
				queue.Enqueue(en.Current);
				i++;
				if (i >= index + index2)
					return new();
			}
			List<T> result = new(Math.Min(index + index2 - i, i));
			for (i = 0; i < result._items.Length; i++)
				result._items[i] = queue.Dequeue();
			result._size = result._items.Length;
			return result.GetSlice();
		}
		else if (range.Start.IsFromEnd && range.End.IsFromEnd)
		{
			using LimitedQueue<T> queue = new(index);
			while (en.MoveNext())
				queue.Enqueue(en.Current);
			if (queue.Length <= index2)
				return new();
			List<T> result = new(queue.Length - index2);
			for (var i = 0; i < result._items.Length; i++)
				result._items[i] = queue.Dequeue();
			result._size = result._items.Length;
			return result.GetSlice();
		}
		else
			return new();
	}

	internal static Slice<T> TakeLastEnumerable(IEnumerable<T> source, int length)
	{
		if (length <= 0)
			return new();
		else if (source is G.IList<T> list)
			return list.GetSlice(Clamp(list.Count - length, 0, list.Count));
		else if (TryGetLengthEasilyEnumerable(source, out var count2))
		{
			var start = Math.Max(count2 - length, 0);
			using var en = source.GetEnumerator();
			var i = 0;
			for (; i < start; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new(Math.Min(length, count2));
			for (i = 0; i < result._items.Length && en.MoveNext(); i++)
				result._items[i] = en.Current;
			result._size = result._items.Length;
			return result.GetSlice();
		}
		else
		{
			using LimitedQueue<T> queue = new(length);
			using var en = source.GetEnumerator();
			while (en.MoveNext())
				queue.Enqueue(en.Current);
			return queue.ToList().GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is List<T> list)
			return list.TakeWhile(function);
		else
		{
			List<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is List<T> list)
			return list.TakeWhile(function);
		else
		{
			List<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current, i); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static TResult[] ToArrayEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
				result[i] = function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			var result = new TResult[array.Length];
			for (var i = 0; i < array.Length; i++)
				result[i] = function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
				result[i] = function(list2[i]);
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
				result[i] = function(list3[i]);
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var result = new TResult[length];
			var i = 0;
			foreach (var item in source)
			{
				result[i] = function(item);
				i++;
			}
			return result;
		}
		else
			return ToArrayEnumerable(new List<T>(source), function);
	}

	internal static TResult[] ToArrayEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = new TResult[array.Length];
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var result = new TResult[length];
			var i = 0;
			foreach (var item in source)
			{
				result[i] = function(item, i);
				i++;
			}
			return result;
		}
		else
			return ToArrayEnumerable(new List<T>(source), function);
	}

	internal static T[] ToArrayEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
			return [.. list];
		else if (source is T[] array)
		{
			var result = new T[array.Length];
			Array.Copy(array, result, array.Length);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = new T[length];
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result[i] = item;
			}
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			var result = new T[length];
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result[i] = item;
			}
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var result = new T[length];
			var i = 0;
			foreach (var item in source)
			{
				result[i] = item;
				i++;
			}
			return result;
		}
		else
			return new List<T>(source).ToArray();
	}

	internal static List<TResult> ToListEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list._items[i]);
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list3[i]);
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 32);
			var i = 0;
			foreach (var item in source)
			{
				if (i >= 32 && (i & i - 1) == 0)
					result.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> ToListEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 32);
			var i = 0;
			foreach (var item in source)
			{
				if (i >= 32 && (i & i - 1) == 0)
					result.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static bool TryGetLengthEasilyEnumerable(IEnumerable<T> source, out int length)
	{
		try
		{
			if (source is G.ICollection<T> col)
			{
				length = col.Count;
				return length >= 0;
			}
			else if (source is G.IReadOnlyCollection<T> col2)
			{
				length = col2.Count;
				return length >= 0;
			}
			else if (source is System.Collections.ICollection col3)
			{
				length = col3.Count;
				return length >= 0;
			}
			else if (source is string s)
			{
				length = s.Length;
				return length >= 0;
			}
			else if (CreateVar(Assembly.Load("System.Linq").GetType("System.Linq.IIListProvider`1")?.MakeGenericType(typeof(T)) ?? throw new InvalidOperationException(), out var targetType).IsInstanceOfType(source) && targetType.GetMethod("GetCount")?.Invoke(source, [true]) is int n)
			{
				length = n;
				return length >= 0;
			}
		}
		catch
		{
		}
		length = -1;
		return false;
	}

	internal static bool TryGetLengthEasilyEnumerable(IEnumerable source, out int length)
	{
		try
		{
			if (source is System.Collections.ICollection col)
			{
				length = col.Count;
				return length >= 0;
			}
			else if (source is string s)
			{
				length = s.Length;
				return length >= 0;
			}
		}
		catch
		{
		}
		length = -1;
		return false;
	}

	internal static bool AllEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i]))
				return false;
		return true;
	}

	internal static bool AllEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i], i))
				return false;
		return true;
	}

	internal static bool AnyEnumerable(ReadOnlySpan<T> source)
	{
		var length = source.Length;
		return length != 0;
	}

	internal static bool AnyEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				return true;
		return false;
	}

	internal static bool AnyEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				return true;
		return false;
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<T>, List<T2>) BreakEnumerable<T2>(ReadOnlySpan<(T, T2)> source)
	{
		var length = source.Length;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<T>, List<T2>, List<T3>) BreakEnumerable<T2, T3>(ReadOnlySpan<(T, T2, T3)> source)
	{
		var length = source.Length;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		List<T3> result3 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static List<T> BreakFilterEnumerable(ReadOnlySpan<T> source, Func<T, bool> function, out List<T> result2)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(length / 2);
		result2 = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				result.Add(item);
			else
				result2.Add(item);
		}
		result.TrimExcess();
		result2.TrimExcess();
		return result;
	}

	internal static List<T> BreakFilterEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function, out List<T> result2)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(length / 2);
		result2 = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				result.Add(item);
			else
				result2.Add(item);
		}
		result.TrimExcess();
		result2.TrimExcess();
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Math.Min(source.Length, source2.Length);
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Math.Min(source.Length, source2.Length);
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], i);
		result._size = length;
		return result;
	}

	internal static List<(T, T2)> CombineEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2)
	{
		var length = Math.Min(source.Length, source2.Length);
		List<(T, T2)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i], i);
		result._size = length;
		return result;
	}

	internal static List<(T, T2, T3)> CombineEnumerable<T2, T3>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3)
	{
		var length = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<(T, T2, T3)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, IEnumerable<TResult>> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source[i]));
		return result;
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, IEnumerable<TResult>> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source[i], i));
		return result;
	}

	internal static int CountEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				result++;
		return result;
	}

	internal static int CountEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				result++;
		return result;
	}

	internal static int CountEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				result++;
		return result;
	}

	internal static bool EqualsEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source.Length != source2.Length)
			return false;
		var length = Math.Min(source.Length, source2.Length);
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i]))
				return false;
		return true;
	}

	internal static bool EqualsEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source.Length != source2.Length)
			return false;
		var length = Math.Min(source.Length, source2.Length);
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i], i))
				return false;
		return true;
	}

	internal static bool EqualsEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2)
	{
		if (source.Length != source2.Length)
			return false;
		var length = Math.Min(source.Length, source2.Length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (item == null || !item.Equals(source2[i]))
				return false;
		}
		return true;
	}

	internal static List<T> FilterEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FilterEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static T? FindEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				return item;
		}
		return default;
	}

	internal static T? FindEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				return item;
		}
		return default;
	}

	internal static List<T> FindAllEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<T> result = new(1024);
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static int FindIndexEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				return i;
		return -1;
	}

	internal static int FindIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				return i;
		return -1;
	}

	internal static int FindLastIndexEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
			if (function(source[i]))
				return i;
		return -1;
	}

	internal static int FindLastIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
			if (function(source[i], i))
				return i;
		return -1;
	}

	internal static T? FindLastEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (function(item))
				return item;
		}
		return default;
	}

	internal static T? FindLastEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (function(item, i))
				return item;
		}
		return default;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		T? result = default;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static void ForEachEnumerable(ReadOnlySpan<T> source, Action<T> action)
	{
		ArgumentNullException.ThrowIfNull(action);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			action(source[i]);
	}

	internal static void ForEachEnumerable(ReadOnlySpan<T> source, Action<T, int> action)
	{
		ArgumentNullException.ThrowIfNull(action);
		var length = source.Length;
		for (var i = 0; i < length; i++)
			action(source[i], i);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i]), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i], i), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(ReadOnlySpan<T> source)
	{
		ListHashSet<T> dic = [];
		var length = source.Length;
		List<(T Key, int Count)> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = source[i], out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i]), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i], i), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<(T Key, int Count)> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = source[i], out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i]), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i], i), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<(T Key, int Count)> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = source[i], out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result.Add(new(32, item, f));
		}
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source)
	{
		ListHashSet<T> dic = [];
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new(32, i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int IndexOfEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				return i;
		return -1;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<int>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<int>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<uint>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<uint>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
		return List<long>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
		return List<long>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.SumEnumerable(list_) / (MpzT)list_.Length;
		return List<MpzT>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.SumEnumerable(list_) / (MpzT)list_.Length;
		return List<MpzT>.IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<decimal>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<double>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		var value = (int)(List<int>.SumEnumerable(source, x => (long)x) / Math.Max(source.Length, 1));
		return List<int>.IndexOfEnumerable(source, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		var value = (uint)(List<uint>.SumEnumerable(source, x => (long)x) / Math.Max(source.Length, 1));
		return List<uint>.IndexOfEnumerable(source, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		var value = (long)(List<long>.SumEnumerable(source, x => (MpzT)x) / Math.Max(source.Length, 1));
		return List<long>.IndexOfEnumerable(source, value);
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<MpzT> source)
	{
		var value = SumEnumerable(source) / (MpzT)source.Length;
		return List<MpzT>.IndexOfEnumerable(source, value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<MpzT>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<decimal> source) => List<decimal>.IndexOfEnumerable(source, MedianEnumerable(source));

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<double> source) => List<double>.IndexOfEnumerable(source, MedianEnumerable(source));

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<int> source) => List<int>.IndexOfEnumerable(source, MedianEnumerable(source));

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<uint> source) => List<uint>.IndexOfEnumerable(source, MedianEnumerable(source));

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<long> source) => List<long>.IndexOfEnumerable(source, MedianEnumerable(source));

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<MpzT> source) => List<MpzT>.IndexOfEnumerable(source, MedianEnumerable(source));

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<List<T>> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source) where TSource : IEnumerable<TResult>
	{
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
			result.AddRange(source[i]);
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<T[]> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<G.IList<T>> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<IEnumerable<T>> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<List<T>> source, T separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.Add(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, TResult separator) where TSource : IEnumerable<TResult>
	{
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.Add(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<T[]> source, T separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.Add(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<G.IList<T>> source, T separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.Add(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<IEnumerable<T>> source, T separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.Add(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<List<T>> source, IEnumerable<T> separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.AddRange(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, IEnumerable<TResult> separator) where TSource : IEnumerable<TResult>
	{
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.AddRange(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<T[]> source, IEnumerable<T> separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.AddRange(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<G.IList<T>> source, IEnumerable<T> separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.AddRange(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<IEnumerable<T>> source, IEnumerable<T> separator)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			if (i != 0)
				result.AddRange(separator);
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static int LastIndexOfEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
			if (source[i]?.Equals(target) ?? false)
				return i;
		return -1;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<int>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<int>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<uint>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return List<uint>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
		return List<long>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
		return List<long>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.SumEnumerable(list_) / (MpzT)list_.Length;
		return List<MpzT>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		var value = NList<bool>.SumEnumerable(list_) / (MpzT)list_.Length;
		return List<MpzT>.LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<decimal>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<double>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		var value = (int)(List<int>.SumEnumerable(source, x => (long)x) / Math.Max(source.Length, 1));
		return List<int>.LastIndexOfEnumerable(source, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		var value = (uint)(List<uint>.SumEnumerable(source, x => (long)x) / Math.Max(source.Length, 1));
		return List<uint>.LastIndexOfEnumerable(source, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		var value = (long)(List<long>.SumEnumerable(source, x => (MpzT)x) / Math.Max(source.Length, 1));
		return List<long>.LastIndexOfEnumerable(source, value);
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<MpzT> source)
	{
		var value = SumEnumerable(source) / (MpzT)source.Length;
		return List<MpzT>.LastIndexOfEnumerable(source, value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToListEnumerable(source, function);
		return List<MpzT>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfEnumerable(source, MedianEnumerable(source));

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<double> source) => List<double>.LastIndexOfEnumerable(source, MedianEnumerable(source));

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<int> source) => List<int>.LastIndexOfEnumerable(source, MedianEnumerable(source));

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<uint> source) => List<uint>.LastIndexOfEnumerable(source, MedianEnumerable(source));

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<long> source) => List<long>.LastIndexOfEnumerable(source, MedianEnumerable(source));

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<MpzT> source) => List<MpzT>.LastIndexOfEnumerable(source, MedianEnumerable(source));

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		var result = -1;
		MpzT indicator = 0;
		MpzT f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == length - 1)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Max(function(source[0]), function(source[1])),
				3 => Math.Max(Math.Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Max(function(source[0], 0), function(source[1], 1)),
				3 => Math.Max(Math.Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Max(function(source[0]), function(source[1])),
				3 => Math.Max(Math.Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Max(function(source[0], 0), function(source[1], 1)),
				3 => Math.Max(Math.Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Max(function(source[0]), function(source[1])),
				3 => Math.Max(Math.Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Max(function(source[0], 0), function(source[1], 1)),
				3 => Math.Max(Math.Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Max(function(source[0]), function(source[1])),
				3 => Math.Max(Math.Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Max(function(source[0], 0), function(source[1], 1)),
				3 => Math.Max(Math.Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Max(function(source[0]), function(source[1])),
				3 => Math.Max(Math.Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Max(function(source[0], 0), function(source[1], 1)),
				3 => Math.Max(Math.Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static MpzT MaxEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static MpzT MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Max(source[0], source[1]),
				3 => Math.Max(Math.Max(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Max(source[0], source[1]),
				3 => Math.Max(Math.Max(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Max(source[0], source[1]),
				3 => Math.Max(Math.Max(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Max(source[0], source[1]),
				3 => Math.Max(Math.Max(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Max(source[0], source[1]),
				3 => Math.Max(Math.Max(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static MpzT MaxEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i], i);
		return result / source.Length;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += (double)item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += (double)item;
		}
		return result / source.Length;
	}

	internal static decimal MedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static decimal MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static double MedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static double MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static int MedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static int MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static uint MedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static uint MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static long MedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static long MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static MpzT MedianEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? 0 : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static MpzT MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? 0 : ToListEnumerable(source, function).Sort().GetInternal((source.Length - 1) / 2);

	internal static decimal MedianEnumerable(ReadOnlySpan<decimal> source) => source.Length == 0 ? default : new NList<decimal>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static double MedianEnumerable(ReadOnlySpan<double> source) => source.Length == 0 ? default : new NList<double>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static int MedianEnumerable(ReadOnlySpan<int> source) => source.Length == 0 ? default : new NList<int>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static uint MedianEnumerable(ReadOnlySpan<uint> source) => source.Length == 0 ? default : new NList<uint>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static long MedianEnumerable(ReadOnlySpan<long> source) => source.Length == 0 ? default : new NList<long>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static MpzT MedianEnumerable(ReadOnlySpan<MpzT> source) => source.Length == 0 ? 0 : new NList<MpzT>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static T? MedianEnumerable(ReadOnlySpan<T> source) => source.Length == 0 ? default : new List<T>(source).Sort().GetInternal((source.Length - 1) / 2);

	internal static decimal MinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Min(function(source[0]), function(source[1])),
				3 => Math.Min(Math.Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Min(function(source[0], 0), function(source[1], 1)),
				3 => Math.Min(Math.Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Min(function(source[0]), function(source[1])),
				3 => Math.Min(Math.Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Min(function(source[0], 0), function(source[1], 1)),
				3 => Math.Min(Math.Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Min(function(source[0]), function(source[1])),
				3 => Math.Min(Math.Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Min(function(source[0], 0), function(source[1], 1)),
				3 => Math.Min(Math.Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Min(function(source[0]), function(source[1])),
				3 => Math.Min(Math.Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Min(function(source[0], 0), function(source[1], 1)),
				3 => Math.Min(Math.Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Math.Min(function(source[0]), function(source[1])),
				3 => Math.Min(Math.Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Math.Min(function(source[0], 0), function(source[1], 1)),
				3 => Math.Min(Math.Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static MpzT MinEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static MpzT MinEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Min(source[0], source[1]),
				3 => Math.Min(Math.Min(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Min(source[0], source[1]),
				3 => Math.Min(Math.Min(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Min(source[0], source[1]),
				3 => Math.Min(Math.Min(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Min(source[0], source[1]),
				3 => Math.Min(Math.Min(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => source[0],
				2 => Math.Min(source[0], source[1]),
				3 => Math.Min(Math.Min(source[0], source[1]), source[2]),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static MpzT MinEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		MpzT indicator = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static List<TResult> PairsEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, T, TResult> function, int offset = 1)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		var length = source.Length - offset;
		if (length <= 0)
			return [];
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			var item2 = source[i + offset];
			result._items[i] = function(item, item2);
		}
		result._size = length;
		return result;
	}

	internal static List<TResult> PairsEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, T, int, TResult> function, int offset = 1)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		var length = source.Length - offset;
		if (length <= 0)
			return [];
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			var item2 = source[i + offset];
			result._items[i] = function(item, item2, i);
		}
		result._size = length;
		return result;
	}

	internal static List<(T, T)> PairsEnumerable(ReadOnlySpan<T> source, int offset = 1)
	{
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		var length = source.Length - offset;
		if (length <= 0)
			return [];
		List<(T, T)> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			var item2 = source[i + offset];
			result._items[i] = (item, item2);
		}
		result._size = length;
		return result;
	}

	internal static T? ProgressionEnumerable(ReadOnlySpan<T> source, Func<T, T, T> function)
	{
		var length = source.Length;
		T? result = default;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result = result == null ? item : function(result, item);
		}
		return result;
	}

	internal static TResult? ProgressionEnumerable<TResult>(ReadOnlySpan<T> source, TResult seed, Func<TResult, T, TResult> function)
	{
		var length = source.Length;
		TResult? result = default;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result = result == null ? seed : function(result, item);
		}
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable(ReadOnlySpan<T> source)
	{
		FastDelHashSet<T> hs = new(EqualityComparer<T>.Default);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> ReverseEnumerable(ReadOnlySpan<T> source)
	{
		var length = source.Length;
		List<T> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[^(i + 1)] = source[i];
		result._size = length;
		return result;
	}

	internal static Span<T> SetAllEnumerable(Span<T> source, T value)
	{
		for (var i = 0; i < source.Length; i++)
			source[i] = value;
		return source;
	}

	internal static bool StartsWithEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source.Length < source2.Length)
			return false;
		var length = source2.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i]))
				return false;
		return true;
	}

	internal static bool StartsWithEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source.Length < source2.Length)
			return false;
		var length = source2.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i], i))
				return false;
		return true;
	}

	internal static bool StartsWithEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2)
	{
		if (source.Length < source2.Length)
			return false;
		var length = source2.Length;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (item == null || !item.Equals(source2[i]))
				return false;
		}
		return true;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		uint result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		uint result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		long result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		long result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static MpzT SumEnumerable(ReadOnlySpan<T> source, Func<T, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		MpzT result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static MpzT SumEnumerable(ReadOnlySpan<T> source, Func<T, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		MpzT result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		uint result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		long result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static MpzT SumEnumerable(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		MpzT result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static TResult[] ToArrayEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = function(source[i]);
		return result;
	}

	internal static TResult[] ToArrayEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = function(source[i], i);
		return result;
	}

	internal static List<TResult> ToListEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> ToListEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], i);
		result._size = length;
		return result;
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IReadOnlyList<T> source, Func<T, TResult> function, Func<T, TResult2> function2)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PBreakEnumerable<T2>(G.IReadOnlyList<(T, T2)> source)
	{
		var length = source.Count;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IReadOnlyList<T> source, Func<T, (TResult, TResult2)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IReadOnlyList<T> source, Func<T, int, (TResult, TResult2)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IReadOnlyList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3)
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<T>, List<T2>, List<T3>) PBreakEnumerable<T2, T3>(G.IReadOnlyList<(T, T2, T3)> source)
	{
		var length = source.Count;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		List<T3> result3 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i], result3._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IReadOnlyList<T> source, Func<T, (TResult, TResult2, TResult3)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IReadOnlyList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static List<TResult> PCombineEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Math.Min(source.Count, source2.Count);
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2);
		});
		result._size = length;
		return result;
	}

	internal static List<TResult> PCombineEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Math.Min(source.Count, source2.Count);
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2, i);
		});
		result._size = length;
		return result;
	}

	internal static List<(T, T2)> PCombineEnumerable<T2>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2)
	{
		var length = Math.Min(source.Count, source2.Count);
		List<(T, T2)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = (item, item2);
		});
		result._size = length;
		return result;
	}

	internal static List<TResult> PCombineEnumerable<T2, T3, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static List<TResult> PCombineEnumerable<T2, T3, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3, i);
		});
		result._size = length;
		return result;
	}

	internal static List<(T, T2, T3)> PCombineEnumerable<T2, T3>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3)
	{
		var length = MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		List<(T, T2, T3)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = (item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (item?.Equals(target) ?? false)
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target, IEqualityComparer<T> comparer)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static List<TResult> PConvertEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(source[i]));
		result._size = length;
		return result;
	}

	internal static List<TResult> PConvertEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(source[i], i));
		result._size = length;
		return result;
	}

	internal static List<TResult> PFillEnumerable<TResult>(TResult elem, int length)
	{
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = elem);
		result._size = length;
		return result;
	}

	internal static List<TResult> PFillEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		ArgumentNullException.ThrowIfNull(function);
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(i));
		result._size = length;
		return result;
	}

	internal static TResult[] PFillArrayEnumerable<TResult>(TResult elem, int length)
	{
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = elem);
		return result;
	}

	internal static TResult[] PFillArrayEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		ArgumentNullException.ThrowIfNull(function);
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = function(i));
		return result;
	}

	internal static List<T> PFilterEnumerable(G.IReadOnlyList<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i]));
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static List<T> PFilterEnumerable(G.IReadOnlyList<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		List<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i], i));
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = [];
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = [];
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable(G.IReadOnlyList<T> source)
	{
		ParallelHashSet<T> hs = [];
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(item, out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(comparer);
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(comparer);
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable(G.IReadOnlyList<T> source, IEqualityComparer<T> comparer)
	{
		ParallelHashSet<T> hs = new(comparer);
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(item, out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable(G.IReadOnlyList<T> source, Func<T, T, bool> equalFunction)
	{
		ParallelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		var length = source.Count;
		List<T> result = new(1024);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(item, out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i), out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static List<T> PRemoveDoublesEnumerable(G.IReadOnlyList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ParallelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Count;
		List<T> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			if (hs.TryAdd(item, out var index))
				result._items[index] = item;
		});
		result._size = hs.Length;
		result.TrimExcess();
		return result;
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = [];
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = [];
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item, i), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2)
	{
		ParallelHashSet<T> hs = [];
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(item, out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function, IEqualityComparer<TResult> comparer)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(comparer);
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(comparer);
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item, i), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, IEqualityComparer<T> comparer)
	{
		ParallelHashSet<T> hs = new(comparer);
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(item, out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item, i), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T, bool> equalFunction)
	{
		ParallelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(item, out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2, TResult>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		try
		{
			throw new ExperimentalException();
		}
		catch
		{
		}
		ArgumentNullException.ThrowIfNull(function);
		ParallelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(function(item, i), out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PRemoveDoublesEnumerable<T2>(G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ParallelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = Math.Min(source.Count, source2.Count);
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			if (hs.TryAdd(item, out var index))
			{
				result._items[index] = item;
				result2._items[index] = item2;
			}
		});
		result._size = hs.Length;
		result2._size = hs.Length;
		result.TrimExcess();
		result2.TrimExcess();
		return (result, result2);
	}

	internal static TResult[] PToArrayEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = function(source[i]));
		return result;
	}

	internal static TResult[] PToArrayEnumerable<TResult>(G.IReadOnlyList<T> source, Func<T, int, TResult> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = function(source[i], i));
		return result;
	}

	internal static T[] PToArrayEnumerable(G.IReadOnlyList<T> source)
	{
		var length = source.Count;
		var result = new T[length];
		Parallel.For(0, length, i => result[i] = source[i]);
		return result;
	}

	internal static bool TryWrapEnumerable(T source, Action<T> action)
	{
		try
		{
			action(source);
			return true;
		}
		catch
		{
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TResult>(T source, Func<T, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static IEnumerable<TResult> ConvertAndJoin<TCollection, TResult>(IEnumerable<T> source, Func<T, int, IEnumerable<TCollection>> collectionSelector, Func<T, TCollection, int, TResult> resultSelector)
	{
		int i = 0, j = 0;
		return Enumerable.SelectMany(source, x => collectionSelector(x, i++), (x, y) => resultSelector(x, y, j++));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), comparer);
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++));
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), comparer);
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static TResult? Max<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.Max(source, x => function(x, i++));
	}

	internal static TResult? Min<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.Min(source, x => function(x, i++));
	}

	internal static IEnumerable<T> Sort<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++));
	}

	internal static IEnumerable<T> Sort<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer)
	{
		var i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++), comparer);
	}

	internal static IEnumerable<T> Sort<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction)
	{
		var i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++), new Comparer<TResult>(compareFunction));
	}

	internal static IEnumerable<T> SortDesc<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++));
	}

	internal static IEnumerable<T> SortDesc<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer)
	{
		var i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++), comparer);
	}

	internal static IEnumerable<T> SortDesc<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction)
	{
		var i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++), new Comparer<TResult>(compareFunction));
	}
}

public unsafe partial class NList<T, TCertain>
{
	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(IEnumerable<T_> source, Func<T_, TResult> function, Func<T_, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(IEnumerable<T_> source, Func<T_, int, TResult> function, Func<T_, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<T>, NList<T2>) BreakEnumerable<T2>(IEnumerable<(T, T2)> source) where T2 : unmanaged
	{
		if (source is List<(T, T2)> list)
		{
			var length = list.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list.GetInternal(i);
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is (T, T2)[] array)
		{
			var length = array.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<(T, T2)> list2)
		{
			var length = list2.Count;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<T> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<T2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i]) = item;
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(IEnumerable<T_> source, Func<T_, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i]) = function(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(IEnumerable<T_> source, Func<T_, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i]) = function(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(IEnumerable<T_> source, Func<T_, TResult> function, Func<T_, TResult2> function2, Func<T_, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(IEnumerable<T_> source, Func<T_, int, TResult> function, Func<T_, int, TResult2> function2, Func<T_, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<T>, NList<T2>, NList<T3>) BreakEnumerable<T2, T3>(IEnumerable<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		if (source is List<(T, T2, T3)> list)
		{
			var length = list.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list.GetInternal(i);
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is (T, T2, T3)[] array)
		{
			var length = array.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<(T, T2, T3)> list2)
		{
			var length = list2.Count;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<T> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = item;
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(IEnumerable<T_> source, Func<T_, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(IEnumerable<T_> source, Func<T_, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(ReadOnlySpan<T_> source, Func<T_, TResult> function, Func<T_, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(ReadOnlySpan<T_> source, Func<T_, int, TResult> function, Func<T_, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<T>, NList<T2>) BreakEnumerable<T2>(ReadOnlySpan<(T, T2)> source) where T2 : unmanaged
	{
		var length = source.Length;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(ReadOnlySpan<T_> source, Func<T_, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<T_, TResult, TResult2>(ReadOnlySpan<T_> source, Func<T_, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(ReadOnlySpan<T_> source, Func<T_, TResult> function, Func<T_, TResult2> function2, Func<T_, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(ReadOnlySpan<T_> source, Func<T_, int, TResult> function, Func<T_, int, TResult2> function2, Func<T_, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<T>, NList<T2>, NList<T3>) BreakEnumerable<T2, T3>(ReadOnlySpan<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		var length = source.Length;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		NList<T3> result3 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(ReadOnlySpan<T_> source, Func<T_, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<T_, TResult, TResult2, TResult3>(ReadOnlySpan<T_> source, Func<T_, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<T>, NList<T2>) BreakEnumerable<T2>(NList<(T, T2)> source) where T2 : unmanaged
	{
		var length = source._size;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i]) = source._items[i];
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<T>, NList<T2>, NList<T3>) BreakEnumerable<T2, T3>(NList<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		var length = source._size;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		NList<T3> result3 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source._items[i];
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, TResult>(IEnumerable<T_> source, IEnumerable<T2> source2, Func<T_, T2, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list && source2 is List<T2> list2)
		{
			var length = Min(list.Length, list2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list2.GetInternal(i);
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array && source2 is T2[] array2)
		{
			var length = Min(array.Length, array2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T_> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Min(list2_.Count, list2_2.Count);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Min(list3_.Count, list3_2.Count);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), function);
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, TResult>(IEnumerable<T_> source, IEnumerable<T2> source2, Func<T_, T2, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list && source2 is List<T2> list2)
		{
			var length = Min(list.Length, list2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list2.GetInternal(i);
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array && source2 is T2[] array2)
		{
			var length = Min(array.Length, array2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T_> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Min(list2_.Count, list2_2.Count);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Min(list3_.Count, list3_2.Count);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), function);
	}

	internal static NList<(T, T2)> CombineEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2) where T2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Min(list.Length, list2.Length);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list2.GetInternal(i);
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Min(array.Length, array2.Length);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Min(list2_.Count, list2_2.Count);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2)
		{
			var length = Min(list3_.Count, list3_2.Count);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2));
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, T3, TResult>(IEnumerable<T_> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T_, T2, T3, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = List<int>.MinEnumerable(new[] { list.Length, list3.Length, list3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list2.GetInternal(i);
				var item3 = list3.GetInternal(i);
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T_> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3_ && source2 is G.IReadOnlyList<T2> list3_2 && source3 is G.IReadOnlyList<T3> list3_3)
		{
			var length = List<int>.MinEnumerable(new[] { list3_.Count, list3_2.Count, list3_3.Count }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				var item3 = list3_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), List<T3>.ReturnOrConstruct(source3), function);
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, T3, TResult>(IEnumerable<T_> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T_, T2, T3, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = List<int>.MinEnumerable(new[] { list.Length, list3.Length, list3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list2.GetInternal(i);
				var item3 = list3.GetInternal(i);
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T_> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3_ && source2 is G.IReadOnlyList<T2> list3_2 && source3 is G.IReadOnlyList<T3> list3_3)
		{
			var length = List<int>.MinEnumerable(new[] { list3_.Count, list3_2.Count, list3_3.Count }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				var item3 = list3_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), List<T3>.ReturnOrConstruct(source3), function);
	}

	internal static NList<(T, T2, T3)> CombineEnumerable<T2, T3>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = List<int>.MinEnumerable(new[] { list.Length, list3.Length, list3.Length }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list2.GetInternal(i);
				var item3 = list3.GetInternal(i);
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3_ && source2 is G.IReadOnlyList<T2> list3_2 && source3 is G.IReadOnlyList<T3> list3_3)
		{
			var length = List<int>.MinEnumerable(new[] { list3_.Count, list3_2.Count, list3_3.Count }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3_[i];
				var item2 = list3_2[i];
				var item3 = list3_3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), List<T3>.ReturnOrConstruct(source3));
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, TResult>(ReadOnlySpan<T_> source, ReadOnlySpan<T2> source2, Func<T_, T2, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Min(source.Length, source2.Length);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, TResult>(ReadOnlySpan<T_> source, ReadOnlySpan<T2> source2, Func<T_, T2, int, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Min(source.Length, source2.Length);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2)> CombineEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) where T2 : unmanaged
	{
		var length = Min(source.Length, source2.Length);
		NList<(T, T2)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, T3, TResult>(ReadOnlySpan<T_> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T_, T2, T3, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)[source.Length, source2.Length, source3.Length]);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T_, T2, T3, TResult>(ReadOnlySpan<T_> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T_, T2, T3, int, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)[source.Length, source2.Length, source3.Length]);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2, T3)> CombineEnumerable<T2, T3>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)[source.Length, source2.Length, source3.Length]);
		NList<(T, T2, T3)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(NList<T> source, NList<T2> source2, Func<T, T2, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(function);
		var length = Min(source._size, source2._size);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(NList<T> source, NList<T2> source2, Func<T, T2, int, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(function);
		var length = Min(source._size, source2._size);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2)> CombineEnumerable<T2>(NList<T> source, NList<T2> source2) where T2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		var length = Min(source._size, source2._size);
		NList<(T, T2)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source._items[i], source2._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		ArgumentNullException.ThrowIfNull(function);
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)[source._size, source2._size, source3._size]);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i], source3._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, int, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		ArgumentNullException.ThrowIfNull(function);
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)[source._size, source2._size, source3._size]);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i], source3._items[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2, T3)> CombineEnumerable<T2, T3>(NList<T> source, NList<T2> source2, NList<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(source2);
		ArgumentNullException.ThrowIfNull(source3);
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)[source._size, source2._size, source3._size]);
		NList<(T, T2, T3)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source._items[i], source2._items[i], source3._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ConvertAndJoinEnumerable<TResult>(NList<T> source, Func<T, IEnumerable<TResult>> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source._items[i]));
		return result;
	}

	internal static NList<TResult> ConvertAndJoinEnumerable<TResult>(NList<T> source, Func<T, int, IEnumerable<TResult>> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source._items[i], i));
		return result;
	}

	internal static NList<T> EmptyListEnumerable(int length) => new(length) { _size = length };

	internal static NList<TResult> FillEnumerable<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(i);
		result._size = length;
		return result;
	}

	internal static NList<TResult> FillEnumerable<TResult>(TResult elem, int length) where TResult : unmanaged
	{
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = elem;
		result._size = length;
		return result;
	}

	internal static NList<T> FilterEnumerable(NList<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> FilterEnumerable(NList<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item, i))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> FindAllEnumerable(NList<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> FindAllEnumerable(NList<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item, i))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
				if (function(list.GetInternal(i)))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
				if (function(list3[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (int)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (uint)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (long)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x) => function(x) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
		}
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MeanEnumerable(list, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MeanEnumerable(array.AsSpan(), function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MeanEnumerable(list2, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : [];
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MeanEnumerable(list3, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(list3, (x, index) => function(x, index) == value2) : [];
		}
		else
		{
			var value = List<T_>.MeanEnumerable(source, function);
			var value2 = (MpzT)value;
			indicator = value2;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x) => function(x) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var value = List<T_>.MedianEnumerable(list, function);
			indicator = value;
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var value = List<T_>.MedianEnumerable(array.AsSpan(), function);
			indicator = value;
			return FindIndexesEnumerable<T_>(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var value = List<T_>.MedianEnumerable(list2, function);
			indicator = value;
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var value = List<T_>.MedianEnumerable(list3, function);
			indicator = value;
			return FindIndexesEnumerable(list3, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = List<T_>.MedianEnumerable(source, function);
			indicator = value;
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function, out decimal indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function, out double indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function, out int indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function, out uint indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function, out long indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function, out MpzT indicator)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = [];
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(comparer);
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, T>> GroupEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, T>> result = new(array.Length);
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, T>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, T>> GroupEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, T>> result = new(array.Length);
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, T>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		ArgumentNullException.ThrowIfNull(function);
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, TResult>> result = new(array.Length);
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, TResult>> result = new(length);
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, TResult>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<NGroup<T, T>> GroupEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is NList<T> list)
		{
			var length = list._size;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<NGroup<T, T>> result = new(array.Length);
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			List<NGroup<T, T>> result = new(length);
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<NGroup<T, T>> result = new(List<bool>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result.GetInternal(index).Add(item);
				else
					result.Add(new(32, item, f));
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfEnumerable<T_>(IEnumerable<T_> source, T_ target)
	{
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfEnumerable(NList<T> source, T target)
	{
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (source._items[i].Equals(target))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is decimal[] array)
		{
			NList<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is double[] array)
		{
			NList<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is int[] array)
		{
			NList<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is uint[] array)
		{
			NList<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is long[] array)
		{
			NList<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is MpzT[] array)
		{
			NList<int> result = new(array.Length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var value = (int)(List<int>.SumEnumerable(list, x => (long)x) / Math.Max(list.Length, 1));
			return IndexesOfEnumerable(list, value);
		}
		else if (source is int[] array)
		{
			var value = (int)(List<int>.SumEnumerable(array.AsSpan(), x => (long)x) / Math.Max(array.Length, 1));
			return IndexesOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<int> list2)
		{
			var value = (int)(List<int>.SumEnumerable(list2, x => (long)x) / Math.Max(list2.Count, 1));
			return IndexesOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var value = (uint)(List<uint>.SumEnumerable(list, x => (long)x) / Math.Max(list.Length, 1));
			return IndexesOfEnumerable(list, value);
		}
		else if (source is uint[] array)
		{
			var value = (uint)(List<uint>.SumEnumerable(array.AsSpan(), x => (long)x) / Math.Max(array.Length, 1));
			return IndexesOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<uint> list2)
		{
			var value = (uint)(List<uint>.SumEnumerable(list2, x => (long)x) / Math.Max(list2.Count, 1));
			return IndexesOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var value = (long)(List<long>.SumEnumerable(list, x => (MpzT)x) / Math.Max(list.Length, 1));
			return IndexesOfEnumerable(list, value);
		}
		else if (source is long[] array)
		{
			var value = (long)(List<long>.SumEnumerable(array.AsSpan(), x => (MpzT)x) / Math.Max(array.Length, 1));
			return IndexesOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<long> list2)
		{
			var value = (long)(List<long>.SumEnumerable(list2, x => (MpzT)x) / Math.Max(list2.Count, 1));
			return IndexesOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var value = SumEnumerable(list) / Math.Max(list.Length, 1);
			return IndexesOfEnumerable(list, value);
		}
		else if (source is MpzT[] array)
		{
			var value = List<T_>.SumEnumerable(array.AsSpan()) / Math.Max(array.Length, 1);
			return IndexesOfEnumerable(array.AsSpan(), value);
		}
		else if (source is G.IList<MpzT> list2)
		{
			var value = SumEnumerable(list2) / Math.Max(list2.Count, 1);
			return IndexesOfEnumerable(list2, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is decimal[] array)
		{
			NList<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is double[] array)
		{
			NList<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is int[] array)
		{
			NList<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is uint[] array)
		{
			NList<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is long[] array)
		{
			NList<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list._size;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is MpzT[] array)
		{
			NList<int> result = new(array.Length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = ToNListEnumerable(list, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = ToNListEnumerable(array.AsSpan(), function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = ToNListEnumerable(list2, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = ToNListEnumerable(list3, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			var value = SumEnumerable(list_) / Math.Max(list_.Length, 1);
			return IndexesOfEnumerable(list_, value);
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			var list_ = List<T_>.ConvertEnumerable(list, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is T_[] array)
		{
			var length = array.Length;
			var list_ = List<T_>.ConvertEnumerable(array, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			var list_ = List<T_>.ConvertEnumerable(list2.GetSlice(), function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			var list_ = List<T_>.ConvertEnumerable(list3, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ToNListEnumerable(source, function);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var list_ = ReturnOrConstruct(list);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is MpzT[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else if (source is G.IList<MpzT> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T_[] array)
		{
			NList<int> result = new(array.Length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<int> result = new(length);
			MpzT indicator = 0;
			var j = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			NList<int> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear(false);
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static decimal MaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Max(list._items[0], list._items[1]),
					3 => Max(Max(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is decimal[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Max(array[0], array[1]),
					3 => Max(Max(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Max(list2[0], list2[1]),
					3 => Max(Max(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Max(list._items[0], list._items[1]),
					3 => Max(Max(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is double[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Max(array[0], array[1]),
					3 => Max(Max(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Max(list2[0], list2[1]),
					3 => Max(Max(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Max(list._items[0], list._items[1]),
					3 => Max(Max(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is int[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Max(array[0], array[1]),
					3 => Max(Max(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Max(list2[0], list2[1]),
					3 => Max(Max(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Max(list._items[0], list._items[1]),
					3 => Max(Max(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is uint[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Max(array[0], array[1]),
					3 => Max(Max(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Max(list2[0], list2[1]),
					3 => Max(Max(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Max(list._items[0], list._items[1]),
					3 => Max(Max(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is long[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Max(array[0], array[1]),
					3 => Max(Max(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Max(list2[0], list2[1]),
					3 => Max(Max(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static MpzT MaxEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => MpzT.Max(list._items[0], list._items[1]),
					3 => MpzT.Max(MpzT.Max(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is MpzT[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => MpzT.Max(array[0], array[1]),
					3 => MpzT.Max(MpzT.Max(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => MpzT.Max(list2[0], list2[1]),
					3 => MpzT.Max(MpzT.Max(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MeanEnumerable(IEnumerable<decimal> source) => MeanInternal<decimal, decimal, decimal>(source);

	internal static double MeanEnumerable(IEnumerable<double> source) => MeanInternal<double, double, double>(source);

	internal static double MeanEnumerable(IEnumerable<int> source) => MeanInternal<int, long, double>(source);

	internal static double MeanEnumerable(IEnumerable<uint> source) => MeanInternal<uint, ulong, double>(source);

	internal static double MeanEnumerable(IEnumerable<long> source) => MeanInternal<long, MpzT, double>(source);

	internal static double MeanEnumerable(IEnumerable<MpzT> source) => MeanInternal<MpzT, MpzT, double>(source);

	private static TResult MeanInternal<TSource, TAccumulator, TResult>(IEnumerable<TSource> source) where TSource : struct, INumber<TSource> where TAccumulator : struct, INumber<TAccumulator> where TResult : struct, INumber<TResult>
	{
		ArgumentNullException.ThrowIfNull(source);
		using var e = source.GetEnumerator();
		if (!e.MoveNext())
			return TResult.Zero;
		var sum = TAccumulator.CreateChecked(e.Current);
		var count = 1;
		while (e.MoveNext())
		{
			checked
			{
				sum += TAccumulator.CreateChecked(e.Current);
				count++;
			}
		}
		return TResult.CreateChecked(sum) / TResult.CreateChecked(count);
	}

	internal static decimal MinEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Min(list._items[0], list._items[1]),
					3 => Min(Min(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is decimal[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Min(array[0], array[1]),
					3 => Min(Min(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Min(list2[0], list2[1]),
					3 => Min(Min(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Min(list._items[0], list._items[1]),
					3 => Min(Min(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is double[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Min(array[0], array[1]),
					3 => Min(Min(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Min(list2[0], list2[1]),
					3 => Min(Min(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Min(list._items[0], list._items[1]),
					3 => Min(Min(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is int[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Min(array[0], array[1]),
					3 => Min(Min(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Min(list2[0], list2[1]),
					3 => Min(Min(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Min(list._items[0], list._items[1]),
					3 => Min(Min(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is uint[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Min(array[0], array[1]),
					3 => Min(Min(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Min(list2[0], list2[1]),
					3 => Min(Min(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => Min(list._items[0], list._items[1]),
					3 => Min(Min(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is long[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => Min(array[0], array[1]),
					3 => Min(Min(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => Min(list2[0], list2[1]),
					3 => Min(Min(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static MpzT MinEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => MpzT.Min(list._items[0], list._items[1]),
					3 => MpzT.Min(MpzT.Min(list._items[0], list._items[1]), list._items[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is MpzT[] array)
		{
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => MpzT.Min(array[0], array[1]),
					3 => MpzT.Min(MpzT.Min(array[0], array[1]), array[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => MpzT.Min(list2[0], list2[1]),
					3 => MpzT.Min(MpzT.Min(list2[0], list2[1]), list2[2]),
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT indicator = 0;
			MpzT f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			MpzT indicator = 0;
			MpzT f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static NList<TResult> PairsEnumerable<T_, TResult>(IEnumerable<T_> source, Func<T_, T_, TResult> function, int offset = 1) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		if (source is List<T_> list)
		{
			var length = list.Length - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list.GetInternal(i + offset);
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			var length = array.Length - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array[i + offset];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				var item2 = list2[i + offset];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				var item2 = list3[i + offset];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else
		{
			NList<TResult> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? Max(length - offset, 0) : 1024);
			if (result.Capacity == 0)
				return result;
			using var en = source.GetEnumerator();
			using LimitedQueue<T_> queue = new(offset);
			while (!queue.IsFull && en.MoveNext())
				queue.Enqueue(en.Current);
			var i = 0;
			while (en.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = queue.Dequeue();
				var item2 = en.Current;
				result._items[i] = function(item, item2);
				queue.Enqueue(item2);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static NList<TResult> PairsEnumerable<T_, TResult>(IEnumerable<T_> source, Func<T_, T_, int, TResult> function, int offset = 1) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		if (source is List<T_> list)
		{
			var length = list.Length - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list.GetInternal(i + offset);
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			var length = array.Length - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array[i + offset];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				var item2 = list2[i + offset];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count - offset;
			if (length <= 0)
				return [];
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				var item2 = list3[i + offset];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			NList<TResult> result = new(List<T_>.TryGetLengthEasilyEnumerable(source, out var length) ? Max(length - offset, 0) : 1024);
			if (result.Capacity == 0)
				return result;
			using var en = source.GetEnumerator();
			using LimitedQueue<T_> queue = new(offset);
			while (!queue.IsFull && en.MoveNext())
				queue.Enqueue(en.Current);
			var i = 0;
			while (en.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = queue.Dequeue();
				var item2 = en.Current;
				result._items[i] = function(item, item2, i);
				queue.Enqueue(item2);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static NList<(T, T)> PairsEnumerable(IEnumerable<T> source, int offset = 1)
	{
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		if (source is List<T> list)
		{
			var length = list.Length - offset;
			if (length <= 0)
				return [];
			NList<(T, T)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				var item2 = list.GetInternal(i + offset);
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length - offset;
			if (length <= 0)
				return [];
			NList<(T, T)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array[i + offset];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count - offset;
			if (length <= 0)
				return [];
			NList<(T, T)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				var item2 = list2[i + offset];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count - offset;
			if (length <= 0)
				return [];
			NList<(T, T)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				var item2 = list3[i + offset];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else
		{
			NList<(T, T)> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? Max(length - offset, 0) : 1024);
			if (result.Capacity == 0)
				return result;
			using var en = source.GetEnumerator();
			using LimitedQueue<T> queue = new(offset);
			while (!queue.IsFull && en.MoveNext())
				queue.Enqueue(en.Current);
			var i = 0;
			while (en.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = queue.Dequeue();
				var item2 = en.Current;
				result._items[i] = (item, item2);
				queue.Enqueue(item2);
				i++;
			}
			result._size = i;
			result._size = i;
			return result;
		}
	}

	internal static NList<TResult> PairsEnumerable<T_, TResult>(ReadOnlySpan<T_> source, Func<T_, T_, TResult> function, int offset = 1) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		var length = source.Length - offset;
		if (length <= 0)
			return [];
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			var item2 = source[i + offset];
			result._items[i] = function(item, item2);
		}
		result._size = length;
		return result;
	}

	internal static NList<TResult> PairsEnumerable<T_, TResult>(ReadOnlySpan<T_> source, Func<T_, T_, int, TResult> function, int offset = 1) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		var length = source.Length - offset;
		if (length <= 0)
			return [];
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			var item2 = source[i + offset];
			result._items[i] = function(item, item2, i);
		}
		result._size = length;
		return result;
	}

	internal static NList<(T, T)> PairsEnumerable(ReadOnlySpan<T> source, int offset = 1)
	{
		ArgumentOutOfRangeException.ThrowIfLessThan(offset, 1);
		var length = source.Length - offset;
		if (length <= 0)
			return [];
		NList<(T, T)> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			var item2 = source[i + offset];
			result._items[i] = (item, item2);
		}
		result._size = length;
		return result;
	}

	internal static decimal ProductEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list._items[0],
					2 => list._items[0] * list._items[1],
					3 => list._items[0] * list._items[1] * list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= item;
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			decimal result = 1;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => array[0],
					2 => array[0] * array[1],
					3 => array[0] * array[1] * array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= item;
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list2[0],
					2 => list2[0] * list2[1],
					3 => list2[0] * list2[1] * list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= item;
			}
			return result;
		}
		else
		{
			decimal result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= item;
				i++;
			}
			return result;
		}
	}

	internal static double ProductEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list._items[0],
					2 => list._items[0] * list._items[1],
					3 => list._items[0] * list._items[1] * list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= item;
			}
			return result;
		}
		else if (source is double[] array)
		{
			double result = 1;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => array[0],
					2 => array[0] * array[1],
					3 => array[0] * array[1] * array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= item;
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list2[0],
					2 => list2[0] * list2[1],
					3 => list2[0] * list2[1] * list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= item;
			}
			return result;
		}
		else
		{
			double result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= item;
				i++;
			}
			return result;
		}
	}

	internal static int ProductEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list._items[0],
					2 => list._items[0] * list._items[1],
					3 => list._items[0] * list._items[1] * list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= item;
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = 1;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => array[0],
					2 => array[0] * array[1],
					3 => array[0] * array[1] * array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= item;
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list2[0],
					2 => list2[0] * list2[1],
					3 => list2[0] * list2[1] * list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= item;
			}
			return result;
		}
		else
		{
			var result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= item;
				i++;
			}
			return result;
		}
	}

	internal static uint ProductEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list._items[0],
					2 => list._items[0] * list._items[1],
					3 => list._items[0] * list._items[1] * list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= item;
			}
			return result;
		}
		else if (source is uint[] array)
		{
			uint result = 1;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => array[0],
					2 => array[0] * array[1],
					3 => array[0] * array[1] * array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= item;
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list2[0],
					2 => list2[0] * list2[1],
					3 => list2[0] * list2[1] * list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= item;
			}
			return result;
		}
		else
		{
			uint result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= item;
				i++;
			}
			return result;
		}
	}

	internal static long ProductEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list._items[0],
					2 => list._items[0] * list._items[1],
					3 => list._items[0] * list._items[1] * list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= item;
			}
			return result;
		}
		else if (source is long[] array)
		{
			long result = 1;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => array[0],
					2 => array[0] * array[1],
					3 => array[0] * array[1] * array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= item;
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list2[0],
					2 => list2[0] * list2[1],
					3 => list2[0] * list2[1] * list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= item;
			}
			return result;
		}
		else
		{
			long result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= item;
				i++;
			}
			return result;
		}
	}

	internal static MpzT ProductEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list._size;
			MpzT result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result *= item;
			}
			return result;
		}
		else if (source is MpzT[] array)
		{
			MpzT result = 1;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 1,
					1 => array[0],
					2 => array[0] * array[1],
					3 => array[0] * array[1] * array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result *= item;
			}
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 1,
					1 => list2[0],
					2 => list2[0] * list2[1],
					3 => list2[0] * list2[1] * list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 1;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result *= item;
			}
			return result;
		}
		else
		{
			MpzT result = 1;
			var i = 0;
			foreach (var item in source)
			{
				result *= item;
				i++;
			}
			return result;
		}
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable(NList<T> source)
	{
		FastDelHashSet<T> hs = new(EqualityComparer<T>.Default);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable(NList<T> source, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable(NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(NList<T> source)
	{
		ListHashSet<T> dic = [];
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(NList<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<T> ReverseEnumerable(NList<T> source)
	{
		var length = source._size;
		NList<T> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[source._size - 1 - i] = source._items[i];
		result._size = length;
		return result;
	}

	internal static NList<TResult> ShuffleEnumerable<T_, TResult>(IEnumerable<T_> source, Func<T_, TResult> function, Random random) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list.GetInternal(0));
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list.GetInternal(i);
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			NList<TResult> result = new(array.Length);
			if (array.Length == 0)
				return result;
			result._items[0] = function(array[0]);
			int blend;
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list2[0]);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list3[0]);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
			}
			result._size = length;
			return result;
		}
		else if (List<T_>.TryGetLengthEasilyEnumerable(source, out var length))
		{
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item);
				}
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			NList<TResult> result = new(1024);
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result.Add(function(item));
				else
				{
					result.Add(result._items[blend]);
					result._items[blend] = function(item);
				}
				i++;
			}
			return result;
		}
	}

	internal static NList<TResult> ShuffleEnumerable<T_, TResult>(IEnumerable<T_> source, Func<T_, int, TResult> function, Random random) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list.GetInternal(0), 0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list.GetInternal(i);
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			NList<TResult> result = new(array.Length);
			if (array.Length == 0)
				return result;
			result._items[0] = function(array[0], 0);
			int blend;
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list2[0], 0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = function(list3[0], 0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
			}
			result._size = length;
			return result;
		}
		else if (List<T_>.TryGetLengthEasilyEnumerable(source, out var length))
		{
			NList<TResult> result = new(length);
			if (length == 0)
				return result;
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = function(item, i);
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = function(item, i);
				}
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			NList<TResult> result = new(1024);
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result.Add(function(item, i));
				else
				{
					result.Add(result._items[blend]);
					result._items[blend] = function(item, i);
				}
				i++;
			}
			return result;
		}
	}

	internal static NList<T> ShuffleEnumerable(IEnumerable<T> source, Random random)
	{
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<T> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = list.GetInternal(0);
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list.GetInternal(i);
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			NList<T> result = new(array.Length);
			if (array.Length == 0)
				return result;
			result._items[0] = array[0];
			int blend;
			for (var i = 1; i < array.Length; i++)
			{
				var item = array[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<T> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = list2[0];
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list2[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T> list3)
		{
			var length = list3.Count;
			NList<T> result = new(length);
			if (length == 0)
				return result;
			result._items[0] = list3[0];
			int blend;
			for (var i = 1; i < length; i++)
			{
				var item = list3[i];
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
			}
			result._size = length;
			return result;
		}
		else if (List<T>.TryGetLengthEasilyEnumerable(source, out var length))
		{
			NList<T> result = new(length);
			if (length == 0)
				return result;
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result._items[i] = item;
				else
				{
					result._items[i] = result._items[blend];
					result._items[blend] = item;
				}
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			NList<T> result = new(1024);
			int blend;
			var i = 0;
			foreach (var item in source)
			{
				blend = random.Next(i + 1);
				if (blend == i)
					result.Add(item);
				else
				{
					result.Add(result._items[blend]);
					result._items[blend] = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is NList<T> list)
			return list.SkipWhile(function);
		else
		{
			NList<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is NList<T> list)
			return list.SkipWhile(function);
		else
		{
			NList<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current, i); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static List<NList<T>> SplitIntoEqualEnumerable(G.IReadOnlyList<T> source, int fragmentLength)
	{
		if (fragmentLength <= 0)
			throw new ArgumentException("Длина фрагмента должна быть положительной.", nameof(fragmentLength));
		var length = GetArrayLength(source.Count, fragmentLength);
		List<NList<T>> result = new(length);
		var count2 = source.Count / fragmentLength;
		var index = 0;
		for (var i = 0; i < count2; i++)
		{
			result.Add(new(fragmentLength));
			for (var j = 0; j < fragmentLength; j++)
				result.GetInternal(i)._items[j] = source[index++];
			result.GetInternal(i)._size = fragmentLength;
		}
		var rest = source.Count % fragmentLength;
		if (rest != 0)
		{
			result.Add(new(rest));
			for (var j = 0; j < rest; j++)
				result.GetInternal(count2)._items[j] = source[index++];
			result.GetInternal(count2)._size = rest;
		}
		return result;
	}

	internal static decimal SumEnumerable(IEnumerable<decimal> source)
	{
		if (source is NList<decimal> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => list._items[0] + list._items[1],
					3 => list._items[0] + list._items[1] + list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			decimal result = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => array[0] + array[1],
					3 => array[0] + array[1] + array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => list2[0] + list2[1],
					3 => list2[0] + list2[1] + list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<double> source)
	{
		if (source is NList<double> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => list._items[0] + list._items[1],
					3 => list._items[0] + list._items[1] + list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is double[] array)
		{
			double result = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => array[0] + array[1],
					3 => array[0] + array[1] + array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => list2[0] + list2[1],
					3 => list2[0] + list2[1] + list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<int> source)
	{
		if (source is NList<int> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => list._items[0] + list._items[1],
					3 => list._items[0] + list._items[1] + list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => array[0] + array[1],
					3 => array[0] + array[1] + array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => list2[0] + list2[1],
					3 => list2[0] + list2[1] + list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			var result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<uint> source)
	{
		if (source is NList<uint> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => list._items[0] + list._items[1],
					3 => list._items[0] + list._items[1] + list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is uint[] array)
		{
			uint result = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => array[0] + array[1],
					3 => array[0] + array[1] + array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => list2[0] + list2[1],
					3 => list2[0] + list2[1] + list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			uint result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<long> source)
	{
		if (source is NList<long> list)
		{
			var length = list._size;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list._items[0],
					2 => list._items[0] + list._items[1],
					3 => list._items[0] + list._items[1] + list._items[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is long[] array)
		{
			long result = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => array[0] + array[1],
					3 => array[0] + array[1] + array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => list2[0] + list2[1],
					3 => list2[0] + list2[1] + list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			long result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static MpzT SumEnumerable(IEnumerable<MpzT> source)
	{
		if (source is NList<MpzT> list)
		{
			var length = list._size;
			MpzT result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is MpzT[] array)
		{
			MpzT result = 0;
			if (array.Length <= 3)
			{
				return array.Length switch
				{
					0 => 0,
					1 => array[0],
					2 => array[0] + array[1],
					3 => array[0] + array[1] + array[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<MpzT> list2)
		{
			var length = list2.Count;
			if (length <= 3)
			{
				return length switch
				{
					0 => 0,
					1 => list2[0],
					2 => list2[0] + list2[1],
					3 => list2[0] + list2[1] + list2[2],
					_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
				};
			}
			MpzT result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			MpzT result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static Slice<T> TakeEnumerable(IEnumerable<T> source, int length)
	{
		if (length == 0)
			return new();
		else if (source is NList<T> list)
			return list.Take(length);
		else
		{
			NList<T> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i++] = item;
				if (i >= length)
					break;
			}
			result._size = i;
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is NList<T> list)
			return list.TakeWhile(function);
		else
		{
			NList<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is NList<T> list)
			return list.TakeWhile(function);
		else
		{
			NList<T> result = [];
			using var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current, i); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static NList<TResult> ToNListEnumerable<T_, TResult>(IEnumerable<T_> source, Func<T_, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list.GetInternal(i));
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			NList<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list3[i]);
			result._size = length;
			return result;
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			var i = 0;
			foreach (var item in source)
			{
				if ((i & i - 1) == 0)
					result.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static NList<TResult> ToNListEnumerable<T_, TResult>(IEnumerable<T_> source, Func<T_, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			NList<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			var i = 0;
			foreach (var item in source)
			{
				if ((i & i - 1) == 0)
					result.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static NList<TResult> ToNListEnumerable<T_, TResult>(ReadOnlySpan<T_> source, Func<T_, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ToNListEnumerable<T_, TResult>(ReadOnlySpan<T_> source, Func<T_, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], i);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ToNListEnumerable<TResult>(NList<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ToNListEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item, i);
		}
		result._size = length;
		return result;
	}

	internal static String ToNStringEnumerable<T_>(IEnumerable<T_> source, Func<T_, char> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			String result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list.GetInternal(i));
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			String result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			String result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			String result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list3[i]);
			result._size = length;
			return result;
		}
		else
		{
			String result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			var i = 0;
			foreach (var item in source)
			{
				if ((i & i - 1) == 0)
					result.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static String ToNStringEnumerable<T_>(IEnumerable<T_> source, Func<T_, int, char> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		if (source is List<T_> list)
		{
			var length = list.Length;
			String result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list.GetInternal(i);
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T_[] array)
		{
			String result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T_> list2)
		{
			var length = list2.Count;
			String result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IReadOnlyList<T_> list3)
		{
			var length = list3.Count;
			String result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list3[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			String result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			var i = 0;
			foreach (var item in source)
			{
				if ((i & i - 1) == 0)
					result.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static String ToNStringEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, char> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		String result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i]);
		result._size = length;
		return result;
	}

	internal static String ToNStringEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, char> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		String result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], i);
		result._size = length;
		return result;
	}

	internal static bool TryWrapEnumerable<TResult>(NList<T> source, Func<NList<T>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static NList<int> FindIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMaxIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : [];
	}

	internal static NList<int> FindMeanIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MeanEnumerable(source, function);
		var value2 = (MpzT)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : [];
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static NList<int> FindMedianIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var value = List<T_>.MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> FindMinIndexesEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfEnumerable<T_>(ReadOnlySpan<T_> source, T_ target)
	{
		var length = source.Length;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMaxEnumerable<T_>(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = (int)(List<int>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = (uint)(List<uint>.SumEnumerable(list_, x => (long)x) / Math.Max(list_.Length, 1));
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = (long)(List<long>.SumEnumerable(list_, x => (MpzT)x) / Math.Max(list_.Length, 1));
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = SumEnumerable(list_) / (MpzT)list_.Length;
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		var value = SumEnumerable(list_) / (MpzT)list_.Length;
		return IndexesOfEnumerable(list_, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<decimal> source)
	{
		var value = List<decimal>.MeanEnumerable(source);
		return IndexesOfEnumerable(source, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<double> source)
	{
		var value = List<double>.MeanEnumerable(source);
		return IndexesOfEnumerable(source, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<int> source)
	{
		var value = (int)(List<int>.SumEnumerable(source, x => (long)x) / Math.Max(source.Length, 1));
		return IndexesOfEnumerable(source, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<uint> source)
	{
		var value = (uint)(List<uint>.SumEnumerable(source, x => (long)x) / Math.Max(source.Length, 1));
		return IndexesOfEnumerable(source, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<long> source)
	{
		var value = (long)(List<long>.SumEnumerable(source, x => (MpzT)x) / Math.Max(source.Length, 1));
		return IndexesOfEnumerable(source, value);
	}

	internal static NList<int> IndexesOfMeanEnumerable<T_>(ReadOnlySpan<MpzT> source)
	{
		var value = List<MpzT>.SumEnumerable(source) / (MpzT)source.Length;
		return IndexesOfEnumerable(source, value);
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		var list_ = ToNListEnumerable(source, function);
		return IndexesOfEnumerable(list_, List<T_>.MedianEnumerable(list_));
	}

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<decimal> source) => IndexesOfEnumerable(source, List<T_>.MedianEnumerable(source));

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<double> source) => IndexesOfEnumerable(source, List<T_>.MedianEnumerable(source));

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<int> source) => IndexesOfEnumerable(source, List<T_>.MedianEnumerable(source));

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<uint> source) => IndexesOfEnumerable(source, List<T_>.MedianEnumerable(source));

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<long> source) => IndexesOfEnumerable(source, List<T_>.MedianEnumerable(source));

	internal static NList<int> IndexesOfMedianEnumerable<T_>(ReadOnlySpan<MpzT> source) => IndexesOfEnumerable(source, List<T_>.MedianEnumerable(source));

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfMinEnumerable<T_>(ReadOnlySpan<MpzT> source)
	{
		var length = source.Length;
		NList<int> result = new(length);
		MpzT indicator = 0;
		var j = 0;
		MpzT f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable<T_>(ReadOnlySpan<T_> source)
	{
		ListHashSet<T_> dic = [];
		var length = source.Length;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, T_, bool> equalFunction)
	{
		ListHashSet<T_> dic = new(new EComparer<T_>(equalFunction));
		var length = source.Length;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable<T_>(ReadOnlySpan<T_> source, Func<T_, T_, bool> equalFunction, Func<T_, int> hashCodeFunction)
	{
		ListHashSet<T_> dic = new(new EComparer<T_>(equalFunction, hashCodeFunction));
		var length = source.Length;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<T_, TResult, TResult2>(G.IReadOnlyList<T_> source, Func<T_, TResult> function, Func<T_, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<T_, TResult, TResult2>(G.IReadOnlyList<T_> source, Func<T_, int, TResult> function, Func<T_, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<T>, NList<T2>) PBreakEnumerable<T2>(G.IList<(T, T2)> source) where T2 : unmanaged
	{
		var length = source.Count;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<T_, TResult, TResult2>(G.IReadOnlyList<T_> source, Func<T_, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<T_, TResult, TResult2>(G.IReadOnlyList<T_> source, Func<T_, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<T_, TResult, TResult2, TResult3>(G.IReadOnlyList<T_> source, Func<T_, TResult> function, Func<T_, TResult2> function2, Func<T_, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		ArgumentNullException.ThrowIfNull(function3);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<T_, TResult, TResult2, TResult3>(G.IReadOnlyList<T_> source, Func<T_, int, TResult> function, Func<T_, int, TResult2> function2, Func<T_, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		ArgumentNullException.ThrowIfNull(function2);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<T>, NList<T2>, NList<T3>) PBreakEnumerable<T2, T3>(G.IList<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		var length = source.Count;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		NList<T3> result3 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i], result3._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<T_, TResult, TResult2, TResult3>(G.IReadOnlyList<T_> source, Func<T_, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<T_, TResult, TResult2, TResult3>(G.IReadOnlyList<T_> source, Func<T_, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static NList<TResult> PCombineEnumerable<T_, T2, TResult>(G.IReadOnlyList<T_> source, G.IList<T2> source2, Func<T_, T2, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Min(source.Count, source2.Count);
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PCombineEnumerable<T_, T2, TResult>(G.IReadOnlyList<T_> source, G.IList<T2> source2, Func<T_, T2, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = Min(source.Count, source2.Count);
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2, i);
		});
		result._size = length;
		return result;
	}

	internal static NList<(T, T2)> PCombineEnumerable<T2>(G.IReadOnlyList<T> source, G.IList<T2> source2) where T2 : unmanaged
	{
		var length = Min(source.Count, source2.Count);
		NList<(T, T2)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = (item, item2);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PCombineEnumerable<T_, T2, T3, TResult>(G.IReadOnlyList<T_> source, G.IList<T2> source2, G.IList<T3> source3, Func<T_, T2, T3, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = List<int>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PCombineEnumerable<T_, T2, T3, TResult>(G.IReadOnlyList<T_> source, G.IList<T2> source2, G.IList<T3> source3, Func<T_, T2, T3, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = List<int>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3, i);
		});
		result._size = length;
		return result;
	}

	internal static NList<(T, T2, T3)> PCombineEnumerable<T2, T3>(G.IReadOnlyList<T> source, G.IList<T2> source2, G.IList<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		var length = List<int>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		NList<(T, T2, T3)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = (item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (item.Equals(target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target, IEqualityComparer<T> comparer)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IReadOnlyList<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static NList<TResult> PConvertEnumerable<T_, TResult>(G.IReadOnlyList<T_> source, Func<T_, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(source[i]));
		result._size = length;
		return result;
	}

	internal static NList<TResult> PConvertEnumerable<T_, TResult>(G.IReadOnlyList<T_> source, Func<T_, int, TResult> function) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PFillEnumerable<TResult>(TResult elem, int length) where TResult : unmanaged
	{
		NList<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = elem);
		result._size = length;
		return result;
	}

	internal static NList<TResult> PFillEnumerable<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged
	{
		ArgumentNullException.ThrowIfNull(function);
		NList<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(i));
		result._size = length;
		return result;
	}

	internal static NList<T> PFilterEnumerable(G.IReadOnlyList<T> source, Func<T, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i]));
		NList<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static NList<T> PFilterEnumerable(G.IReadOnlyList<T> source, Func<T, int, bool> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		NList<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i], i));
		NList<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static decimal PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Max(function(source[0]), function(source[1])),
				3 => Max(Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static decimal PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Max(function(source[0], 0), function(source[1], 1)),
				3 => Max(Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static double PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Max(function(source[0]), function(source[1])),
				3 => Max(Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static double PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Max(function(source[0], 0), function(source[1], 1)),
				3 => Max(Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static int PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Max(function(source[0]), function(source[1])),
				3 => Max(Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static int PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Max(function(source[0], 0), function(source[1], 1)),
				3 => Max(Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static uint PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Max(function(source[0]), function(source[1])),
				3 => Max(Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static uint PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Max(function(source[0], 0), function(source[1], 1)),
				3 => Max(Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static long PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Max(function(source[0]), function(source[1])),
				3 => Max(Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static long PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Max(function(source[0], 0), function(source[1], 1)),
				3 => Max(Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static MpzT PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => MpzT.Max(function(source[0]), function(source[1])),
				3 => MpzT.Max(MpzT.Max(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static MpzT PMaxEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => MpzT.Max(function(source[0], 0), function(source[1], 1)),
				3 => MpzT.Max(MpzT.Max(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f < indicator)
				return;
			lock (lockObj)
				if (f > indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static decimal PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Min(function(source[0]), function(source[1])),
				3 => Min(Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static decimal PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, decimal> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Min(function(source[0], 0), function(source[1], 1)),
				3 => Min(Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static double PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Min(function(source[0]), function(source[1])),
				3 => Min(Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static double PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, double> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Min(function(source[0], 0), function(source[1], 1)),
				3 => Min(Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static int PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Min(function(source[0]), function(source[1])),
				3 => Min(Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static int PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, int> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Min(function(source[0], 0), function(source[1], 1)),
				3 => Min(Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static uint PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Min(function(source[0]), function(source[1])),
				3 => Min(Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static uint PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, uint> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Min(function(source[0], 0), function(source[1], 1)),
				3 => Min(Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static long PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => Min(function(source[0]), function(source[1])),
				3 => Min(Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static long PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, long> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => Min(function(source[0], 0), function(source[1], 1)),
				3 => Min(Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static MpzT PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0]),
				2 => MpzT.Min(function(source[0]), function(source[1])),
				3 => MpzT.Min(MpzT.Min(function(source[0]), function(source[1])), function(source[2])),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0]);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}

	internal static MpzT PMinEnumerable<T_>(G.IReadOnlyList<T_> source, Func<T_, int, MpzT> function)
	{
		ArgumentNullException.ThrowIfNull(function);
		var length = source.Count;
		if (length <= 3)
		{
			return length switch
			{
				0 => 0,
				1 => function(source[0], 0),
				2 => MpzT.Min(function(source[0], 0), function(source[1], 1)),
				3 => MpzT.Min(MpzT.Min(function(source[0], 0), function(source[1], 1)), function(source[2], 2)),
				_ => throw new ApplicationException("Произошла серьезная ошибка при попытке выполнить действие. К сожалению, причина ошибки неизвестна.")
			};
		}
		var indicator = function(source[0], 0);
		object lockObj = new();
		Parallel.For(1, source.Count, i =>
		{
			var item = source[i];
			var f = function(item, i);
			if (f > indicator)
				return;
			lock (lockObj)
				if (f < indicator)
					indicator = f;
		});
		return indicator;
	}
}

public static class RedStarLinq
{
	public static bool All<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool All<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool AllEqual<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.AllEqualEnumerable(source, function);
	public static bool AllEqual<T>(this IEnumerable<T> source, Func<T, T, bool> function) => List<T>.AllEqualEnumerable(source, function);
	public static bool AllEqual<T>(this IEnumerable<T> source, Func<T, T, int, bool> function) => List<T>.AllEqualEnumerable(source, function);
	public static bool AllEqual<T>(this IEnumerable<T> source) => List<T>.AllEqualEnumerable(source);
	public static bool AllUnique<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.AllUniqueEnumerable(source, function);
	public static bool AllUnique<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.AllUniqueEnumerable(source, function);
	public static bool AllUnique<T>(this IEnumerable<T> source) => List<T>.AllUniqueEnumerable(source);
	public static bool Any<T>(this IEnumerable<T> source) => Enumerable.Any(source);
	public static bool Any<T>(this IEnumerable<T> source, Func<T, bool> function) => Enumerable.Any(source, function);
	public static bool Any<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.AnyEnumerable(source, function);
	public static Slice<T> Append<T>(this G.IReadOnlyList<T> source, T element) => List<T>.AppendEnumerable(source, element);
	public static IEnumerable<T> Append<T>(this IEnumerable<T> source, T element) => Enumerable.Append(source, element);
	public static IEnumerable<T> AsEnumerable<T>(this IEnumerable<T> source) => source;
	public static Span<T> AsSpan<T>(this IEnumerable<T> source) => source is BaseIndexable<T> collection ? collection.AsSpan() : source is T[] array ? MemoryExtensions.AsSpan(array) : List<T>.ReturnOrConstruct(source).AsSpan();
	public static Span<T> AsSpan<T>(this IEnumerable<T> source, Index index) => source is BaseIndexable<T> collection ? collection.AsSpan(index) : source is T[] array ? MemoryExtensions.AsSpan(array, index) : List<T>.ReturnOrConstruct(source).AsSpan(index);
	public static Span<T> AsSpan<T>(this IEnumerable<T> source, int index) => source is BaseIndexable<T> collection ? collection.AsSpan(index) : source is T[] array ? MemoryExtensions.AsSpan(array, index) : List<T>.ReturnOrConstruct(source).AsSpan(index);
	public static Span<T> AsSpan<T>(this IEnumerable<T> source, int index, int length) => source is BaseIndexable<T> collection ? collection.AsSpan(index, length) : source is T[] array ? MemoryExtensions.AsSpan(array, index, length) : List<T>.ReturnOrConstruct(source).AsSpan(index, length);
	public static Span<T> AsSpan<T>(this IEnumerable<T> source, Range range) => AsSpan(source)[range];
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<T>, List<T2>) Break<T, T2>(this IEnumerable<(T, T2)> source) => List<T>.BreakEnumerable(source);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this IEnumerable<(T, T2, T3)> source) => List<T>.BreakEnumerable(source);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static List<T> BreakFilter<T>(this IEnumerable<T> source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static List<T> BreakFilter<T>(this IEnumerable<T> source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static (List<T>, List<T>) BreakFilter<T>(this IEnumerable<T> source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this IEnumerable<T> source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static Slice<TResult> Combine<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static IEnumerable<TResult> Combine<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, TResult> function) => Enumerable.Zip(source, source2, function);
	public static Slice<TResult> Combine<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static IEnumerable<TResult> Combine<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static Slice<(T, T2)> Combine<T, T2>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2) => List<T>.CombineEnumerable(source, source2);
	public static IEnumerable<(T, T2)> Combine<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => Enumerable.Zip(source, source2);
	public static Slice<TResult> Combine<T, T2, T3, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static IEnumerable<TResult> Combine<T, T2, T3, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static Slice<TResult> Combine<T, T2, T3, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static IEnumerable<TResult> Combine<T, T2, T3, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static Slice<(T, T2, T3)> Combine<T, T2, T3>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3) => List<T>.CombineEnumerable(source, source2, source3);
	public static IEnumerable<(T, T2, T3)> Combine<T, T2, T3>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3) => Enumerable.Zip(source, source2, source3);
	public static Slice<TResult> Combine<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, T2, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, function);
	public static IEnumerable<TResult> Combine<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T2, TResult> function) => Enumerable.Zip(source.Item1, source.Item2, function);
	public static Slice<TResult> Combine<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, function);
	public static IEnumerable<TResult> Combine<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, function);
	public static Slice<(T, T2)> Combine<T, T2>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source) => List<T>.CombineEnumerable(source.Item1, source.Item2);
	public static IEnumerable<(T, T2)> Combine<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source) => Enumerable.Zip(source.Item1, source.Item2);
	public static Slice<TResult> Combine<T, T2, T3, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>, G.IReadOnlyList<T3>) source, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static IEnumerable<TResult> Combine<T, T2, T3, TResult>(this (IEnumerable<T>, IEnumerable<T2>, IEnumerable<T3>) source, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static Slice<TResult> Combine<T, T2, T3, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>, G.IReadOnlyList<T3>) source, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static IEnumerable<TResult> Combine<T, T2, T3, TResult>(this (IEnumerable<T>, IEnumerable<T2>, IEnumerable<T3>) source, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static Slice<(T, T2, T3)> Combine<T, T2, T3>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>, G.IReadOnlyList<T3>) source) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3);
	public static IEnumerable<(T, T2, T3)> Combine<T, T2, T3>(this (IEnumerable<T>, IEnumerable<T2>, IEnumerable<T3>) source) => Enumerable.Zip(source.Item1, source.Item2, source.Item3);
	public static List<T> Concat<T>(this IEnumerable<T> source, params IEnumerable<T>[] collections) => List<T>.ConcatEnumerable(source, collections);
	public static bool Contains<T>(this IEnumerable<T> source, T target) => List<T>.ContainsEnumerable(source, target);
	public static bool Contains<T>(this IEnumerable<T> source, T target, IEqualityComparer<T> comparer) => List<T>.ContainsEnumerable(source, target, comparer);
	public static bool Contains<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.ContainsEnumerable(source, target, equalFunction);
	public static bool Contains<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.ContainsEnumerable(source, target, equalFunction, hashCodeFunction);
	public static Slice<TResult> Convert<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static IEnumerable<TResult> Convert<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => Enumerable.Select(source, function);
	public static Slice<TResult> Convert<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static IEnumerable<TResult> Convert<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => Enumerable.Select(source, function);
	public static IEnumerable<TResult> ConvertAndJoin<T, TResult>(this IEnumerable<T> source, Func<T, IEnumerable<TResult>> function) => Enumerable.SelectMany(source, function);
	public static IEnumerable<TResult> ConvertAndJoin<T, TResult>(this IEnumerable<T> source, Func<T, int, IEnumerable<TResult>> function) => Enumerable.SelectMany(source, function);
	public static IEnumerable<TResult> ConvertAndJoin<T, TCollection, TResult>(this IEnumerable<T> source, Func<T, IEnumerable<TCollection>> collectionSelector, Func<T, TCollection, TResult> resultSelector) => Enumerable.SelectMany(source, collectionSelector, resultSelector);
	public static IEnumerable<TResult> ConvertAndJoin<T, TCollection, TResult>(this IEnumerable<T> source, Func<T, int, IEnumerable<TCollection>> collectionSelector, Func<T, TCollection, int, TResult> resultSelector) => List<T>.ConvertAndJoin(source, collectionSelector, resultSelector);
	public static List<List<T>> CopyDoubleList<T>(this List<List<T>> source) => source.ToList(x => x.Copy());
	public static List<List<List<T>>> CopyTripleList<T>(this List<List<List<T>>> source) => source.ToList(x => x.CopyDoubleList());
	public static int Count<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this IEnumerable<T> source, T target) => List<T>.CountEnumerable(source, target);
	public static IEnumerable<T?> DefaultIfEmpty<T>(this IEnumerable<T> source) => Enumerable.DefaultIfEmpty(source);
	public static IEnumerable<T> DefaultIfEmpty<T>(this IEnumerable<T> source, T defaultValue) => Enumerable.DefaultIfEmpty(source, defaultValue);
	public static T ElementAt<T>(this IEnumerable<T> source, int index) => Enumerable.ElementAt(source, index);
	public static T? ElementAtOrDefault<T>(this IEnumerable<T> source, int index) => Enumerable.ElementAtOrDefault(source, index);
	public static IEnumerable<T?> Empty<T>() => [];
	public static List<T> EmptyList<T>(int length) => List<T>.EmptyListEnumerable(length);
	public static bool Equals<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.EqualsEnumerable(source, source2);
	public static IEnumerable<T> Except<T>(this IEnumerable<T> source, IEnumerable<T> source2) => Enumerable.Except(source, source2);
	public static IEnumerable<T> Except<T>(this IEnumerable<T> source, IEnumerable<T> source2, IEqualityComparer<T> comparer) => Enumerable.Except(source, source2, comparer);
	public static List<TResult> Fill<TResult>(TResult elem, int length) => List<bool>.FillEnumerable(elem, length);
	public static List<TResult> Fill<TResult>(Func<int, TResult> function, int length) => List<bool>.FillEnumerable(function, length);
	public static List<TResult> Fill<TResult>(int length, Func<int, TResult> function) => List<bool>.FillEnumerable(function, length);
	public static TResult[] FillArray<TResult>(TResult elem, int length) => List<bool>.FillArrayEnumerable(elem, length);
	public static TResult[] FillArray<TResult>(Func<int, TResult> function, int length) => List<bool>.FillArrayEnumerable(function, length);
	public static TResult[] FillArray<TResult>(int length, Func<int, TResult> function) => List<bool>.FillArrayEnumerable(function, length);
	public static IEnumerable<T> Filter<T>(this IEnumerable<T> source, Func<T, bool> function) => Enumerable.Where(source, function);
	public static IEnumerable<T> Filter<T>(this IEnumerable<T> source, Func<T, int, bool> function) => Enumerable.Where(source, function);
	public static T? Find<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindEnumerable(source, function);
	public static T? Find<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindEnumerable(source, function);
	public static List<T> FindAll<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAll<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMinEnumerable(source, function);
	public static NList<int> FindIndexes<T>(this IEnumerable<T> source, Func<T, bool> function) => NList<bool>.FindIndexesEnumerable(source, function);
	public static NList<int> FindIndexes<T>(this IEnumerable<T> source, Func<T, int, bool> function) => NList<bool>.FindIndexesEnumerable(source, function);
	public static int FindIndex<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindIndexEnumerable(source, function);
	public static int FindIndex<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindIndexEnumerable(source, function);
	public static T? FindLast<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static T? FindLast<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static int FindLastIndex<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindLastIndexEnumerable(source, function);
	public static int FindLastIndex<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindLastIndexEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMinEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.FindMinEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, double> function, out double indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, double> function, out double indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int> function, out int indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, int> function, out int indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, uint> function, out uint indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, long> function, out long indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, long> function, out long indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static T First<T>(this IEnumerable<T> source) => Enumerable.First(source);
	public static T? FirstOrDefault<T>(this IEnumerable<T> source) => Enumerable.FirstOrDefault(source);
	public static void ForEach<T>(this IEnumerable<T> source, Action<T> action) => List<T>.ForEachEnumerable(source, action);
	public static void ForEach<T>(this IEnumerable<T> source, Action<T, int> action) => List<T>.ForEachEnumerable(source, action);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source) where T : notnull => List<T>.FrequencyTableEnumerable(source);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, comparer);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, comparer);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.FrequencyTableEnumerable(source, comparer);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction, hashCodeFunction);
	public static Slice<T> GetSlice<T>(this G.IList<T> source) => new(source);
	public static Slice<T> GetSlice<T>(this G.IList<T> source, Index index) => new(source, index);
	public static Slice<T> GetSlice<T>(this G.IList<T> source, int index) => new(source, index);
	public static Slice<T> GetSlice<T>(this G.IList<T> source, int index, int length) => new(source, index, length);
	public static Slice<T> GetSlice<T>(this G.IList<T> source, Range range) => new(source, range);
	public static Slice<T> GetROLSlice<T>(this G.IReadOnlyList<T> source) => new(source);
	public static Slice<T> GetROLSlice<T>(this G.IReadOnlyList<T> source, Index index) => new(source, index);
	public static Slice<T> GetROLSlice<T>(this G.IReadOnlyList<T> source, int index) => new(source, index);
	public static Slice<T> GetROLSlice<T>(this G.IReadOnlyList<T> source, int index, int length) => new(source, index, length);
	public static Slice<T> GetROLSlice<T>(this G.IReadOnlyList<T> source, Range range) => new(source, range);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	[Obsolete("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в последовательности, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.", true)]
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source) where T : notnull => throw new NotSupportedException("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в последовательности, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.");
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable(source, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector) => Enumerable.GroupBy(source, keySelector, elementSelector);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector) => List<T>.Group(source, keySelector, elementSelector);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, elementSelector, comparer);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, IEqualityComparer<TKey> comparer) => List<T>.Group(source, keySelector, elementSelector, comparer);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction) => List<T>.Group(source, keySelector, elementSelector, equalFunction);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<T>.Group(source, keySelector, elementSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector) => Enumerable.GroupBy(source, keySelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector) => List<T>.Group(source, keySelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<T>.Group(source, keySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<T>.Group(source, keySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<T>.Group(source, keySelector, resultSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector) => List<T>.Group(source, keySelector, elementSelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<T>.Group(source, keySelector, elementSelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<T>.Group(source, keySelector, elementSelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<T>.Group(source, keySelector, elementSelector, resultSelector, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source) where T : notnull => List<T>.GroupIndexesEnumerable(source);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable(source, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static NList<int> IndexesOf<T>(this IEnumerable<T> source, T target) => NList<bool>.IndexesOfEnumerable(source, target);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, double> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, long> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax(this IEnumerable<decimal> source) => NList<bool>.IndexesOfMaxEnumerable<decimal>(source);
	public static NList<int> IndexesOfMax(this IEnumerable<double> source) => NList<bool>.IndexesOfMaxEnumerable<double>(source);
	public static NList<int> IndexesOfMax(this IEnumerable<int> source) => NList<bool>.IndexesOfMaxEnumerable<int>(source);
	public static NList<int> IndexesOfMax(this IEnumerable<uint> source) => NList<bool>.IndexesOfMaxEnumerable<int>(source);
	public static NList<int> IndexesOfMax(this IEnumerable<long> source) => NList<bool>.IndexesOfMaxEnumerable<long>(source);
	public static NList<int> IndexesOfMax(this IEnumerable<MpzT> source) => NList<bool>.IndexesOfMaxEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, double> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, long> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean(this IEnumerable<decimal> source) => NList<bool>.IndexesOfMeanEnumerable<decimal>(source);
	public static NList<int> IndexesOfMean(this IEnumerable<double> source) => NList<bool>.IndexesOfMeanEnumerable<double>(source);
	public static NList<int> IndexesOfMean(this IEnumerable<int> source) => NList<bool>.IndexesOfMeanEnumerable<int>(source);
	public static NList<int> IndexesOfMean(this IEnumerable<uint> source) => NList<bool>.IndexesOfMeanEnumerable<int>(source);
	public static NList<int> IndexesOfMean(this IEnumerable<long> source) => NList<bool>.IndexesOfMeanEnumerable<long>(source);
	public static NList<int> IndexesOfMean(this IEnumerable<MpzT> source) => NList<bool>.IndexesOfMeanEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, double> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, long> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian(this IEnumerable<decimal> source) => NList<bool>.IndexesOfMedianEnumerable<decimal>(source);
	public static NList<int> IndexesOfMedian(this IEnumerable<double> source) => NList<bool>.IndexesOfMedianEnumerable<double>(source);
	public static NList<int> IndexesOfMedian(this IEnumerable<int> source) => NList<bool>.IndexesOfMedianEnumerable<int>(source);
	public static NList<int> IndexesOfMedian(this IEnumerable<uint> source) => NList<bool>.IndexesOfMedianEnumerable<int>(source);
	public static NList<int> IndexesOfMedian(this IEnumerable<long> source) => NList<bool>.IndexesOfMedianEnumerable<long>(source);
	public static NList<int> IndexesOfMedian(this IEnumerable<MpzT> source) => NList<bool>.IndexesOfMedianEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, double> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, long> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin(this IEnumerable<decimal> source) => NList<bool>.IndexesOfMinEnumerable<decimal>(source);
	public static NList<int> IndexesOfMin(this IEnumerable<double> source) => NList<bool>.IndexesOfMinEnumerable<double>(source);
	public static NList<int> IndexesOfMin(this IEnumerable<int> source) => NList<bool>.IndexesOfMinEnumerable<int>(source);
	public static NList<int> IndexesOfMin(this IEnumerable<uint> source) => NList<bool>.IndexesOfMinEnumerable<int>(source);
	public static NList<int> IndexesOfMin(this IEnumerable<long> source) => NList<bool>.IndexesOfMinEnumerable<long>(source);
	public static NList<int> IndexesOfMin(this IEnumerable<MpzT> source) => NList<bool>.IndexesOfMinEnumerable<MpzT>(source);
	public static int IndexOf<T>(this IEnumerable<T> source, T target) => List<T>.IndexOfEnumerable(source, target);
	public static int IndexOf<T>(this IEnumerable<T> source, T target, IEqualityComparer<T> comparer) => List<T>.IndexOfEnumerable(source, target, comparer);
	public static int IndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.IndexOfEnumerable(source, target, equalFunction);
	public static int IndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.IndexOfEnumerable(source, target, equalFunction, hashCodeFunction);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax(this IEnumerable<decimal> source) => List<decimal>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<double> source) => List<double>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<int> source) => List<int>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<uint> source) => List<int>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<long> source) => List<long>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<MpzT> source) => List<MpzT>.IndexOfMaxEnumerable(source);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean(this IEnumerable<decimal> source) => List<decimal>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<double> source) => List<double>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<int> source) => List<int>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<uint> source) => List<int>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<long> source) => List<long>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<MpzT> source) => List<MpzT>.IndexOfMeanEnumerable(source);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian(this IEnumerable<decimal> source) => List<decimal>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<double> source) => List<double>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<int> source) => List<int>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<uint> source) => List<int>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<long> source) => List<long>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<MpzT> source) => List<MpzT>.IndexOfMedianEnumerable(source);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin(this IEnumerable<decimal> source) => List<decimal>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<double> source) => List<double>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<int> source) => List<int>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<uint> source) => List<int>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<long> source) => List<long>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<MpzT> source) => List<MpzT>.IndexOfMinEnumerable(source);
	public static IEnumerable<T> Intersect<T>(this IEnumerable<T> source, IEnumerable<T> source2) => Enumerable.Intersect(source, source2);
	public static IEnumerable<T> Intersect<T>(this IEnumerable<T> source, IEnumerable<T> source2, IEqualityComparer<T> comparer) => Enumerable.Intersect(source, source2, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<List<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T[]> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<G.IList<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<IEnumerable<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<TResult> JoinIntoSingle<T, TResult>(this IEnumerable<T> source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<List<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T[]> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<G.IList<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<IEnumerable<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this IEnumerable<T> source, TResult separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<List<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T[]> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<G.IList<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<IEnumerable<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this IEnumerable<T> source, IEnumerable<TResult> separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static T Last<T>(this IEnumerable<T> source) => Enumerable.Last(source);
	public static T? LastOrDefault<T>(this IEnumerable<T> source) => Enumerable.LastOrDefault(source);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target) => List<T>.LastIndexOfEnumerable(source, target);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target, IEqualityComparer<T> comparer) => List<T>.LastIndexOfEnumerable(source, target, comparer);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.LastIndexOfEnumerable(source, target, equalFunction);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.LastIndexOfEnumerable(source, target, equalFunction, hashCodeFunction);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<double> source) => List<double>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<int> source) => List<int>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<uint> source) => List<int>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<long> source) => List<long>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<MpzT> source) => List<MpzT>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<double> source) => List<double>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<int> source) => List<int>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<uint> source) => List<int>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<long> source) => List<long>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<MpzT> source) => List<MpzT>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<double> source) => List<double>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<int> source) => List<int>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<uint> source) => List<int>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<long> source) => List<long>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<MpzT> source) => List<MpzT>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<double> source) => List<double>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<int> source) => List<int>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<uint> source) => List<int>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<long> source) => List<long>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<MpzT> source) => List<MpzT>.LastIndexOfMinEnumerable(source);
	public static int Length<T>(this IEnumerable<T> source) => List<T>.LengthEnumerable(source);
	public static decimal Max<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MaxEnumerable(source, function);
	public static MpzT Max<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.MaxEnumerable(source, function);
	public static MpzT Max<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max(this IEnumerable<decimal> source) => NList<bool>.MaxEnumerable(source);
	public static double Max(this IEnumerable<double> source) => NList<bool>.MaxEnumerable(source);
	public static int Max(this IEnumerable<int> source) => NList<bool>.MaxEnumerable(source);
	public static uint Max(this IEnumerable<uint> source) => NList<bool>.MaxEnumerable(source);
	public static long Max(this IEnumerable<long> source) => NList<bool>.MaxEnumerable(source);
	public static MpzT Max(this IEnumerable<MpzT> source) => NList<bool>.MaxEnumerable(source);
	public static TResult? Max<T, TResult>(this IEnumerable<T> source, Func<T, TResult> selector) => Enumerable.Max(source, selector);
	public static TResult? Max<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> selector) => List<T>.Max(source, selector);
	public static T? Max<T>(this IEnumerable<T> source) => Enumerable.Max(source);
	public static decimal Max(params decimal[] source) => List<decimal>.MaxEnumerable(source.AsSpan());
	public static double Max(params double[] source) => List<double>.MaxEnumerable(source.AsSpan());
	public static int Max(params int[] source) => List<int>.MaxEnumerable(source.AsSpan());
	public static uint Max(params uint[] source) => List<uint>.MaxEnumerable(source.AsSpan());
	public static long Max(params long[] source) => List<long>.MaxEnumerable(source.AsSpan());
	public static MpzT Max(params MpzT[] source) => List<MpzT>.MaxEnumerable(source.AsSpan());
	public static T? Max<T>(params T?[] source) => Enumerable.Max(source);
	public static decimal Mean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean(this IEnumerable<decimal> source) => NList<bool>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<double> source) => NList<bool>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<int> source) => NList<bool>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<uint> source) => NList<bool>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<long> source) => NList<bool>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<MpzT> source) => NList<bool>.MeanEnumerable(source);
	public static decimal Mean(params decimal[] source) => List<bool>.MeanEnumerable(source);
	public static double Mean(params double[] source) => List<bool>.MeanEnumerable(source);
	public static double Mean(params int[] source) => List<bool>.MeanEnumerable(source);
	public static double Mean(params uint[] source) => List<bool>.MeanEnumerable(source);
	public static double Mean(params long[] source) => List<bool>.MeanEnumerable(source);
	public static double Mean(params MpzT[] source) => List<bool>.MeanEnumerable(source);
	public static decimal Median<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MedianEnumerable(source, function);
	public static MpzT Median<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.MedianEnumerable(source, function);
	public static MpzT Median<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median(this IEnumerable<decimal> source) => List<decimal>.MedianEnumerable(source);
	public static double Median(this IEnumerable<double> source) => List<double>.MedianEnumerable(source);
	public static int Median(this IEnumerable<int> source) => List<int>.MedianEnumerable(source);
	public static uint Median(this IEnumerable<uint> source) => List<int>.MedianEnumerable(source);
	public static long Median(this IEnumerable<long> source) => List<long>.MedianEnumerable(source);
	public static MpzT Median(this IEnumerable<MpzT> source) => List<MpzT>.MedianEnumerable(source);
	public static TResult? Median<T, TResult>(this IEnumerable<T> source, Func<T, TResult> selector) => List<T>.MedianEnumerable(source, selector);
	public static TResult? Median<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> selector) => List<T>.MedianEnumerable(source, selector);
	public static T? Median<T>(this IEnumerable<T> source) => List<T>.MedianEnumerable(source);
	public static decimal Median(params decimal[] source) => List<decimal>.MedianEnumerable(source.AsSpan());
	public static double Median(params double[] source) => List<double>.MedianEnumerable(source.AsSpan());
	public static int Median(params int[] source) => List<int>.MedianEnumerable(source.AsSpan());
	public static uint Median(params uint[] source) => List<uint>.MedianEnumerable(source.AsSpan());
	public static long Median(params long[] source) => List<long>.MedianEnumerable(source.AsSpan());
	public static MpzT Median(params MpzT[] source) => List<MpzT>.MedianEnumerable(source.AsSpan());
	public static T? Median<T>(params T[] source) => List<T>.MedianEnumerable((G.IList<T>)source);
	public static decimal Min<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MinEnumerable(source, function);
	public static MpzT Min<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.MinEnumerable(source, function);
	public static MpzT Min<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min(this IEnumerable<decimal> source) => NList<bool>.MinEnumerable(source);
	public static double Min(this IEnumerable<double> source) => NList<bool>.MinEnumerable(source);
	public static int Min(this IEnumerable<int> source) => NList<bool>.MinEnumerable(source);
	public static uint Min(this IEnumerable<uint> source) => NList<bool>.MinEnumerable(source);
	public static long Min(this IEnumerable<long> source) => NList<bool>.MinEnumerable(source);
	public static MpzT Min(this IEnumerable<MpzT> source) => NList<bool>.MinEnumerable(source);
	public static TResult? Min<T, TResult>(this IEnumerable<T> source, Func<T, TResult> selector) => Enumerable.Min(source, selector);
	public static TResult? Min<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> selector) => List<T>.Min(source, selector);
	public static T? Min<T>(this IEnumerable<T> source) => Enumerable.Min(source);
	public static decimal Min(params decimal[] source) => List<decimal>.MinEnumerable(source.AsSpan());
	public static double Min(params double[] source) => List<double>.MinEnumerable(source.AsSpan());
	public static int Min(params int[] source) => List<int>.MinEnumerable(source.AsSpan());
	public static uint Min(params uint[] source) => List<uint>.MinEnumerable(source.AsSpan());
	public static long Min(params long[] source) => List<long>.MinEnumerable(source.AsSpan());
	public static MpzT Min(params MpzT[] source) => List<MpzT>.MinEnumerable(source.AsSpan());
	public static T? Min<T>(params T?[] source) => Enumerable.Min(source);
	public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source) => Enumerable.OfType<TResult>(source);
	public static Slice<TResult> Pairs<T, TResult>(this IReadOnlyList<T> source, Func<T, T, TResult> function, int offset = 1) => List<T>.PairsEnumerable(source, function, offset);
	public static IEnumerable<TResult> Pairs<T, TResult>(this IEnumerable<T> source, Func<T, T, TResult> function, int offset = 1) => List<T>.PairsEnumerable(source, function, offset);
	public static Slice<TResult> Pairs<T, TResult>(this IReadOnlyList<T> source, Func<T, T, int, TResult> function, int offset = 1) => List<T>.PairsEnumerable(source, function, offset);
	public static IEnumerable<TResult> Pairs<T, TResult>(this IEnumerable<T> source, Func<T, T, int, TResult> function, int offset = 1) => List<T>.PairsEnumerable(source, function, offset);
	public static Slice<(T, T)> Pairs<T>(this IReadOnlyList<T> source, int offset = 1) => List<T>.PairsEnumerable(source, offset);
	public static IEnumerable<(T, T)> Pairs<T>(this IEnumerable<T> source, int offset = 1) => List<T>.PairsEnumerable(source, offset);
	public static Slice<T> Prepend<T>(this G.IReadOnlyList<T> source, T element) => List<T>.PrependEnumerable(source, element);
	public static IEnumerable<T> Prepend<T>(this IEnumerable<T> source, T element) => Enumerable.Prepend(source, element);
	public static decimal Product<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.ProductEnumerable(source, function);
	public static decimal Product<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.ProductEnumerable(source, function);
	public static double Product<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.ProductEnumerable(source, function);
	public static double Product<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.ProductEnumerable(source, function);
	public static int Product<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.ProductEnumerable(source, function);
	public static int Product<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.ProductEnumerable(source, function);
	public static uint Product<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.ProductEnumerable(source, function);
	public static uint Product<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.ProductEnumerable(source, function);
	public static long Product<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.ProductEnumerable(source, function);
	public static long Product<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.ProductEnumerable(source, function);
	public static MpzT Product<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.ProductEnumerable(source, function);
	public static MpzT Product<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.ProductEnumerable(source, function);
	public static decimal Product(this IEnumerable<decimal> source) => NList<decimal>.ProductEnumerable(source);
	public static double Product(this IEnumerable<double> source) => NList<double>.ProductEnumerable(source);
	public static int Product(this IEnumerable<int> source) => NList<int>.ProductEnumerable(source);
	public static uint Product(this IEnumerable<uint> source) => NList<int>.ProductEnumerable(source);
	public static long Product(this IEnumerable<long> source) => NList<long>.ProductEnumerable(source);
	public static MpzT Product(this IEnumerable<MpzT> source) => NList<MpzT>.ProductEnumerable(source);
	public static T? Progression<T>(this IEnumerable<T> source, Func<T, T, T> function) => List<T>.ProgressionEnumerable(source, function);
	public static TResult? Progression<T, TResult>(this IEnumerable<T> source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable(source, seed, function);
	public static T Random<T>(this G.IReadOnlyList<T> source) => source[random.Next(source.Count)];
	public static T Random<T>(this G.IReadOnlyList<T> source, Random randomObj) => source[randomObj.Next(source.Count)];
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source) => List<T>.RemoveDoublesEnumerable(source);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, comparer);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, comparer);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) => List<T>.RemoveDoublesEnumerable(source, comparer);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source, source2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source, source2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.RemoveDoublesEnumerable(source, source2);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, IEqualityComparer<T> comparer) => List<T>.RemoveDoublesEnumerable(source, source2, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, source2, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, source2, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, IEqualityComparer<T> comparer) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction, hashCodeFunction);
	public static NList<int> RepresentIntoNumbers<T>(this IEnumerable<T> source) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source);
	public static NList<int> RepresentIntoNumbers<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, comparer);
	public static NList<int> RepresentIntoNumbers<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static NList<int> RepresentIntoNumbers<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static List<T> Reverse<T>(this IEnumerable<T> source) => List<T>.ReverseEnumerable(source);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value) => List<T>.SetAllEnumerable(source, value);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, Index index) => List<T>.SetAllEnumerable(source, value, index);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, int index) => List<T>.SetAllEnumerable(source, value, index);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, int index, int length) => List<T>.SetAllEnumerable(source, value, index, length);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, Range range) => List<T>.SetAllEnumerable(source, value, range);
	public static T[] SetAll<T>(this T[] source, T value) => List<T>.SetAllEnumerable((G.IList<T>)source, value) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, Index index) => List<T>.SetAllEnumerable(source, value, index) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, int index) => List<T>.SetAllEnumerable(source, value, index) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, int index, int length) => List<T>.SetAllEnumerable(source, value, index, length) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, Range range) => List<T>.SetAllEnumerable(source, value, range) as T[] ?? throw new InvalidOperationException();
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source) => List<bool>.SetInnerTypeEnumerable<TResult>(source);
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source, Func<object?, TResult> function) => List<bool>.SetInnerTypeEnumerable(source, function);
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source, Func<object?, int, TResult> function) => List<bool>.SetInnerTypeEnumerable(source, function);
	public static List<TResult> Shuffle<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.ShuffleEnumerable(source, function, random);
	public static List<TResult> Shuffle<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Random random) => List<T>.ShuffleEnumerable(source, function, random);
	public static List<TResult> Shuffle<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.ShuffleEnumerable(source, function, random);
	public static List<TResult> Shuffle<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Random random) => List<T>.ShuffleEnumerable(source, function, random);
	public static List<T> Shuffle<T>(this IEnumerable<T> source) => List<T>.ShuffleEnumerable(source, random);
	public static List<T> Shuffle<T>(this IEnumerable<T> source, Random random) => List<T>.ShuffleEnumerable(source, random);
	public static Slice<T> Skip<T>(this IEnumerable<T> source, int length) => List<T>.SkipEnumerable(source, length);
	public static Slice<T> SkipLast<T>(this IEnumerable<T> source, int length) => List<T>.SkipLastEnumerable(source, length);
	public static Slice<T> SkipWhile<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.SkipWhileEnumerable(source, function);
	public static Slice<T> SkipWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.SkipWhileEnumerable(source, function);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => Enumerable.OrderBy(source, function);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.Sort(source, function);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IComparer<TResult> comparer) => Enumerable.OrderBy(source, function, comparer);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer) => List<T>.Sort(source, function, comparer);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, int> compareFunction) => Enumerable.OrderBy(source, function, new Comparer<TResult>(compareFunction));
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction) => List<T>.Sort(source, function, compareFunction);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => Enumerable.OrderByDescending(source, function);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.SortDesc(source, function);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IComparer<TResult> comparer) => Enumerable.OrderByDescending(source, function, comparer);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer) => List<T>.SortDesc(source, function, comparer);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, int> compareFunction) => Enumerable.OrderByDescending(source, function, new Comparer<TResult>(compareFunction));
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction) => List<T>.SortDesc(source, function, compareFunction);
	public static List<List<T>> SplitIntoEqual<T>(this IEnumerable<T> source, int fragmentLength) => List<T>.SplitIntoEqualEnumerable(source, fragmentLength);
	public static bool StartsWith<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.StartsWithEnumerable(source, source2);
	public static decimal Sum<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.SumEnumerable(source, function);
	public static MpzT Sum<T>(this IEnumerable<T> source, Func<T, MpzT> function) => List<T>.SumEnumerable(source, function);
	public static MpzT Sum<T>(this IEnumerable<T> source, Func<T, int, MpzT> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum(this IEnumerable<decimal> source) => NList<decimal>.SumEnumerable(source);
	public static double Sum(this IEnumerable<double> source) => NList<double>.SumEnumerable(source);
	public static int Sum(this IEnumerable<int> source) => NList<int>.SumEnumerable(source);
	public static uint Sum(this IEnumerable<uint> source) => NList<int>.SumEnumerable(source);
	public static long Sum(this IEnumerable<long> source) => NList<long>.SumEnumerable(source);
	public static MpzT Sum(this IEnumerable<MpzT> source) => NList<MpzT>.SumEnumerable(source);
	public static Slice<T> Take<T>(this IEnumerable<T> source, int length) => List<T>.TakeEnumerable(source, length);
	public static Slice<T> Take<T>(this IEnumerable<T> source, Range range) => List<T>.TakeEnumerable(source, range);
	public static Slice<T> TakeLast<T>(this IEnumerable<T> source, int length) => List<T>.TakeLastEnumerable(source, length);
	public static Slice<T> TakeWhile<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.TakeWhileEnumerable(source, function);
	public static Slice<T> TakeWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.TakeWhileEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static T[] ToArray<T>(this IEnumerable<T> source) => List<T>.ToArrayEnumerable(source);
	public static BitList ToBitList(this IEnumerable<bool> source) => new(source);
	public static BitList ToBitList(this IEnumerable<byte> source) => new(source);
	public static BitList ToBitList(this IEnumerable<int> source) => new(source);
	public static BitList ToBitList(this IEnumerable<uint> source) => new(source);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, IEqualityComparer<TKey> comparer, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), comparer, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, IEqualityComparer<TKey> comparer, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), comparer, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, Func<TKey, TKey, bool> equalFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), equalFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, Func<TKey, TKey, bool> equalFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), equalFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), equalFunction, hashCodeFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), List<T>.ToListEnumerable(source, function2), equalFunction, hashCodeFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, IEqualityComparer<TKey> comparer, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), comparer, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, IEqualityComparer<TKey> comparer, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), comparer, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, hashCodeFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, hashCodeFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, IEqualityComparer<TKey> comparer, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), comparer, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, IEqualityComparer<TKey> comparer, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), comparer, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, hashCodeFunction, unordered);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction, bool unordered = false) where TKey : notnull => new(List<T>.ToListEnumerable(source, function), equalFunction, hashCodeFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, bool unordered = false) where T : notnull => new(source, source2, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, IEqualityComparer<T> comparer, bool unordered = false) where T : notnull => new(source, source2, comparer, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, bool unordered = false) where T : notnull => new(source, source2, equalFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction, bool unordered = false) where T : notnull => new(source, source2, equalFunction, hashCodeFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, bool unordered = false) where T : notnull => new(source.Item1, source.Item2, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, IEqualityComparer<T> comparer, bool unordered = false) where T : notnull => new(source.Item1, source.Item2, comparer, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction, bool unordered = false) where T : notnull => new(source.Item1, source.Item2, equalFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction, bool unordered = false) where T : notnull => new(source.Item1, source.Item2, equalFunction, hashCodeFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, bool unordered = false) where T : notnull => new(source, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, IEqualityComparer<T> comparer, bool unordered = false) where T : notnull => new(source, comparer, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, Func<T, T, bool> equalFunction, bool unordered = false) where T : notnull => new(source, equalFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction, bool unordered = false) where T : notnull => new(source, equalFunction, hashCodeFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, bool unordered = false) where T : notnull => new(source, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, IEqualityComparer<T> comparer, bool unordered = false) where T : notnull => new(source, comparer, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, Func<T, T, bool> equalFunction, bool unordered = false) where T : notnull => new(source, equalFunction, unordered);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction, bool unordered = false) where T : notnull => new(source, equalFunction, hashCodeFunction, unordered);
	public static ListHashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new(source);
	public static List<TResult> ToList<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.ToListEnumerable(source, function);
	public static List<TResult> ToList<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.ToListEnumerable(source, function);
	public static List<T> ToList<T>(this IEnumerable<T> source) => List<T>.ReturnOrConstruct(source);
	public static NList<TResult> ToNList<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable(source, function);
	public static NList<TResult> ToNList<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable(source, function);
	public static NList<T> ToNList<T>(this IEnumerable<T> source) where T : unmanaged => NList<T>.ReturnOrConstruct(source);
	public static String ToNString<T>(this IEnumerable<T> source, Func<T, char> function) => NList<bool>.ToNStringEnumerable(source, function);
	public static String ToNString<T>(this IEnumerable<T> source, Func<T, int, char> function) => NList<bool>.ToNStringEnumerable(source, function);
	public static String ToNString(this IEnumerable<char> source) => new(source);
	public static ParallelHashSet<T> ToParallelHashSet<T>(this IEnumerable<T> source) => new(source);
	public static string ToString<T>(this IEnumerable<T> source, Func<T, char> function) => new(List<T>.ToArrayEnumerable(source, function));
	public static string ToString<T>(this IEnumerable<T> source, Func<T, int, char> function) => new(List<T>.ToArrayEnumerable(source, function));
	public static string ToString(this IEnumerable<char> source) => new(List<char>.ToArrayEnumerable(source));
	public static List<List<T>> Transpose<T>(this List<List<T>> source, bool widen = false) => List<T>.Transpose(source, widen);
	public static List<NList<T>> Transpose<T>(this List<NList<T>> source, bool widen = false) where T : unmanaged => NList<T>.Transpose(source, widen);
	public static bool TryGetLengthEasily<T>(this IEnumerable<T> source, out int length) => List<T>.TryGetLengthEasilyEnumerable(source, out length);
	public static bool TryGetLengthEasily<T>(this IEnumerable source, out int length) => List<T>.TryGetLengthEasilyEnumerable(source, out length);
	public static IEnumerable<T> Union<T>(this IEnumerable<T> source, IEnumerable<T> source2) => Enumerable.Union(source, source2);
	public static IEnumerable<T> Union<T>(this IEnumerable<T> source, IEnumerable<T> source2, IEqualityComparer<T> comparer) => Enumerable.Union(source, source2, comparer);
	public static bool All<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool All<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool All<T>(this Span<T> source, Func<T, bool> function) => List<T>.AllEnumerable((ReadOnlySpan<T>)source, function);
	public static bool All<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.AllEnumerable((ReadOnlySpan<T>)source, function);
	public static bool All<T>(this T[] source, Func<T, bool> function) => Enumerable.All(source, function);
	public static bool All<T>(this T[] source, Func<T, int, bool> function) => List<T>.AllEnumerable((G.IList<T>)source, function);
	public static bool Any<T>(this ReadOnlySpan<T> source) => List<T>.AnyEnumerable(source);
	public static bool Any<T>(this Span<T> source) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source);
	public static bool Any<T>(this T[] source) => source.Length != 0;
	public static bool Any<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.AnyEnumerable(source, function);
	public static bool Any<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.AnyEnumerable(source, function);
	public static bool Any<T>(this Span<T> source, Func<T, bool> function) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source, function);
	public static bool Any<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source, function);
	public static bool Any<T>(this T[] source, Func<T, bool> function) => Enumerable.Any(source, function);
	public static bool Any<T>(this T[] source, Func<T, int, bool> function) => List<T>.AnyEnumerable((G.IList<T>)source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable((G.IList<T>)source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable((G.IList<T>)source, function, function2);
	public static (List<T>, List<T2>) Break<T, T2>(this ReadOnlySpan<(T, T2)> source) => List<T>.BreakEnumerable(source);
	public static (List<T>, List<T2>) Break<T, T2>(this Span<(T, T2)> source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source);
	public static (List<T>, List<T2>) Break<T, T2>(this (T, T2)[] source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source.AsSpan());
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable((G.IList<T>)source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable((G.IList<T>)source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable((G.IList<T>)source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable((G.IList<T>)source, function, function2, function3);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this ReadOnlySpan<(T, T2, T3)> source) => List<T>.BreakEnumerable(source);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this Span<(T, T2, T3)> source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this (T, T2, T3)[] source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source.AsSpan());
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((G.IList<T>)source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((G.IList<T>)source, function);
	public static List<T> BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static List<T> BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static List<T> BreakFilter<T>(this Span<T> source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out result2);
	public static List<T> BreakFilter<T>(this Span<T> source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out result2);
	public static List<T> BreakFilter<T>(this T[] source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((G.IList<T>)source, function, out result2);
	public static List<T> BreakFilter<T>(this T[] source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((G.IList<T>)source, function, out result2);
	public static (List<T>, List<T>) BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this Span<T> source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this Span<T> source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this T[] source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable((G.IList<T>)source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this T[] source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable((G.IList<T>)source, function, out var result2), result2);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static Slice<TResult> Combine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable((G.IReadOnlyList<T>)source, source2, function);
	public static Slice<TResult> Combine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable((G.IReadOnlyList<T>)source, source2, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<(T, T2)> Combine<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) => List<T>.CombineEnumerable(source, source2);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<(T, T2)> Combine<T, T2>(this Span<T> source, Span<T2> source2) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static Slice<(T, T2)> Combine<T, T2>(this T[] source, T2[] source2) => List<T>.CombineEnumerable(source, source2);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<TResult> Combine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static Slice<TResult> Combine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable((G.IReadOnlyList<T>)source, source2, source3, function);
	public static Slice<TResult> Combine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable((G.IReadOnlyList<T>)source, source2, source3, function);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3) => List<T>.CombineEnumerable(source, source2, source3);
	[Obsolete("Этот метод не рекомендуется, так как создает новый список, который потребляет очень много памяти (сравнимо с исходными Span<T>). Для устранения проблемы замените Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()).")]
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this Span<T> source, Span<T2> source2, Span<T3> source3) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3);
	public static Slice<(T, T2, T3)> Combine<T, T2, T3>(this T[] source, T2[] source2, T3[] source3) => List<T>.CombineEnumerable(source, source2, source3);
	[Obsolete("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().", true)]
	public static List<TResult> Convert<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => throw new NotSupportedException("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().");
	[Obsolete("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().", true)]
	public static List<TResult> Convert<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => throw new NotSupportedException("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().");
	[Obsolete("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().", true)]
	public static List<TResult> Convert<T, TResult>(this Span<T> source, Func<T, TResult> function) => throw new NotSupportedException("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().");
	[Obsolete("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().", true)]
	public static List<TResult> Convert<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => throw new NotSupportedException("Этот метод устарел. Мы рекомендуем заменить Span<T> на Slice<T> (создается методами GetSlice() и GetROLSlice()), но в крайнем случае вы можете использовать прямой аналог - ToList().");
	public static Slice<TResult> Convert<T, TResult>(this T[] source, Func<T, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static Slice<TResult> Convert<T, TResult>(this T[] source, Func<T, int, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this ReadOnlySpan<T> source, Func<T, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this Span<T> source, Func<T, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this Span<T> source, Func<T, int, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable((ReadOnlySpan<T>)source, function);
	public static IEnumerable<TResult> ConvertAndJoin<T, TResult>(this T[] source, Func<T, IEnumerable<TResult>> function) => Enumerable.SelectMany(source, function);
	public static IEnumerable<TResult> ConvertAndJoin<T, TResult>(this T[] source, Func<T, int, IEnumerable<TResult>> function) => Enumerable.SelectMany(source, function);
	public static int Count<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this Span<T> source, Func<T, bool> function) => List<T>.CountEnumerable((ReadOnlySpan<T>)source, function);
	public static int Count<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.CountEnumerable((ReadOnlySpan<T>)source, function);
	public static int Count<T>(this T[] source, Func<T, bool> function) => List<T>.CountEnumerable((G.IList<T>)source, function);
	public static int Count<T>(this T[] source, Func<T, int, bool> function) => List<T>.CountEnumerable((G.IList<T>)source, function);
	public static bool Equals<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool Equals<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool Equals<T, T2>(this T[] source, T2[] source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable((G.IList<T>)source, source2, function);
	public static bool Equals<T, T2>(this T[] source, T2[] source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable((G.IList<T>)source, source2, function);
	public static bool Equals<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) => List<T>.EqualsEnumerable(source, source2);
	public static bool Equals<T, T2>(this Span<T> source, Span<T2> source2) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static bool Equals<T, T2>(this T[] source, T2[] source2) => List<T>.EqualsEnumerable(source, source2);
	public static List<T> Filter<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FilterEnumerable(source, function);
	public static List<T> Filter<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FilterEnumerable(source, function);
	public static List<T> Filter<T>(this Span<T> source, Func<T, bool> function) => List<T>.FilterEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> Filter<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FilterEnumerable((ReadOnlySpan<T>)source, function);
	public static IEnumerable<T> Filter<T>(this T[] source, Func<T, bool> function) => Enumerable.Where(source, function);
	public static IEnumerable<T> Filter<T>(this T[] source, Func<T, int, bool> function) => Enumerable.Where(source, function);
	public static T? Find<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FindEnumerable(source, function);
	public static T? Find<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FindEnumerable(source, function);
	public static T? Find<T>(this Span<T> source, Func<T, bool> function) => List<T>.FindEnumerable((ReadOnlySpan<T>)source, function);
	public static T? Find<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FindEnumerable((ReadOnlySpan<T>)source, function);
	public static T? Find<T>(this T[] source, Func<T, bool> function) => List<T>.FindEnumerable((G.IList<T>)source, function);
	public static T? Find<T>(this T[] source, Func<T, int, bool> function) => List<T>.FindEnumerable((G.IList<T>)source, function);
	public static List<T> FindAll<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAll<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAll<T>(this Span<T> source, Func<T, bool> function) => List<T>.FindAllEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAll<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FindAllEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAll<T>(this T[] source, Func<T, bool> function) => List<T>.FindAllEnumerable((G.IList<T>)source, function);
	public static List<T> FindAll<T>(this T[] source, Func<T, int, bool> function) => List<T>.FindAllEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindAllMaxEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindAllMeanEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindAllMedianEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindAllMinEnumerable((G.IList<T>)source, function);
	public static T? FindLast<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static T? FindLast<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static T? FindLast<T>(this Span<T> source, Func<T, bool> function) => List<T>.FindLastEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLast<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FindLastEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLast<T>(this T[] source, Func<T, bool> function) => List<T>.FindLastEnumerable((G.IList<T>)source, function);
	public static T? FindLast<T>(this T[] source, Func<T, int, bool> function) => List<T>.FindLastEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindLastMaxEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindLastMeanEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindLastMedianEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindLastMinEnumerable((G.IList<T>)source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMaxIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMeanIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMedianIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindLastMinIndexEnumerable(source, function, out indicator);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, double> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, uint> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, long> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindMaxEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, double> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, uint> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, long> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindMeanEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, double> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, uint> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, long> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindMedianEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, double> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, uint> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, long> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, MpzT> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.FindMinEnumerable((G.IList<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, double> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, double> function, out double indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int> function, out int indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, long> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, long> function, out long indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMaxIndexesEnumerable(source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMaxIndexes<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMaxIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, double> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, double> function, out double indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int> function, out int indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, long> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, long> function, out long indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMeanIndexesEnumerable(source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMeanIndexes<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMeanIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, double> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, double> function, out double indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int> function, out int indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, long> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, long> function, out long indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMedianIndexesEnumerable(source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMedianIndexes<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMedianIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, double> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, double> function, out double indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int, double> function, out double indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int> function, out int indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int, int> function, out int indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, uint> function, out uint indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, long> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, long> function, out long indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int, long> function, out long indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMinIndexesEnumerable(source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static NList<int> FindMinIndexes<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => NList<bool>.FindMinIndexesEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMaxIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMeanIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMedianIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, decimal> function, out decimal indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, decimal> function, out decimal indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, double> function, out double indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, double> function, out double indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int> function, out int indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, int> function, out int indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, uint> function, out uint indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, uint> function, out uint indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, long> function, out long indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, long> function, out long indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, MpzT> function, out MpzT indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, MpzT> function, out MpzT indicator) => List<T>.FindMinIndexEnumerable(source, function, out indicator);
	public static void ForEach<T>(this ReadOnlySpan<T> source, Action<T> action) => List<T>.ForEachEnumerable(source, action);
	public static void ForEach<T>(this ReadOnlySpan<T> source, Action<T, int> action) => List<T>.ForEachEnumerable(source, action);
	public static void ForEach<T>(this Span<T> source, Action<T> action) => List<T>.ForEachEnumerable((ReadOnlySpan<T>)source, action);
	public static void ForEach<T>(this Span<T> source, Action<T, int> action) => List<T>.ForEachEnumerable((ReadOnlySpan<T>)source, action);
	public static void ForEach<T>(this T[] source, Action<T> action) => List<T>.ForEachEnumerable((G.IList<T>)source, action);
	public static void ForEach<T>(this T[] source, Action<T, int> action) => List<T>.ForEachEnumerable((G.IList<T>)source, action);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, function);
	public static List<(T Key, int Count)> FrequencyTable<T>(this ReadOnlySpan<T> source) where T : notnull => List<T>.FrequencyTableEnumerable(source);
	public static List<(T Key, int Count)> FrequencyTable<T>(this Span<T> source) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source);
	public static List<(T Key, int Count)> FrequencyTable<T>(this T[] source) where T : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable((G.IList<T>)source, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function);
	[Obsolete("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в ReadOnlySpan, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.", true)]
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source) where T : notnull => throw new NotSupportedException("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в ReadOnlySpan, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.");
	[Obsolete("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в Span, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.", true)]
	public static List<Group<T, T>> Group<T>(this Span<T> source) where T : notnull => throw new NotSupportedException("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в Span, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.");
	[Obsolete("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в массиве, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.", true)]
	public static List<Group<T, T>> Group<T>(this T[] source) where T : notnull => throw new NotSupportedException("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в массиве, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.");
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function, comparer);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable(source, comparer);
	public static List<Group<T, T>> Group<T>(this Span<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, comparer);
	public static List<Group<T, T>> Group<T>(this T[] source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable((G.IList<T>)source, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction);
	public static List<Group<T, T>> Group<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<Group<T, T>> Group<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable((G.IList<T>)source, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable((G.IList<T>)source, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source) where T : notnull => List<T>.GroupIndexesEnumerable(source);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source) where T : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable(source, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable((G.IList<T>)source, equalFunction, hashCodeFunction);
	public static NList<int> IndexesOf<T>(this ReadOnlySpan<T> source, T target) => NList<bool>.IndexesOfEnumerable(source, target);
	public static NList<int> IndexesOf<T>(this Span<T> source, T target) => NList<bool>.IndexesOfEnumerable((ReadOnlySpan<T>)source, target);
	public static NList<int> IndexesOf<T>(this T[] source, T target) => NList<bool>.IndexesOfEnumerable((G.IList<T>)source, target);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, decimal> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, double> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, double> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int, double> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int, int> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, uint> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int, uint> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, long> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, long> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int, long> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable(source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax<T>(this T[] source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMaxEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMax(this ReadOnlySpan<decimal> source) => NList<bool>.IndexesOfMaxEnumerable<decimal>(source);
	public static NList<int> IndexesOfMax(this Span<decimal> source) => NList<bool>.IndexesOfMaxEnumerable<decimal>((ReadOnlySpan<decimal>)source);
	public static NList<int> IndexesOfMax(this decimal[] source) => NList<bool>.IndexesOfMaxEnumerable<decimal>((ReadOnlySpan<decimal>)source.AsSpan());
	public static NList<int> IndexesOfMax(this ReadOnlySpan<double> source) => NList<bool>.IndexesOfMaxEnumerable<double>(source);
	public static NList<int> IndexesOfMax(this Span<double> source) => NList<bool>.IndexesOfMaxEnumerable<double>((ReadOnlySpan<double>)source);
	public static NList<int> IndexesOfMax(this double[] source) => NList<bool>.IndexesOfMaxEnumerable<double>((ReadOnlySpan<double>)source.AsSpan());
	public static NList<int> IndexesOfMax(this ReadOnlySpan<int> source) => NList<bool>.IndexesOfMaxEnumerable<int>(source);
	public static NList<int> IndexesOfMax(this Span<int> source) => NList<bool>.IndexesOfMaxEnumerable<int>((ReadOnlySpan<int>)source);
	public static NList<int> IndexesOfMax(this int[] source) => NList<bool>.IndexesOfMaxEnumerable<int>((ReadOnlySpan<int>)source.AsSpan());
	public static NList<int> IndexesOfMax(this ReadOnlySpan<uint> source) => NList<bool>.IndexesOfMaxEnumerable<uint>(source);
	public static NList<int> IndexesOfMax(this Span<uint> source) => NList<bool>.IndexesOfMaxEnumerable<uint>((ReadOnlySpan<uint>)source);
	public static NList<int> IndexesOfMax(this uint[] source) => NList<bool>.IndexesOfMaxEnumerable<uint>((ReadOnlySpan<uint>)source.AsSpan());
	public static NList<int> IndexesOfMax(this ReadOnlySpan<long> source) => NList<bool>.IndexesOfMaxEnumerable<long>(source);
	public static NList<int> IndexesOfMax(this Span<long> source) => NList<bool>.IndexesOfMaxEnumerable<long>((ReadOnlySpan<long>)source);
	public static NList<int> IndexesOfMax(this long[] source) => NList<bool>.IndexesOfMaxEnumerable<long>((ReadOnlySpan<long>)source.AsSpan());
	public static NList<int> IndexesOfMax(this ReadOnlySpan<MpzT> source) => NList<bool>.IndexesOfMaxEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMax(this Span<MpzT> source) => NList<bool>.IndexesOfMaxEnumerable<MpzT>((ReadOnlySpan<MpzT>)source);
	public static NList<int> IndexesOfMax(this MpzT[] source) => NList<bool>.IndexesOfMaxEnumerable<MpzT>((ReadOnlySpan<MpzT>)source.AsSpan());
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, decimal> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, double> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, double> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int, double> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int, int> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, uint> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int, uint> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, long> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, long> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int, long> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable(source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean<T>(this T[] source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMeanEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMean(this ReadOnlySpan<decimal> source) => NList<bool>.IndexesOfMeanEnumerable<decimal>(source);
	public static NList<int> IndexesOfMean(this Span<decimal> source) => NList<bool>.IndexesOfMeanEnumerable<decimal>((ReadOnlySpan<decimal>)source);
	public static NList<int> IndexesOfMean(this decimal[] source) => NList<bool>.IndexesOfMeanEnumerable<decimal>((ReadOnlySpan<decimal>)source.AsSpan());
	public static NList<int> IndexesOfMean(this ReadOnlySpan<double> source) => NList<bool>.IndexesOfMeanEnumerable<double>(source);
	public static NList<int> IndexesOfMean(this Span<double> source) => NList<bool>.IndexesOfMeanEnumerable<double>((ReadOnlySpan<double>)source);
	public static NList<int> IndexesOfMean(this double[] source) => NList<bool>.IndexesOfMeanEnumerable<double>((ReadOnlySpan<double>)source.AsSpan());
	public static NList<int> IndexesOfMean(this ReadOnlySpan<int> source) => NList<bool>.IndexesOfMeanEnumerable<int>(source);
	public static NList<int> IndexesOfMean(this Span<int> source) => NList<bool>.IndexesOfMeanEnumerable<int>((ReadOnlySpan<int>)source);
	public static NList<int> IndexesOfMean(this int[] source) => NList<bool>.IndexesOfMeanEnumerable<int>((ReadOnlySpan<int>)source.AsSpan());
	public static NList<int> IndexesOfMean(this ReadOnlySpan<uint> source) => NList<bool>.IndexesOfMeanEnumerable<uint>(source);
	public static NList<int> IndexesOfMean(this Span<uint> source) => NList<bool>.IndexesOfMeanEnumerable<uint>((ReadOnlySpan<uint>)source);
	public static NList<int> IndexesOfMean(this uint[] source) => NList<bool>.IndexesOfMeanEnumerable<uint>((ReadOnlySpan<uint>)source.AsSpan());
	public static NList<int> IndexesOfMean(this ReadOnlySpan<long> source) => NList<bool>.IndexesOfMeanEnumerable<long>(source);
	public static NList<int> IndexesOfMean(this Span<long> source) => NList<bool>.IndexesOfMeanEnumerable<long>((ReadOnlySpan<long>)source);
	public static NList<int> IndexesOfMean(this long[] source) => NList<bool>.IndexesOfMeanEnumerable<long>((ReadOnlySpan<long>)source.AsSpan());
	public static NList<int> IndexesOfMean(this ReadOnlySpan<MpzT> source) => NList<bool>.IndexesOfMeanEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMean(this Span<MpzT> source) => NList<bool>.IndexesOfMeanEnumerable<MpzT>((ReadOnlySpan<MpzT>)source);
	public static NList<int> IndexesOfMean(this MpzT[] source) => NList<bool>.IndexesOfMeanEnumerable<MpzT>((ReadOnlySpan<MpzT>)source.AsSpan());
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, decimal> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, double> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, double> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int, double> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int, int> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, uint> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int, uint> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, long> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, long> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int, long> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable(source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian<T>(this T[] source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMedianEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMedian(this ReadOnlySpan<decimal> source) => NList<bool>.IndexesOfMedianEnumerable<decimal>(source);
	public static NList<int> IndexesOfMedian(this Span<decimal> source) => NList<bool>.IndexesOfMedianEnumerable<decimal>((ReadOnlySpan<decimal>)source);
	public static NList<int> IndexesOfMedian(this decimal[] source) => NList<bool>.IndexesOfMedianEnumerable<decimal>((ReadOnlySpan<decimal>)source.AsSpan());
	public static NList<int> IndexesOfMedian(this ReadOnlySpan<double> source) => NList<bool>.IndexesOfMedianEnumerable<double>(source);
	public static NList<int> IndexesOfMedian(this Span<double> source) => NList<bool>.IndexesOfMedianEnumerable<double>((ReadOnlySpan<double>)source);
	public static NList<int> IndexesOfMedian(this double[] source) => NList<bool>.IndexesOfMedianEnumerable<double>((ReadOnlySpan<double>)source.AsSpan());
	public static NList<int> IndexesOfMedian(this ReadOnlySpan<int> source) => NList<bool>.IndexesOfMedianEnumerable<int>(source);
	public static NList<int> IndexesOfMedian(this Span<int> source) => NList<bool>.IndexesOfMedianEnumerable<int>((ReadOnlySpan<int>)source);
	public static NList<int> IndexesOfMedian(this int[] source) => NList<bool>.IndexesOfMedianEnumerable<int>((ReadOnlySpan<int>)source.AsSpan());
	public static NList<int> IndexesOfMedian(this ReadOnlySpan<uint> source) => NList<bool>.IndexesOfMedianEnumerable<uint>(source);
	public static NList<int> IndexesOfMedian(this Span<uint> source) => NList<bool>.IndexesOfMedianEnumerable<uint>((ReadOnlySpan<uint>)source);
	public static NList<int> IndexesOfMedian(this uint[] source) => NList<bool>.IndexesOfMedianEnumerable<uint>((ReadOnlySpan<uint>)source.AsSpan());
	public static NList<int> IndexesOfMedian(this ReadOnlySpan<long> source) => NList<bool>.IndexesOfMedianEnumerable<long>(source);
	public static NList<int> IndexesOfMedian(this Span<long> source) => NList<bool>.IndexesOfMedianEnumerable<long>((ReadOnlySpan<long>)source);
	public static NList<int> IndexesOfMedian(this long[] source) => NList<bool>.IndexesOfMedianEnumerable<long>((ReadOnlySpan<long>)source.AsSpan());
	public static NList<int> IndexesOfMedian(this ReadOnlySpan<MpzT> source) => NList<bool>.IndexesOfMedianEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMedian(this Span<MpzT> source) => NList<bool>.IndexesOfMedianEnumerable<MpzT>((ReadOnlySpan<MpzT>)source);
	public static NList<int> IndexesOfMedian(this MpzT[] source) => NList<bool>.IndexesOfMedianEnumerable<MpzT>((ReadOnlySpan<MpzT>)source.AsSpan());
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, decimal> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, decimal> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int, decimal> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, double> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, double> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, double> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int, double> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, int> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int, int> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, uint> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, uint> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, uint> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int, uint> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, long> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, long> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, long> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int, long> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMinEnumerable(source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, MpzT> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, MpzT> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin<T>(this T[] source, Func<T, int, MpzT> function) => NList<bool>.IndexesOfMinEnumerable((G.IList<T>)source, function);
	public static NList<int> IndexesOfMin(this ReadOnlySpan<decimal> source) => NList<bool>.IndexesOfMinEnumerable<decimal>(source);
	public static NList<int> IndexesOfMin(this Span<decimal> source) => NList<bool>.IndexesOfMinEnumerable<decimal>((ReadOnlySpan<decimal>)source);
	public static NList<int> IndexesOfMin(this decimal[] source) => NList<bool>.IndexesOfMinEnumerable<decimal>((ReadOnlySpan<decimal>)source.AsSpan());
	public static NList<int> IndexesOfMin(this ReadOnlySpan<double> source) => NList<bool>.IndexesOfMinEnumerable<double>(source);
	public static NList<int> IndexesOfMin(this Span<double> source) => NList<bool>.IndexesOfMinEnumerable<double>((ReadOnlySpan<double>)source);
	public static NList<int> IndexesOfMin(this double[] source) => NList<bool>.IndexesOfMinEnumerable<double>((ReadOnlySpan<double>)source.AsSpan());
	public static NList<int> IndexesOfMin(this ReadOnlySpan<int> source) => NList<bool>.IndexesOfMinEnumerable<int>(source);
	public static NList<int> IndexesOfMin(this Span<int> source) => NList<bool>.IndexesOfMinEnumerable<int>((ReadOnlySpan<int>)source);
	public static NList<int> IndexesOfMin(this int[] source) => NList<bool>.IndexesOfMinEnumerable<int>((ReadOnlySpan<int>)source.AsSpan());
	public static NList<int> IndexesOfMin(this ReadOnlySpan<uint> source) => NList<bool>.IndexesOfMinEnumerable<uint>(source);
	public static NList<int> IndexesOfMin(this Span<uint> source) => NList<bool>.IndexesOfMinEnumerable<uint>((ReadOnlySpan<uint>)source);
	public static NList<int> IndexesOfMin(this uint[] source) => NList<bool>.IndexesOfMinEnumerable<uint>((ReadOnlySpan<uint>)source.AsSpan());
	public static NList<int> IndexesOfMin(this ReadOnlySpan<long> source) => NList<bool>.IndexesOfMinEnumerable<long>(source);
	public static NList<int> IndexesOfMin(this Span<long> source) => NList<bool>.IndexesOfMinEnumerable<long>((ReadOnlySpan<long>)source);
	public static NList<int> IndexesOfMin(this long[] source) => NList<bool>.IndexesOfMinEnumerable<long>((ReadOnlySpan<long>)source.AsSpan());
	public static NList<int> IndexesOfMin(this ReadOnlySpan<MpzT> source) => NList<bool>.IndexesOfMinEnumerable<MpzT>(source);
	public static NList<int> IndexesOfMin(this Span<MpzT> source) => NList<bool>.IndexesOfMinEnumerable<MpzT>((ReadOnlySpan<MpzT>)source);
	public static NList<int> IndexesOfMin(this MpzT[] source) => NList<bool>.IndexesOfMinEnumerable<MpzT>((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int IndexOf<T>(this ReadOnlySpan<T> source, T target) => List<T>.IndexOfEnumerable(source, target);
	public static int IndexOf<T>(this Span<T> source, T target) => List<T>.IndexOfEnumerable((ReadOnlySpan<T>)source, target);
	public static int IndexOf<T>(this T[] source, T target) => List<T>.IndexOfEnumerable((G.IList<T>)source, target);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, MpzT> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.IndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int IndexOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<decimal> source) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMax(this decimal[] source) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<double> source) => List<double>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<double> source) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMax(this double[] source) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<int> source) => List<int>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<int> source) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMax(this int[] source) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<uint> source) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMax(this uint[] source) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<long> source) => List<long>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<long> source) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMax(this long[] source) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<MpzT> source) => List<MpzT>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<MpzT> source) => List<MpzT>.IndexOfMaxEnumerable((ReadOnlySpan<MpzT>)source);
	public static int IndexOfMax(this MpzT[] source) => List<MpzT>.IndexOfMaxEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, MpzT> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.IndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int IndexOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<decimal> source) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMean(this decimal[] source) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<double> source) => List<double>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<double> source) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMean(this double[] source) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<int> source) => List<int>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<int> source) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMean(this int[] source) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<uint> source) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMean(this uint[] source) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<long> source) => List<long>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<long> source) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMean(this long[] source) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<MpzT> source) => List<MpzT>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<MpzT> source) => List<MpzT>.IndexOfMeanEnumerable((ReadOnlySpan<MpzT>)source);
	public static int IndexOfMean(this MpzT[] source) => List<MpzT>.IndexOfMeanEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, MpzT> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.IndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int IndexOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<decimal> source) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMedian(this decimal[] source) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<double> source) => List<double>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<double> source) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMedian(this double[] source) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<int> source) => List<int>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<int> source) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMedian(this int[] source) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<uint> source) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMedian(this uint[] source) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<long> source) => List<long>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<long> source) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMedian(this long[] source) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<MpzT> source) => List<MpzT>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<MpzT> source) => List<MpzT>.IndexOfMedianEnumerable((ReadOnlySpan<MpzT>)source);
	public static int IndexOfMedian(this MpzT[] source) => List<MpzT>.IndexOfMedianEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, MpzT> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.IndexOfMinEnumerable((G.IList<T>)source, function);
	public static int IndexOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<decimal> source) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMin(this decimal[] source) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<double> source) => List<double>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<double> source) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMin(this double[] source) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<int> source) => List<int>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<int> source) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMin(this int[] source) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<uint> source) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMin(this uint[] source) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<long> source) => List<long>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<long> source) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMin(this long[] source) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<MpzT> source) => List<MpzT>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<MpzT> source) => List<MpzT>.IndexOfMinEnumerable((ReadOnlySpan<MpzT>)source);
	public static int IndexOfMin(this MpzT[] source) => List<MpzT>.IndexOfMinEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<List<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<List<T>> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source);
	public static List<T> JoinIntoSingle<T>(this List<T>[] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<T[]> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<T[]> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source);
	public static List<T> JoinIntoSingle<T>(this T[][] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<G.IList<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<G.IList<T>> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source);
	public static List<T> JoinIntoSingle<T>(this G.IList<T>[] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<IEnumerable<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<IEnumerable<T>> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T>[] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source.AsSpan());
	public static List<TResult> JoinIntoSingle<T, TResult>(this ReadOnlySpan<T> source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>(source);
	public static List<TResult> JoinIntoSingle<T, TResult>(this Span<T> source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>((ReadOnlySpan<T>)source);
	public static List<TResult> JoinIntoSingle<T, TResult>(this T[] source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>((G.IList<T>)source);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<List<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<List<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source, separator);
	public static List<T> JoinIntoSingle<T>(this List<T>[] source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source.AsSpan(), separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<T[]> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<T[]> source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source, separator);
	public static List<T> JoinIntoSingle<T>(this T[][] source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source.AsSpan(), separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<G.IList<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<G.IList<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source, separator);
	public static List<T> JoinIntoSingle<T>(this G.IList<T>[] source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source.AsSpan(), separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<IEnumerable<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<IEnumerable<T>> source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T>[] source, T separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source.AsSpan(), separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this ReadOnlySpan<T> source, TResult separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this Span<T> source, TResult separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T>)source, separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this T[] source, TResult separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<List<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<List<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source, separator);
	public static List<T> JoinIntoSingle<T>(this List<T>[] source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source.AsSpan(), separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<T[]> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<T[]> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source, separator);
	public static List<T> JoinIntoSingle<T>(this T[][] source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source.AsSpan(), separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<G.IList<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<G.IList<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source, separator);
	public static List<T> JoinIntoSingle<T>(this G.IList<T>[] source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source.AsSpan(), separator);
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<IEnumerable<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<T> JoinIntoSingle<T>(this Span<IEnumerable<T>> source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source, separator);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T>[] source, IEnumerable<T> separator) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source.AsSpan(), separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this ReadOnlySpan<T> source, IEnumerable<TResult> separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this Span<T> source, IEnumerable<TResult> separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T>)source, separator);
	public static List<TResult> JoinIntoSingle<T, TResult>(this T[] source, IEnumerable<TResult> separator) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable(source, separator);
	public static int LastIndexOf<T>(this ReadOnlySpan<T> source, T target) => List<T>.LastIndexOfEnumerable(source, target);
	public static int LastIndexOf<T>(this Span<T> source, T target) => List<T>.LastIndexOfEnumerable((ReadOnlySpan<T>)source, target);
	public static int LastIndexOf<T>(this T[] source, T target) => List<T>.LastIndexOfEnumerable((G.IList<T>)source, target);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, MpzT> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMaxEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMax(this decimal[] source) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<double> source) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMax(this double[] source) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<int> source) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMax(this int[] source) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<uint> source) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMax(this uint[] source) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<long> source) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMax(this long[] source) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<MpzT> source) => List<MpzT>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<MpzT> source) => List<MpzT>.LastIndexOfMaxEnumerable((ReadOnlySpan<MpzT>)source);
	public static int LastIndexOfMax(this MpzT[] source) => List<MpzT>.LastIndexOfMaxEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, MpzT> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMeanEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMean(this decimal[] source) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<double> source) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMean(this double[] source) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<int> source) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMean(this int[] source) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<uint> source) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMean(this uint[] source) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<long> source) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMean(this long[] source) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<MpzT> source) => List<MpzT>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<MpzT> source) => List<MpzT>.LastIndexOfMeanEnumerable((ReadOnlySpan<MpzT>)source);
	public static int LastIndexOfMean(this MpzT[] source) => List<MpzT>.LastIndexOfMeanEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, MpzT> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMedianEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMedian(this decimal[] source) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<double> source) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMedian(this double[] source) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<int> source) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMedian(this int[] source) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<uint> source) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMedian(this uint[] source) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<long> source) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMedian(this long[] source) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<MpzT> source) => List<MpzT>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<MpzT> source) => List<MpzT>.LastIndexOfMedianEnumerable((ReadOnlySpan<MpzT>)source);
	public static int LastIndexOfMedian(this MpzT[] source) => List<MpzT>.LastIndexOfMedianEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, MpzT> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.LastIndexOfMinEnumerable((G.IList<T>)source, function);
	public static int LastIndexOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<decimal> source) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMin(this decimal[] source) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<double> source) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMin(this double[] source) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<int> source) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMin(this int[] source) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<uint> source) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMin(this uint[] source) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<long> source) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMin(this long[] source) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<MpzT> source) => List<MpzT>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<MpzT> source) => List<MpzT>.LastIndexOfMinEnumerable((ReadOnlySpan<MpzT>)source);
	public static int LastIndexOfMin(this MpzT[] source) => List<MpzT>.LastIndexOfMinEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static decimal Max<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Max<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Max<T>(this T[] source, Func<T, decimal> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static decimal Max<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static double Max<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this Span<T> source, Func<T, double> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static double Max<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static double Max<T>(this T[] source, Func<T, double> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static double Max<T>(this T[] source, Func<T, int, double> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static int Max<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this Span<T> source, Func<T, int> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int Max<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int Max<T>(this T[] source, Func<T, int> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static int Max<T>(this T[] source, Func<T, int, int> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static uint Max<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this Span<T> source, Func<T, uint> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Max<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Max<T>(this T[] source, Func<T, uint> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static uint Max<T>(this T[] source, Func<T, int, uint> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static long Max<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this Span<T> source, Func<T, long> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static long Max<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static long Max<T>(this T[] source, Func<T, long> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static long Max<T>(this T[] source, Func<T, int, long> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static MpzT Max<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.MaxEnumerable(source, function);
	public static MpzT Max<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.MaxEnumerable(source, function);
	public static MpzT Max<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Max<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Max<T>(this T[] source, Func<T, MpzT> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static MpzT Max<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.MaxEnumerable((G.IList<T>)source, function);
	public static decimal Max(this ReadOnlySpan<decimal> source) => List<decimal>.MaxEnumerable(source);
	public static decimal Max(this Span<decimal> source) => List<decimal>.MaxEnumerable((ReadOnlySpan<decimal>)source);
	public static double Max(this ReadOnlySpan<double> source) => List<double>.MaxEnumerable(source);
	public static double Max(this Span<double> source) => List<double>.MaxEnumerable((ReadOnlySpan<double>)source);
	public static int Max(this ReadOnlySpan<int> source) => List<int>.MaxEnumerable(source);
	public static int Max(this Span<int> source) => List<int>.MaxEnumerable((ReadOnlySpan<int>)source);
	public static uint Max(this ReadOnlySpan<uint> source) => List<uint>.MaxEnumerable(source);
	public static uint Max(this Span<uint> source) => List<uint>.MaxEnumerable((ReadOnlySpan<uint>)source);
	public static long Max(this ReadOnlySpan<long> source) => List<long>.MaxEnumerable(source);
	public static long Max(this Span<long> source) => List<long>.MaxEnumerable((ReadOnlySpan<long>)source);
	public static MpzT Max(this ReadOnlySpan<MpzT> source) => List<MpzT>.MaxEnumerable(source);
	public static MpzT Max(this Span<MpzT> source) => List<MpzT>.MaxEnumerable((ReadOnlySpan<MpzT>)source);
	public static decimal Mean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Mean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Mean<T>(this T[] source, Func<T, decimal> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static decimal Mean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, double> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, double> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int, double> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int, int> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, uint> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, uint> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int, uint> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, long> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, long> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int, long> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, MpzT> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.MeanEnumerable((G.IList<T>)source, function);
	public static decimal Mean(this ReadOnlySpan<decimal> source) => List<decimal>.MeanEnumerable(source);
	public static decimal Mean(this Span<decimal> source) => List<decimal>.MeanEnumerable((ReadOnlySpan<decimal>)source);
	public static double Mean(this ReadOnlySpan<double> source) => List<double>.MeanEnumerable(source);
	public static double Mean(this Span<double> source) => List<double>.MeanEnumerable((ReadOnlySpan<double>)source);
	public static double Mean(this ReadOnlySpan<int> source) => List<int>.MeanEnumerable(source);
	public static double Mean(this Span<int> source) => List<int>.MeanEnumerable((ReadOnlySpan<int>)source);
	public static double Mean(this ReadOnlySpan<uint> source) => List<uint>.MeanEnumerable(source);
	public static double Mean(this Span<uint> source) => List<uint>.MeanEnumerable((ReadOnlySpan<uint>)source);
	public static double Mean(this ReadOnlySpan<long> source) => List<long>.MeanEnumerable(source);
	public static double Mean(this Span<long> source) => List<long>.MeanEnumerable((ReadOnlySpan<long>)source);
	public static double Mean(this ReadOnlySpan<MpzT> source) => List<MpzT>.MeanEnumerable(source);
	public static double Mean(this Span<MpzT> source) => List<MpzT>.MeanEnumerable((ReadOnlySpan<MpzT>)source);
	public static decimal Median<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Median<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Median<T>(this T[] source, Func<T, decimal> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static decimal Median<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static double Median<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this Span<T> source, Func<T, double> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static double Median<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static double Median<T>(this T[] source, Func<T, double> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static double Median<T>(this T[] source, Func<T, int, double> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static int Median<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this Span<T> source, Func<T, int> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int Median<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int Median<T>(this T[] source, Func<T, int> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static int Median<T>(this T[] source, Func<T, int, int> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static uint Median<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this Span<T> source, Func<T, uint> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Median<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Median<T>(this T[] source, Func<T, uint> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static uint Median<T>(this T[] source, Func<T, int, uint> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static long Median<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this Span<T> source, Func<T, long> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static long Median<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static long Median<T>(this T[] source, Func<T, long> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static long Median<T>(this T[] source, Func<T, int, long> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static MpzT Median<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.MedianEnumerable(source, function);
	public static MpzT Median<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.MedianEnumerable(source, function);
	public static MpzT Median<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Median<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Median<T>(this T[] source, Func<T, MpzT> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static MpzT Median<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.MedianEnumerable((G.IList<T>)source, function);
	public static decimal Median(this ReadOnlySpan<decimal> source) => List<decimal>.MedianEnumerable(source);
	public static decimal Median(this Span<decimal> source) => List<decimal>.MedianEnumerable((ReadOnlySpan<decimal>)source);
	public static double Median(this ReadOnlySpan<double> source) => List<double>.MedianEnumerable(source);
	public static double Median(this Span<double> source) => List<double>.MedianEnumerable((ReadOnlySpan<double>)source);
	public static int Median(this ReadOnlySpan<int> source) => List<int>.MedianEnumerable(source);
	public static int Median(this Span<int> source) => List<int>.MedianEnumerable((ReadOnlySpan<int>)source);
	public static uint Median(this ReadOnlySpan<uint> source) => List<uint>.MedianEnumerable(source);
	public static uint Median(this Span<uint> source) => List<uint>.MedianEnumerable((ReadOnlySpan<uint>)source);
	public static long Median(this ReadOnlySpan<long> source) => List<long>.MedianEnumerable(source);
	public static long Median(this Span<long> source) => List<long>.MedianEnumerable((ReadOnlySpan<long>)source);
	public static MpzT Median(this ReadOnlySpan<MpzT> source) => List<MpzT>.MedianEnumerable(source);
	public static MpzT Median(this Span<MpzT> source) => List<MpzT>.MedianEnumerable((ReadOnlySpan<MpzT>)source);
	public static decimal Min<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Min<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Min<T>(this T[] source, Func<T, decimal> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static decimal Min<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static double Min<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this Span<T> source, Func<T, double> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static double Min<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static double Min<T>(this T[] source, Func<T, double> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static double Min<T>(this T[] source, Func<T, int, double> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static int Min<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this Span<T> source, Func<T, int> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static int Min<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static int Min<T>(this T[] source, Func<T, int> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static int Min<T>(this T[] source, Func<T, int, int> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static uint Min<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this Span<T> source, Func<T, uint> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Min<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Min<T>(this T[] source, Func<T, uint> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static uint Min<T>(this T[] source, Func<T, int, uint> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static long Min<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this Span<T> source, Func<T, long> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static long Min<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static long Min<T>(this T[] source, Func<T, long> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static long Min<T>(this T[] source, Func<T, int, long> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static MpzT Min<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.MinEnumerable(source, function);
	public static MpzT Min<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.MinEnumerable(source, function);
	public static MpzT Min<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Min<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Min<T>(this T[] source, Func<T, MpzT> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static MpzT Min<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.MinEnumerable((G.IList<T>)source, function);
	public static decimal Min(this ReadOnlySpan<decimal> source) => List<decimal>.MinEnumerable(source);
	public static decimal Min(this Span<decimal> source) => List<decimal>.MinEnumerable((ReadOnlySpan<decimal>)source);
	public static double Min(this ReadOnlySpan<double> source) => List<double>.MinEnumerable(source);
	public static double Min(this Span<double> source) => List<double>.MinEnumerable((ReadOnlySpan<double>)source);
	public static int Min(this ReadOnlySpan<int> source) => List<int>.MinEnumerable(source);
	public static int Min(this Span<int> source) => List<int>.MinEnumerable((ReadOnlySpan<int>)source);
	public static uint Min(this ReadOnlySpan<uint> source) => List<uint>.MinEnumerable(source);
	public static uint Min(this Span<uint> source) => List<uint>.MinEnumerable((ReadOnlySpan<uint>)source);
	public static long Min(this ReadOnlySpan<long> source) => List<long>.MinEnumerable(source);
	public static long Min(this Span<long> source) => List<long>.MinEnumerable((ReadOnlySpan<long>)source);
	public static MpzT Min(this ReadOnlySpan<MpzT> source) => List<MpzT>.MinEnumerable(source);
	public static MpzT Min(this Span<MpzT> source) => List<MpzT>.MinEnumerable((ReadOnlySpan<MpzT>)source);
	public static List<TResult> Pairs<T, TResult>(this ReadOnlySpan<T> source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => List<T>.PairsEnumerable(source, function, offset);
	public static List<TResult> Pairs<T, TResult>(this ReadOnlySpan<T> source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => List<T>.PairsEnumerable(source, function, offset);
	public static List<TResult> Pairs<T, TResult>(this Span<T> source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => List<T>.PairsEnumerable((ReadOnlySpan<T>)source, function, offset);
	public static List<TResult> Pairs<T, TResult>(this Span<T> source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => List<T>.PairsEnumerable((ReadOnlySpan<T>)source, function, offset);
	public static Slice<TResult> Pairs<T, TResult>(this T[] source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => List<T>.PairsEnumerable((G.IReadOnlyList<T>)source, function, offset);
	public static Slice<TResult> Pairs<T, TResult>(this T[] source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => List<T>.PairsEnumerable((G.IReadOnlyList<T>)source, function, offset);
	public static List<(T, T)> Pairs<T>(this ReadOnlySpan<T> source, int offset = 1) where T : unmanaged => List<T>.PairsEnumerable(source, offset);
	public static List<(T, T)> Pairs<T>(this Span<T> source, int offset = 1) where T : unmanaged => List<T>.PairsEnumerable((ReadOnlySpan<T>)source, offset);
	public static Slice<(T, T)> Pairs<T>(this T[] source, int offset = 1) where T : unmanaged => List<T>.PairsEnumerable((G.IReadOnlyList<T>)source, offset);
	public static T? Progression<T>(this ReadOnlySpan<T> source, Func<T, T, T> function) => List<T>.ProgressionEnumerable(source, function);
	public static T? Progression<T>(this Span<T> source, Func<T, T, T> function) => List<T>.ProgressionEnumerable((ReadOnlySpan<T>)source, function);
	public static T? Progression<T>(this T[] source, Func<T, T, T> function) => List<T>.ProgressionEnumerable((G.IList<T>)source, function);
	public static TResult? Progression<T, TResult>(this ReadOnlySpan<T> source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable(source, seed, function);
	public static TResult? Progression<T, TResult>(this Span<T> source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable((ReadOnlySpan<T>)source, seed, function);
	public static TResult? Progression<T, TResult>(this T[] source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable((G.IList<T>)source, seed, function);
	public static T Random<T>(this ReadOnlySpan<T> source) => source[random.Next(source.Length)];
	public static T Random<T>(this Span<T> source) => source[random.Next(source.Length)];
	public static T Random<T>(this T[] source) => source[random.Next(source.Length)];
	public static T Random<T>(this ReadOnlySpan<T> source, Random randomObj) => source[randomObj.Next(source.Length)];
	public static T Random<T>(this Span<T> source, Random randomObj) => source[randomObj.Next(source.Length)];
	public static T Random<T>(this T[] source, Random randomObj) => source[randomObj.Next(source.Length)];
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, function);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, function);
	public static List<T> RemoveDoubles<T>(this ReadOnlySpan<T> source) => List<T>.RemoveDoublesEnumerable(source);
	public static List<T> RemoveDoubles<T>(this Span<T> source) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source);
	public static List<T> RemoveDoubles<T>(this T[] source) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, function, equalFunction);
	public static List<T> RemoveDoubles<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction);
	public static List<T> RemoveDoubles<T>(this Span<T> source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<T> RemoveDoubles<T>(this T[] source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((G.IList<T>)source, equalFunction, hashCodeFunction);
	public static NList<int> RepresentIntoNumbers<T>(this ReadOnlySpan<T> source) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable(source);
	public static NList<int> RepresentIntoNumbers<T>(this Span<T> source) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source);
	public static NList<int> RepresentIntoNumbers<T>(this T[] source) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static NList<int> RepresentIntoNumbers<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static NList<int> RepresentIntoNumbers<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static NList<int> RepresentIntoNumbers<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction);
	public static NList<int> RepresentIntoNumbers<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<int> RepresentIntoNumbers<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static NList<int> RepresentIntoNumbers<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => NList<bool>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction, hashCodeFunction);
	public static List<T> Reverse<T>(this ReadOnlySpan<T> source) => List<T>.ReverseEnumerable(source);
	public static List<T> Reverse<T>(this Span<T> source) => List<T>.ReverseEnumerable((ReadOnlySpan<T>)source);
	public static List<T> Reverse<T>(this T[] source) => List<T>.ReverseEnumerable((G.IList<T>)source);
	public static Span<T> SetAll<T>(Span<T> source, T value) => List<T>.SetAllEnumerable(source, value);
	public static bool StartsWith<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool StartsWith<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool StartsWith<T, T2>(this T[] source, T2[] source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable((G.IList<T>)source, source2, function);
	public static bool StartsWith<T, T2>(this T[] source, T2[] source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable((G.IList<T>)source, source2, function);
	public static bool StartsWith<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) => List<T>.StartsWithEnumerable(source, source2);
	public static bool StartsWith<T, T2>(this Span<T> source, Span<T2> source2) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static bool StartsWith<T, T2>(this T[] source, T2[] source2) => List<T>.StartsWithEnumerable(source, source2);
	public static decimal Sum<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum<T>(this Span<T> source, Func<T, decimal> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Sum<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Sum<T>(this T[] source, Func<T, decimal> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static decimal Sum<T>(this T[] source, Func<T, int, decimal> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static double Sum<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this Span<T> source, Func<T, double> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static double Sum<T>(this Span<T> source, Func<T, int, double> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static double Sum<T>(this T[] source, Func<T, double> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static double Sum<T>(this T[] source, Func<T, int, double> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static int Sum<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this Span<T> source, Func<T, int> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static int Sum<T>(this Span<T> source, Func<T, int, int> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static int Sum<T>(this T[] source, Func<T, int> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static int Sum<T>(this T[] source, Func<T, int, int> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static uint Sum<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this Span<T> source, Func<T, uint> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Sum<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Sum<T>(this T[] source, Func<T, uint> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static uint Sum<T>(this T[] source, Func<T, int, uint> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static long Sum<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this Span<T> source, Func<T, long> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static long Sum<T>(this Span<T> source, Func<T, int, long> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static long Sum<T>(this T[] source, Func<T, long> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static long Sum<T>(this T[] source, Func<T, int, long> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static MpzT Sum<T>(this ReadOnlySpan<T> source, Func<T, MpzT> function) => List<T>.SumEnumerable(source, function);
	public static MpzT Sum<T>(this ReadOnlySpan<T> source, Func<T, int, MpzT> function) => List<T>.SumEnumerable(source, function);
	public static MpzT Sum<T>(this Span<T> source, Func<T, MpzT> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Sum<T>(this Span<T> source, Func<T, int, MpzT> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static MpzT Sum<T>(this T[] source, Func<T, MpzT> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static MpzT Sum<T>(this T[] source, Func<T, int, MpzT> function) => List<T>.SumEnumerable((G.IList<T>)source, function);
	public static decimal Sum(this ReadOnlySpan<decimal> source) => List<decimal>.SumEnumerable(source);
	public static decimal Sum(this Span<decimal> source) => List<decimal>.SumEnumerable((ReadOnlySpan<decimal>)source);
	public static decimal Sum(this decimal[] source) => List<decimal>.SumEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static double Sum(this ReadOnlySpan<double> source) => List<double>.SumEnumerable(source);
	public static double Sum(this Span<double> source) => List<double>.SumEnumerable((ReadOnlySpan<double>)source);
	public static double Sum(this double[] source) => List<double>.SumEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int Sum(this ReadOnlySpan<int> source) => List<int>.SumEnumerable(source);
	public static int Sum(this Span<int> source) => List<int>.SumEnumerable((ReadOnlySpan<int>)source);
	public static int Sum(this int[] source) => List<int>.SumEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static uint Sum(this ReadOnlySpan<uint> source) => List<uint>.SumEnumerable(source);
	public static uint Sum(this Span<uint> source) => List<uint>.SumEnumerable((ReadOnlySpan<uint>)source);
	public static uint Sum(this uint[] source) => List<uint>.SumEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static long Sum(this ReadOnlySpan<long> source) => List<long>.SumEnumerable(source);
	public static long Sum(this Span<long> source) => List<long>.SumEnumerable((ReadOnlySpan<long>)source);
	public static long Sum(this long[] source) => List<long>.SumEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static MpzT Sum(this ReadOnlySpan<MpzT> source) => List<MpzT>.SumEnumerable(source);
	public static MpzT Sum(this Span<MpzT> source) => List<MpzT>.SumEnumerable((ReadOnlySpan<MpzT>)source);
	public static MpzT Sum(this MpzT[] source) => List<MpzT>.SumEnumerable((ReadOnlySpan<MpzT>)source.AsSpan());
	public static TResult[] ToArray<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this Span<T> source, Func<T, TResult> function) => List<T>.ToArrayEnumerable((ReadOnlySpan<T>)source, function);
	public static TResult[] ToArray<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => List<T>.ToArrayEnumerable((ReadOnlySpan<T>)source, function);
	public static BitList ToBitList(this ReadOnlySpan<bool> source) => new(source.ToArray());
	public static BitList ToBitList(this ReadOnlySpan<byte> source) => new(source.ToArray());
	public static BitList ToBitList(this ReadOnlySpan<int> source) => new(source.ToArray());
	public static BitList ToBitList(this ReadOnlySpan<uint> source) => new(source);
	public static BitList ToBitList(this Span<bool> source) => new(source.ToArray());
	public static BitList ToBitList(this Span<byte> source) => new(source.ToArray());
	public static BitList ToBitList(this Span<int> source) => new(source.ToArray());
	public static BitList ToBitList(this Span<uint> source) => new(source);
	public static BitList ToBitList(this bool[] source) => new(source);
	public static BitList ToBitList(this byte[] source) => new(source);
	public static BitList ToBitList(this int[] source) => new(source);
	public static BitList ToBitList(this uint[] source) => new(source);
	public static ListHashSet<T> ToHashSet<T>(this ReadOnlySpan<T> source) => new(source);
	public static ListHashSet<T> ToHashSet<T>(this Span<T> source) => new((ReadOnlySpan<T>)source);
	public static ListHashSet<T> ToHashSet<T>(this T[] source) => new((G.IList<T>)source);
	public static List<TResult> ToList<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => List<T>.ToListEnumerable(source, function);
	public static List<TResult> ToList<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => List<T>.ToListEnumerable(source, function);
	public static List<TResult> ToList<T, TResult>(this Span<T> source, Func<T, TResult> function) => List<T>.ToListEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> ToList<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => List<T>.ToListEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> ToList<T, TResult>(this T[] source, Func<T, TResult> function) => List<T>.ToListEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<TResult> ToList<T, TResult>(this T[] source, Func<T, int, TResult> function) => List<T>.ToListEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> ToList<T>(this ReadOnlySpan<T> source) => new(source);
	public static List<T> ToList<T>(this Span<T> source) => new((ReadOnlySpan<T>)source);
	public static List<T> ToList<T>(this T[] source) => new((G.IList<T>)source);
	public static NList<TResult> ToNList<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable(source, function);
	public static NList<TResult> ToNList<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable(source, function);
	public static NList<TResult> ToNList<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<TResult> ToNList<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<TResult> ToNList<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable((G.IList<T>)source, function);
	public static NList<TResult> ToNList<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : unmanaged => NList<bool>.ToNListEnumerable((G.IList<T>)source, function);
	public static NList<TResult> ToNList<T, TResult>(this NList<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ToNListEnumerable(source, function);
	public static NList<TResult> ToNList<T, TResult>(this NList<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ToNListEnumerable(source, function);
	public static NList<T> ToNList<T>(this ReadOnlySpan<T> source) where T : unmanaged => new(source);
	public static NList<T> ToNList<T>(this Span<T> source) where T : unmanaged => new((ReadOnlySpan<T>)source);
	public static NList<T> ToNList<T>(this T[] source) where T : unmanaged => new((G.IList<T>)source);
	public static String ToNString<T>(this ReadOnlySpan<T> source, Func<T, char> function) => NList<bool>.ToNStringEnumerable(source, function);
	public static String ToNString<T>(this ReadOnlySpan<T> source, Func<T, int, char> function) => NList<bool>.ToNStringEnumerable(source, function);
	public static String ToNString<T>(this Span<T> source, Func<T, char> function) => NList<bool>.ToNStringEnumerable((ReadOnlySpan<T>)source, function);
	public static String ToNString<T>(this Span<T> source, Func<T, int, char> function) => NList<bool>.ToNStringEnumerable((ReadOnlySpan<T>)source, function);
	public static String ToNString<T>(this T[] source, Func<T, char> function) => NList<bool>.ToNStringEnumerable((G.IList<T>)source, function);
	public static String ToNString<T>(this T[] source, Func<T, int, char> function) => NList<bool>.ToNStringEnumerable((G.IList<T>)source, function);
	public static String ToNString<T>(this NList<T> source, Func<T, char> function) where T : unmanaged => NList<T>.ToNStringEnumerable(source, function);
	public static String ToNString<T>(this NList<T> source, Func<T, int, char> function) where T : unmanaged => NList<T>.ToNStringEnumerable(source, function);
	public static String ToNString(this ReadOnlySpan<char> source) => new(source);
	public static String ToNString(this Span<char> source) => new((ReadOnlySpan<char>)source);
	public static String ToNString(this char[] source) => new((G.IList<char>)source);
	public static ParallelHashSet<T> ToParallelHashSet<T>(this ReadOnlySpan<T> source) => new(source);
	public static ParallelHashSet<T> ToParallelHashSet<T>(this Span<T> source) => new((ReadOnlySpan<T>)source);
	public static ParallelHashSet<T> ToParallelHashSet<T>(this T[] source) => new((G.IList<T>)source);
	public static string ToString<T>(this ReadOnlySpan<T> source, Func<T, char> function) => new(List<T>.ToArrayEnumerable(source, function));
	public static string ToString<T>(this Span<T> source, Func<T, char> function) => new(List<T>.ToArrayEnumerable((ReadOnlySpan<T>)source, function));
	public static string ToString<T>(this T[] source, Func<T, char> function) => new(List<T>.ToArrayEnumerable((G.IList<T>)source, function));
	public static string ToString<T>(this ReadOnlySpan<T> source, Func<T, int, char> function) => new(List<T>.ToArrayEnumerable(source, function));
	public static string ToString<T>(this Span<T> source, Func<T, int, char> function) => new(List<T>.ToArrayEnumerable((ReadOnlySpan<T>)source, function));
	public static string ToString<T>(this T[] source, Func<T, int, char> function) => new(List<T>.ToArrayEnumerable((G.IList<T>)source, function));
	public static string ToString(this ReadOnlySpan<char> source) => new(source.ToArray());
	public static string ToString(this Span<char> source) => new((ReadOnlySpan<char>)source.ToArray());
	public static string ToString(this char[] source) => new(source);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.PBreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.PBreakEnumerable(source, function, function2);
	public static (List<T>, List<T2>) PBreak<T, T2>(this G.IReadOnlyList<(T, T2)> source) => List<T>.PBreakEnumerable(source);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, (TResult, TResult2)> function) => List<T>.PBreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.PBreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.PBreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.PBreakEnumerable(source, function, function2, function3);
	public static (List<T>, List<T2>, List<T3>) PBreak<T, T2, T3>(this G.IReadOnlyList<(T, T2, T3)> source) => List<T>.PBreakEnumerable(source);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.PBreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.PBreakEnumerable(source, function);
	public static List<TResult> PCombine<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, TResult> function) => List<T>.PCombineEnumerable(source, source2, function);
	public static List<TResult> PCombine<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T2, int, TResult> function) => List<T>.PCombineEnumerable(source, source2, function);
	public static List<(T, T2)> PCombine<T, T2>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2) => List<T>.PCombineEnumerable(source, source2);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.PCombineEnumerable(source, source2, source3, function);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.PCombineEnumerable(source, source2, source3, function);
	public static List<(T, T2, T3)> PCombine<T, T2, T3>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, G.IReadOnlyList<T3> source3) => List<T>.PCombineEnumerable(source, source2, source3);
	public static List<TResult> PCombine<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, T2, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, function);
	public static List<TResult> PCombine<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, T2, int, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, function);
	public static List<(T, T2)> PCombine<T, T2>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source) => List<T>.PCombineEnumerable(source.Item1, source.Item2);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>, G.IReadOnlyList<T3>) source, Func<T, T2, T3, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>, G.IReadOnlyList<T3>) source, Func<T, T2, T3, int, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static List<(T, T2, T3)> PCombine<T, T2, T3>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>, G.IReadOnlyList<T3>) source) => List<T>.PCombineEnumerable(source.Item1, source.Item2, source.Item3);
	public static bool PContains<T>(this G.IReadOnlyList<T> source, T target) => List<T>.PContainsEnumerable(source, target);
	public static bool PContains<T>(this G.IReadOnlyList<T> source, T target, IEqualityComparer<T> comparer) => List<T>.PContainsEnumerable(source, target, comparer);
	public static bool PContains<T>(this G.IReadOnlyList<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.PContainsEnumerable(source, target, equalFunction);
	public static bool PContains<T>(this G.IReadOnlyList<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.PContainsEnumerable(source, target, equalFunction, hashCodeFunction);
	public static List<TResult> PConvert<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function) => List<T>.PConvertEnumerable(source, function);
	public static List<TResult> PConvert<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function) => List<T>.PConvertEnumerable(source, function);
	public static List<TResult> PFill<TResult>(TResult elem, int length) => List<bool>.PFillEnumerable(elem, length);
	public static List<TResult> PFill<TResult>(Func<int, TResult> function, int length) => List<bool>.PFillEnumerable(function, length);
	public static List<TResult> PFill<TResult>(int length, Func<int, TResult> function) => List<bool>.PFillEnumerable(function, length);
	public static TResult[] PFillArray<TResult>(TResult elem, int length) => List<bool>.PFillArrayEnumerable(elem, length);
	public static TResult[] PFillArray<TResult>(Func<int, TResult> function, int length) => List<bool>.PFillArrayEnumerable(function, length);
	public static TResult[] PFillArray<TResult>(int length, Func<int, TResult> function) => List<bool>.PFillArrayEnumerable(function, length);
	public static List<T> PFilter<T>(this G.IReadOnlyList<T> source, Func<T, bool> function) => List<T>.PFilterEnumerable(source, function);
	public static List<T> PFilter<T>(this G.IReadOnlyList<T> source, Func<T, int, bool> function) => List<T>.PFilterEnumerable(source, function);
	public static decimal PMax<T>(this G.IReadOnlyList<T> source, Func<T, decimal> function) => NList<bool>.PMaxEnumerable(source, function);
	public static decimal PMax<T>(this G.IReadOnlyList<T> source, Func<T, int, decimal> function) => NList<bool>.PMaxEnumerable(source, function);
	public static double PMax<T>(this G.IReadOnlyList<T> source, Func<T, double> function) => NList<bool>.PMaxEnumerable(source, function);
	public static double PMax<T>(this G.IReadOnlyList<T> source, Func<T, int, double> function) => NList<bool>.PMaxEnumerable(source, function);
	public static int PMax<T>(this G.IReadOnlyList<T> source, Func<T, int> function) => NList<bool>.PMaxEnumerable(source, function);
	public static int PMax<T>(this G.IReadOnlyList<T> source, Func<T, int, int> function) => NList<bool>.PMaxEnumerable(source, function);
	public static uint PMax<T>(this G.IReadOnlyList<T> source, Func<T, uint> function) => NList<bool>.PMaxEnumerable(source, function);
	public static uint PMax<T>(this G.IReadOnlyList<T> source, Func<T, int, uint> function) => NList<bool>.PMaxEnumerable(source, function);
	public static long PMax<T>(this G.IReadOnlyList<T> source, Func<T, long> function) => NList<bool>.PMaxEnumerable(source, function);
	public static long PMax<T>(this G.IReadOnlyList<T> source, Func<T, int, long> function) => NList<bool>.PMaxEnumerable(source, function);
	public static MpzT PMax<T>(this G.IReadOnlyList<T> source, Func<T, MpzT> function) => NList<bool>.PMaxEnumerable(source, function);
	public static MpzT PMax<T>(this G.IReadOnlyList<T> source, Func<T, int, MpzT> function) => NList<bool>.PMaxEnumerable(source, function);
	public static decimal PMin<T>(this G.IReadOnlyList<T> source, Func<T, decimal> function) => NList<bool>.PMinEnumerable(source, function);
	public static decimal PMin<T>(this G.IReadOnlyList<T> source, Func<T, int, decimal> function) => NList<bool>.PMinEnumerable(source, function);
	public static double PMin<T>(this G.IReadOnlyList<T> source, Func<T, double> function) => NList<bool>.PMinEnumerable(source, function);
	public static double PMin<T>(this G.IReadOnlyList<T> source, Func<T, int, double> function) => NList<bool>.PMinEnumerable(source, function);
	public static int PMin<T>(this G.IReadOnlyList<T> source, Func<T, int> function) => NList<bool>.PMinEnumerable(source, function);
	public static int PMin<T>(this G.IReadOnlyList<T> source, Func<T, int, int> function) => NList<bool>.PMinEnumerable(source, function);
	public static uint PMin<T>(this G.IReadOnlyList<T> source, Func<T, uint> function) => NList<bool>.PMinEnumerable(source, function);
	public static uint PMin<T>(this G.IReadOnlyList<T> source, Func<T, int, uint> function) => NList<bool>.PMinEnumerable(source, function);
	public static long PMin<T>(this G.IReadOnlyList<T> source, Func<T, long> function) => NList<bool>.PMinEnumerable(source, function);
	public static long PMin<T>(this G.IReadOnlyList<T> source, Func<T, int, long> function) => NList<bool>.PMinEnumerable(source, function);
	public static MpzT PMin<T>(this G.IReadOnlyList<T> source, Func<T, MpzT> function) => NList<bool>.PMinEnumerable(source, function);
	public static MpzT PMin<T>(this G.IReadOnlyList<T> source, Func<T, int, MpzT> function) => NList<bool>.PMinEnumerable(source, function);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function) => List<T>.PRemoveDoublesEnumerable(source, function);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function) => List<T>.PRemoveDoublesEnumerable(source, function);
	public static List<T> PRemoveDoubles<T>(this G.IReadOnlyList<T> source) => List<T>.PRemoveDoublesEnumerable(source);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, function, comparer);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, function, comparer);
	public static List<T> PRemoveDoubles<T>(this G.IReadOnlyList<T> source, IEqualityComparer<T> comparer) => List<T>.PRemoveDoublesEnumerable(source, comparer);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> PRemoveDoubles<T>(this G.IReadOnlyList<T> source, Func<T, T, bool> equalFunction) => List<T>.PRemoveDoublesEnumerable(source, equalFunction);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> PRemoveDoubles<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> PRemoveDoubles<T>(this G.IReadOnlyList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.PRemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function) => List<T>.PRemoveDoublesEnumerable(source, source2, function);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function) => List<T>.PRemoveDoublesEnumerable(source, source2, function);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2) => List<T>.PRemoveDoublesEnumerable(source, source2);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, source2, function, comparer);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, source2, function, comparer);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, IEqualityComparer<T> comparer) => List<T>.PRemoveDoublesEnumerable(source, source2, comparer);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, source2, function, equalFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, source2, function, equalFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T, bool> equalFunction) => List<T>.PRemoveDoublesEnumerable(source, source2, equalFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this G.IReadOnlyList<T> source, G.IReadOnlyList<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.PRemoveDoublesEnumerable(source, source2, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, TResult> function) => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, int, TResult> function) => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source) => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, IEqualityComparer<T> comparer) => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, comparer);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, T, bool> equalFunction) => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2, TResult>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) PRemoveDoubles<T, T2>(this (G.IReadOnlyList<T>, G.IReadOnlyList<T2>) source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.PRemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction, hashCodeFunction);
	public static TResult[] PToArray<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function) => List<T>.PToArrayEnumerable(source, function);
	public static TResult[] PToArray<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function) => List<T>.PToArrayEnumerable(source, function);
	public static T[] PToArray<T>(this G.IReadOnlyList<T> source) => List<T>.PToArrayEnumerable(source);
	public static bool TryWrap<T>(this T source, Action<T> function) => List<T>.TryWrapEnumerable(source, function);
	public static bool TryWrap<T, TResult>(this T source, Func<T, TResult> function, out TResult? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static TResult Wrap<T, TResult>(this T source, Func<T, TResult> function) => function(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this IEnumerable<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this IEnumerable<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function, function2);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this ReadOnlySpan<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this Span<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this (T, T2)[] source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source.AsSpan());
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this ReadOnlySpan<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this Span<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this (T, T2, T3)[] source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source.AsSpan());
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.BreakEnumerable((G.IList<T>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this NList<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this NList<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<(T, T2)> NCombine<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> NCombine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((G.IList<T>)source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((G.IList<T>)source, source2, function);
	public static NList<(T, T2)> NCombine<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<(T, T2)> NCombine<T, T2>(this Span<T> source, Span<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static NList<(T, T2)> NCombine<T, T2>(this T[] source, T2[] source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((G.IList<T>)source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((G.IList<T>)source, source2, source3, function);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this Span<T> source, Span<T2> source2, Span<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this T[] source, T2[] source2, T3[] source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> NCombine<T, T2, TResult>(this NList<T> source, NList<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this NList<T> source, NList<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<(T, T2)> NCombine<T, T2>(this NList<T> source, NList<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this NList<T> source, NList<T2> source2, NList<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> NConvertAndJoin<T, TResult>(this NList<T> source, Func<T, IEnumerable<TResult>> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertAndJoinEnumerable(source, function);
	public static NList<TResult> NConvertAndJoin<T, TResult>(this NList<T> source, Func<T, int, IEnumerable<TResult>> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertAndJoinEnumerable(source, function);
	public static NList<T> NEmptyList<T>(int length) where T : unmanaged => NList<T>.EmptyListEnumerable(length);
	public static NList<TResult> NFill<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged => NList<TResult>.FillEnumerable(function, length);
	public static NList<TResult> NFill<TResult>(int length, Func<int, TResult> function) where TResult : unmanaged => NList<TResult>.FillEnumerable(function, length);
	public static NList<TResult> NFill<TResult>(TResult elem, int length) where TResult : unmanaged => NList<TResult>.FillEnumerable(elem, length);
	public static NList<T> NFilter<T>(this NList<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.FilterEnumerable(source, function);
	public static NList<T> NFilter<T>(this NList<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.FilterEnumerable(source, function);
	public static NList<T> NFindAll<T>(this NList<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.FindAllEnumerable(source, function);
	public static NList<T> NFindAll<T>(this NList<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.FindAllEnumerable(source, function);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function);
	[Obsolete("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в последовательности, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.", true)]
	public static List<NGroup<T, T>> NGroup<T>(this IEnumerable<T> source) where T : unmanaged => throw new NotSupportedException("Этот метод не имеет смысла, так как без использования функций сравнения или вычисления ключа все элементы в каждой группе будут в точности одинаковыми, и такая группировка будет впустую расходовать память. Если вы хотите узнать количество вхождений каждого элемента в последовательности, используйте экстент FrequencyTable(). Если вы по ошибке не добавили функцию сравнения или функцию ключа, добавьте их.");
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function, comparer);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function, comparer);
	public static List<NGroup<T, T>> NGroup<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : unmanaged => NList<T>.GroupEnumerable(source, comparer);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function, equalFunction);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function, equalFunction);
	public static List<NGroup<T, T>> NGroup<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : unmanaged => NList<T>.GroupEnumerable(source, equalFunction);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<NGroup<T, TResult>> NGroup<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where T : unmanaged where TResult : notnull => NList<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<NGroup<T, T>> NGroup<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : unmanaged => NList<T>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<int> NIndexesOf<T>(this NList<T> source, T target) where T : unmanaged => NList<T>.IndexesOfEnumerable(source, target);
	public static NList<TResult> NPairs<T, TResult>(this IEnumerable<T> source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable(source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this IEnumerable<T> source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable(source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this ReadOnlySpan<T> source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable(source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this ReadOnlySpan<T> source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable(source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this Span<T> source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable((ReadOnlySpan<T>)source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this Span<T> source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable((ReadOnlySpan<T>)source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this T[] source, Func<T, T, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable((G.IList<T>)source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this T[] source, Func<T, T, int, TResult> function, int offset = 1) where TResult : unmanaged => NList<bool>.PairsEnumerable((G.IList<T>)source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this NList<T> source, Func<T, T, TResult> function, int offset = 1) where T : unmanaged where TResult : unmanaged => NList<T>.PairsEnumerable(source, function, offset);
	public static NList<TResult> NPairs<T, TResult>(this NList<T> source, Func<T, T, int, TResult> function, int offset = 1) where T : unmanaged where TResult : unmanaged => NList<T>.PairsEnumerable(source, function, offset);
	public static NList<(T, T)> NPairs<T>(this IEnumerable<T> source, int offset = 1) where T : unmanaged => NList<T>.PairsEnumerable(source, offset);
	public static NList<(T, T)> NPairs<T>(this ReadOnlySpan<T> source, int offset = 1) where T : unmanaged => NList<T>.PairsEnumerable(source, offset);
	public static NList<(T, T)> NPairs<T>(this Span<T> source, int offset = 1) where T : unmanaged => NList<T>.PairsEnumerable((ReadOnlySpan<T>)source, offset);
	public static NList<(T, T)> NPairs<T>(this T[] source, int offset = 1) where T : unmanaged => NList<T>.PairsEnumerable((G.IList<T>)source, offset);
	public static NList<(T, T)> NPairs<T>(this NList<T> source, int offset = 1) where T : unmanaged => NList<T>.PairsEnumerable(source, offset);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function);
	public static NList<T> NRemoveDoubles<T>(this NList<T> source) where T : unmanaged => NList<T>.RemoveDoublesEnumerable(source);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static NList<T> NRemoveDoubles<T>(this NList<T> source, Func<T, T, bool> equalFunction) where T : unmanaged => NList<T>.RemoveDoublesEnumerable(source, equalFunction);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static NList<T> NRemoveDoubles<T>(this NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : unmanaged => NList<T>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<int> NRepresentIntoNumbers<T>(this NList<T> source) where T : unmanaged => NList<T>.RepresentIntoNumbersEnumerable(source);
	public static NList<int> NRepresentIntoNumbers<T>(this NList<T> source, Func<T, T, bool> equalFunction) where T : unmanaged => NList<T>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static NList<int> NRepresentIntoNumbers<T>(this NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : unmanaged => NList<T>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<T> NReverse<T>(this NList<T> source) where T : unmanaged => NList<T>.ReverseEnumerable(source);
	public static NList<TResult> NShuffle<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : unmanaged => NList<bool>.ShuffleEnumerable(source, function, random);
	public static NList<TResult> NShuffle<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Random random) where TResult : unmanaged => NList<bool>.ShuffleEnumerable(source, function, random);
	public static NList<TResult> NShuffle<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : unmanaged => NList<bool>.ShuffleEnumerable(source, function, random);
	public static NList<TResult> NShuffle<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Random random) where TResult : unmanaged => NList<bool>.ShuffleEnumerable(source, function, random);
	public static NList<T> NShuffle<T>(this IEnumerable<T> source) where T : unmanaged => NList<T>.ShuffleEnumerable(source, random);
	public static NList<T> NShuffle<T>(this IEnumerable<T> source, Random random) where T : unmanaged => NList<T>.ShuffleEnumerable(source, random);
	public static Slice<T> NSkipWhile<T>(this IEnumerable<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.SkipWhileEnumerable(source, function);
	public static Slice<T> NSkipWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.SkipWhileEnumerable(source, function);
	public static List<NList<T>> NSplitIntoEqual<T>(this G.IReadOnlyList<T> source, int fragmentLength) where T : unmanaged => NList<T>.SplitIntoEqualEnumerable(source, fragmentLength);
	public static Slice<T> NTake<T>(this IEnumerable<T> source, int length) where T : unmanaged => NList<T>.TakeEnumerable(source, length);
	public static Slice<T> NTakeWhile<T>(this IEnumerable<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.TakeWhileEnumerable(source, function);
	public static Slice<T> NTakeWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.TakeWhileEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.PBreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.PBreakEnumerable(source, function, function2);
	public static (NList<T>, NList<T2>) PNBreak<T, T2>(this G.IList<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.PBreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.PBreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IReadOnlyList<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<bool>.PBreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.PBreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.PBreakEnumerable(source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) PNBreak<T, T2, T3>(this G.IList<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.PBreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.PBreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IReadOnlyList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<bool>.PBreakEnumerable(source, function);
	public static NList<TResult> PNCombine<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IList<T2> source2, Func<T, T2, TResult> function) where TResult : unmanaged => NList<bool>.CombineEnumerable(source, source2, function);
	public static NList<TResult> PNCombine<T, T2, TResult>(this G.IReadOnlyList<T> source, G.IList<T2> source2, Func<T, T2, int, TResult> function) where TResult : unmanaged => NList<bool>.CombineEnumerable(source, source2, function);
	public static NList<(T, T2)> PNCombine<T, T2>(this G.IReadOnlyList<T> source, G.IList<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<TResult> PNCombine<T, T2, T3, TResult>(this G.IReadOnlyList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, TResult> function) where TResult : unmanaged => NList<bool>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> PNCombine<T, T2, T3, TResult>(this G.IReadOnlyList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, int, TResult> function) where TResult : unmanaged => NList<bool>.CombineEnumerable(source, source2, source3, function);
	public static NList<(T, T2, T3)> PNCombine<T, T2, T3>(this G.IReadOnlyList<T> source, G.IList<T2> source2, G.IList<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> PNConvert<T, TResult>(this G.IReadOnlyList<T> source, Func<T, TResult> function) where TResult : unmanaged => NList<bool>.PConvertEnumerable(source, function);
	public static NList<TResult> PNConvert<T, TResult>(this G.IReadOnlyList<T> source, Func<T, int, TResult> function) where TResult : unmanaged => NList<bool>.PConvertEnumerable(source, function);
	public static NList<TResult> PNFill<TResult>(TResult elem, int length) where TResult : unmanaged => NList<TResult>.PFillEnumerable(elem, length);
	public static NList<TResult> PNFill<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged => NList<TResult>.PFillEnumerable(function, length);
	public static NList<TResult> PNFill<TResult>(int length, Func<int, TResult> function) where TResult : unmanaged => NList<TResult>.PFillEnumerable(function, length);
}
