using System.Reflection;

namespace Corlib.NStar;

public partial class List<T, TCertain>
{
	internal static bool AllEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				if (!function(list._items[i]))
					return false;
			return true;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				if (!function(array[i]))
					return false;
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				if (!function(list2[i]))
					return false;
			return true;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (!function(item))
					return false;
				i++;
			}
			return true;
		}
	}

	internal static bool AllEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (!function(item, i))
					return false;
				i++;
			}
			return true;
		}
	}

	internal static bool AnyEnumerable(IEnumerable<T> source) => source switch
	{
		List<T> list => list._size != 0,
		T[] array => array.Length != 0,
		G.IList<T> list2 => list2.Count != 0,
		_ => source.GetEnumerator().MoveNext()
	};

	internal static bool AnyEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				if (function(list._items[i]))
					return true;
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					return true;
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					return true;
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool AnyEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<T>, List<T2>) BreakEnumerable<T2>(IEnumerable<(T, T2)> source)
	{
		if (source is List<(T, T2)> list)
		{
			var length = list._size;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list._items[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is (T, T2)[] array)
		{
			var length = array.Length;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<(T, T2)> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<T2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i]) = item;
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i]) = function(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i]) = function(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			return (result, result2);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<T>, List<T2>, List<T3>) BreakEnumerable<T2, T3>(IEnumerable<(T, T2, T3)> source)
	{
		if (source is List<(T, T2, T3)> list)
		{
			var length = list._size;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list._items[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is (T, T2, T3)[] array)
		{
			var length = array.Length;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<(T, T2, T3)> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<T2> result2 = new(length);
			List<T3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i], result3._items[i]) = item;
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			List<TResult2> result2 = new(length);
			List<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result.EnsureCapacity(i + 1);
				result2.EnsureCapacity(i + 1);
				result3.EnsureCapacity(i + 1);
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
				i++;
			}
			result._size = i;
			result2._size = i;
			result3._size = i;
			return (result, result2, result3);
		}
	}

	internal static List<T> BreakFilterEnumerable(IEnumerable<T> source, Func<T, bool> function, out List<T> result2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length / 2);
			result2 = new(array.Length / 2);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length / 2 : 0);
			result2 = new(length / 2);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(item);
				else
					result2.Add(item);
				i++;
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
	}

	internal static List<T> BreakFilterEnumerable(IEnumerable<T> source, Func<T, int, bool> function, out List<T> result2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length / 2);
			result2 = new(array.Length / 2);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length / 2);
			result2 = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length / 2 : 0);
			result2 = new(length / 2);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(item);
				else
					result2.Add(item);
				i++;
			}
			result.TrimExcess();
			result2.TrimExcess();
			return result;
		}
	}

	internal static List<TResult> CombineEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : 1024);
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				result._items[i] = function(item, item2);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> CombineEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : 1024);
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				result._items[i] = function(item, item2, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<(T, T2)> CombineEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<(T, T2)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : 1024);
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				result._items[i] = (item, item2);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = MinEnumerable(new[] { list._size, list2._size, list3._size }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				var item3 = list3._items[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : TryGetLengthEasilyEnumerable(source3, out length) ? length : 1024);
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var en3 = source3.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext() && en3.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				var item3 = en3.Current;
				result._items[i] = function(item, item2, item3);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = MinEnumerable(new[] { list._size, list2._size, list3._size }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				var item3 = list3._items[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : TryGetLengthEasilyEnumerable(source3, out length) ? length : 1024);
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var en3 = source3.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext() && en3.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				var item3 = en3.Current;
				result._items[i] = function(item, item2, item3, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<(T, T2, T3)> CombineEnumerable<T2, T3>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3)
	{
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = MinEnumerable(new[] { list._size, list2._size, list3._size }.AsSpan());
			List<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				var item3 = list3._items[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<(T, T2, T3)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : TryGetLengthEasilyEnumerable(source2, out length) ? length : TryGetLengthEasilyEnumerable(source3, out length) ? length : 1024);
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var en3 = source3.GetEnumerator();
			var i = 0;
			while (en.MoveNext() && en2.MoveNext() && en3.MoveNext())
			{
				result.EnsureCapacity(i + 1);
				var item = en.Current;
				var item2 = en2.Current;
				var item3 = en3.Current;
				result._items[i] = (item, item2, item3);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<T> ConcatEnumerable(IEnumerable<T> source, params IEnumerable<T>[] collections)
	{
		List<T> result = new(source);
		for (var i = 0; i < collections.Length; i++)
			result.AddRange(collections[i]);
		return result;
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target, IEqualityComparer<T> comparer)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static List<TResult> ConvertEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list._items[i]);
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> ConvertEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			List<TResult> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TResult>(IEnumerable<T> source, Func<T, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
				result.AddRange(function(list._items[i]));
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result.AddRange(function(array[i]));
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
				result.AddRange(function(list2[i]));
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(function(item));
				i++;
			}
			return result;
		}
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TResult>(IEnumerable<T> source, Func<T, int, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(function(item, i));
			}
			return result;
		}
		else if (source is T[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(function(item, i));
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(function(item, i));
			}
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(function(item, i));
				i++;
			}
			return result;
		}
	}

	internal static int CountEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list._items[i]))
					n++;
			return n;
		}
		else if (source is T[] array)
		{
			var n = 0;
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					n++;
			return n;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					n++;
			return n;
		}
		else
		{
			var n = 0;
			foreach (var item in source)
				if (function(item))
					n++;
			return n;
		}
	}

	internal static int CountEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list._items[i], i))
					n++;
			return n;
		}
		else if (source is T[] array)
		{
			var n = 0;
			for (var i = 0; i < array.Length; i++)
				if (function(array[i], i))
					n++;
			return n;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
				if (function(list2[i], i))
					n++;
			return n;
		}
		else
		{
			var n = 0;
			var i = 0;
			foreach (var item in source)
				if (function(item, i++))
					n++;
			return n;
		}
	}

	internal static int CountEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			var n = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is T[] array)
		{
			var n = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var n = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else
		{
			var n = 0;
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					n++;
				i++;
			}
			return n;
		}
	}

	internal static List<T> EmptyListEnumerable(int length) => new(length) { _size = length };

	internal static bool EqualsEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2))
					return false;
			}
			return list._size == list2._size;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			var length = list2_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else
		{
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			while (en.MoveNext())
			{
				if (!en2.MoveNext())
					return false;
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2))
					return false;
			}
			return !en2.MoveNext();
		}
	}

	internal static bool EqualsEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size != list2._size)
				return false;
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			var length = list2_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else
		{
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext())
			{
				if (!en2.MoveNext())
					return false;
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2, i))
					return false;
				i++;
			}
			return !en2.MoveNext();
		}
	}

	internal static bool EqualsEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size != list2._size)
				return false;
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			var length = list2_.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else
		{
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			while (en.MoveNext())
			{
				if (!en2.MoveNext())
					return false;
				var item = en.Current;
				var item2 = en2.Current;
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return !en2.MoveNext();
		}
	}

	internal static List<TResult> FillEnumerable<TResult>(TResult elem, int length)
	{
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = elem;
		result._size = length;
		return result;
	}

	internal static List<TResult> FillEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(i);
		result._size = length;
		return result;
	}

	internal static TResult[] FillArrayEnumerable<TResult>(TResult elem, int length)
	{
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = elem;
		return result;
	}

	internal static TResult[] FillArrayEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = function(i);
		return result;
	}

	internal static List<T> FilterEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length / 2);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length / 2 : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FilterEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length / 2);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length / 2);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length / 2 : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static T? FindEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					return item;
				i++;
			}
			return default;
		}
	}

	internal static T? FindEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					return item;
				i++;
			}
			return default;
		}
	}

	internal static List<T> FindAllEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<T> FindAllMeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<T> FindAllMedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(item);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> FindAllMinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(item);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
				}
				else if (f == indicator!)
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindIndexesEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
				if (function(list._items[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindIndexesEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static int FindIndexEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				if (function(list._items[i]))
					return i;
			return default;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				if (function(array[i]))
					return i;
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				if (function(list2[i]))
					return i;
			return default;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item))
					return i;
				i++;
			}
			return default;
		}
	}

	internal static int FindIndexEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (function(item, i))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static T? FindLastEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else
			return FindLastEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else
			return FindLastEnumerable(new List<T>(source), function);
	}

	internal static int FindLastIndexEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
				if (function(list._items[i]))
					return i;
			return -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
				if (function(array[i]))
					return i;
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
				if (function(list2[i]))
					return i;
			return -1;
		}
		else
			return FindLastIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastIndexEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else
			return FindLastIndexEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static T? FindLastMinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static int FindLastMinIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<T>(source), function);
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static T? FindMeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static T? FindMedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static T? FindMinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
		{
			T? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMaxIndexesEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
	}

	internal static List<int> FindMeanIndexesEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static List<int> FindMedianIndexesEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> FindMinIndexesEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMaxIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MeanEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (int)value;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (uint)value;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (long)value;
			return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
	}

	internal static int FindMeanIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MeanEnumerable(list, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MeanEnumerable(array.AsSpan(), function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MeanEnumerable(list2, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
		{
			var value = MeanEnumerable(source, function);
			var value2 = (mpz_t)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x) => function(x) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
	}

	internal static int FindMedianIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array.AsSpan(), (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
		{
			var value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int FindMinIndexEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static void ForEachEnumerable(IEnumerable<T> source, Action<T> action)
	{
		if (action == null)
			throw new ArgumentNullException(nameof(action));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				action(list._items[i]);
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				action(array[i]);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				action(list2[i]);
		}
		else
		{
			foreach (var item in source)
				action(item);
		}
	}

	internal static void ForEachEnumerable(IEnumerable<T> source, Action<T, int> action)
	{
		if (action == null)
			throw new ArgumentNullException(nameof(action));
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
				action(list._items[i], i);
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
				action(array[i], i);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
				action(list2[i], i);
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				action(item, i);
				i++;
			}
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(TResult Key, int Count)> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(TResult Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<(T Key, int Count)> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<(T Key, int Count)> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<(T Key, int Count)> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index] = (f, result._items[index].Count + 1);
				else
					result._items[j++] = (f, 1);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<T, T>> GroupEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<T, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<T, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<T, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(item);
				else
					result._items[j++] = new((List<T>)item, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, TResult>> result = new(array.Length);
			var j = 0;
			TResult f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, TResult>> result = new(length);
			var j = 0;
			TResult f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, TResult>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			TResult f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = function(item, i), out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<Group<int, T>> result = new(array.Length);
			var j = 0;
			T f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<Group<int, T>> result = new(length);
			var j = 0;
			T f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<Group<int, T>> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			T f;
			var i = 0;
			foreach (var item in source)
			{
				if (!dic.TryAdd(f = item, out var index))
					result._items[index].Add(i);
				else
					result._items[j++] = new((List<int>)i, f);
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is decimal[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is double[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is int[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is uint[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is long[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is mpz_t[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			return List<decimal>.IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			return List<double>.IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is mpz_t[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is mpz_t[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result.Add(i);
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result.Add(i);
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is decimal[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			decimal indicator = 0;
			var j = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is double[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			double indicator = 0;
			var j = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is int[] array)
		{
			List<int> result = new(array.Length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var indicator = 0;
			var j = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is uint[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			uint indicator = 0;
			var j = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is long[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			long indicator = 0;
			var j = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is mpz_t[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			mpz_t indicator = 0;
			var j = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
					j++;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result.Add(i);
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result.Clear();
					result.Add(i);
				}
				else if (f == indicator!)
					result.Add(i);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (item?.Equals(target) ?? false)
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target, IEqualityComparer<T> comparer)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			var i = 0;
			foreach (var item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<decimal>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<double>.IndexOfEnumerable(list_, MeanEnumerable(list_));
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is mpz_t[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ConvertEnumerable(source, function);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is mpz_t[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
		{
			var list_ = ReturnOrConstruct(source);
			return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<List<T>> source)
	{
		if (source is List<List<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is List<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<List<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(IEnumerable<TSource> source) where TSource : IEnumerable<TResult>
	{
		if (source is List<TSource> list)
		{
			var length = list._size;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
				result.AddRange(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result.AddRange(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			var length = list2.Count;
			List<TResult> result = new(1024);
			for (var i = 0; i < length; i++)
				result.AddRange(list2[i]);
			return result;
		}
		else
		{
			List<TResult> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<T[]> source)
	{
		if (source is List<T[]> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is T[][] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T[]> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<G.IList<T>> source)
	{
		if (source is List<G.IList<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<G.IList<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> JoinIntoSingleEnumerable(IEnumerable<IEnumerable<T>> source)
	{
		if (source is List<IEnumerable<T>> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is IEnumerable<T>[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<IEnumerable<T>> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target);
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target, IEqualityComparer<T> comparer)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = array.Length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target, comparer);
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = array.Length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target, equalFunction);
	}

	internal static int LastIndexOfEnumerable(IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		if (source is List<T> list)
		{
			var length = list._size;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is T[] array)
		{
			for (var i = array.Length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<T>(source), target, equalFunction, hashCodeFunction);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<mpz_t>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.LastIndexOfEnumerable(list_, MeanEnumerable(list_));
		}
		else
			return LastIndexOfMeanEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (int)value;
			return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (uint)value;
			return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (long)value;
			return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var list_ = ReturnOrConstruct(list);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is mpz_t[] array)
		{
			var list_ = ReturnOrConstruct(array);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			var value = MeanEnumerable(list_);
			var value2 = (mpz_t)value;
			return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<mpz_t>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var list_ = ConvertEnumerable(list, function);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var list_ = ConvertEnumerable(array.AsSpan(), function);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var list_ = ConvertEnumerable(list2, function);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is decimal[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<decimal> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is double[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<double> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is int[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<int> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is uint[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<uint> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is long[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<long> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var list_ = ReturnOrConstruct(list);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is mpz_t[] array)
		{
			var list_ = ReturnOrConstruct(array);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var list_ = ReturnOrConstruct(list2);
			return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
		}
		else
			return LastIndexOfMedianEnumerable(new List<mpz_t>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<T>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			var length = array.Length;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			var result = -1;
			decimal indicator = 0;
			decimal f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			var length = array.Length;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			var result = -1;
			double indicator = 0;
			double f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			var length = array.Length;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = -1;
			var indicator = 0;
			int f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			var length = array.Length;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			var result = -1;
			uint indicator = 0;
			uint f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			var length = array.Length;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			var result = -1;
			long indicator = 0;
			long f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			var length = array.Length;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			var result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = length - 1; i >= 0; i--)
			{
				var item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<mpz_t>(source));
	}

	internal static int LengthEnumerable(IEnumerable<T> source)
	{
		if (TryGetLengthEasilyEnumerable(source, out var length))
			return length;
		else
		{
			var n = 0;
			var en = source.GetEnumerator();
			while (en.MoveNext()) n++;
			return n;
		}
	}

	internal static decimal MaxEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MaxEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MaxEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MaxEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is decimal[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is double[] array)
		{
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is int[] array)
		{
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is uint[] array)
		{
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is long[] array)
		{
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is mpz_t[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MeanEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static decimal MeanEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += (double)function(list._items[i]);
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += (double)function(array[i]);
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += (double)function(list2[i]);
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += (double)function(item);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += (double)function(item, i);
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += (double)function(item, i);
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += (double)function(item, i);
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += (double)function(item, i);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += (double)function(list._items[i]);
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += (double)function(array[i]);
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += (double)function(list2[i]);
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += (double)function(item);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += (double)function(item, i);
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += (double)function(item, i);
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += (double)function(item, i);
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += (double)function(item, i);
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static decimal MeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is decimal[] array)
		{
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += (double)item;
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is double[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += (double)item;
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += (double)item;
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += (double)item;
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is int[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is uint[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is long[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static double MeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += (double)item;
			}
			return result / Math.Max(list._size, 1);
		}
		else if (source is mpz_t[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += (double)item;
			}
			return result / Math.Max(array.Length, 1);
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += (double)item;
			}
			return result / Math.Max(list2.Count, 1);
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += (double)item;
				i++;
			}
			return result / Math.Max(i, 1);
		}
	}

	internal static decimal MedianEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static decimal MedianEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static double MedianEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static double MedianEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static int MedianEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static int MedianEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static uint MedianEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static uint MedianEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static long MedianEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static long MedianEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static mpz_t MedianEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static mpz_t MedianEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else
			return CreateVar(ConvertEnumerable(source, function), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static decimal MedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
			return list._size == 0 ? 0 : new List<decimal>(list).Sort()._items[(list._size - 1) / 2];
		else return source is decimal[] array
			? array.Length == 0 ? 0 : new List<decimal>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<decimal> list2
			? list2.Count == 0 ? 0 : new List<decimal>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<decimal>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static double MedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
			return list._size == 0 ? 0 : new List<double>(list).Sort()._items[(list._size - 1) / 2];
		else return source is double[] array
			? array.Length == 0 ? 0 : new List<double>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<double> list2
			? list2.Count == 0 ? 0 : new List<double>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<double>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static int MedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
			return list._size == 0 ? 0 : new List<int>(list).Sort()._items[(list._size - 1) / 2];
		else return source is int[] array
			? array.Length == 0 ? 0 : new List<int>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<int> list2
			? list2.Count == 0 ? 0 : new List<int>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<int>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static uint MedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
			return list._size == 0 ? 0 : new List<uint>(list).Sort()._items[(list._size - 1) / 2];
		else return source is uint[] array
			? array.Length == 0 ? 0 : new List<uint>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<uint> list2
			? list2.Count == 0 ? 0 : new List<uint>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<uint>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static long MedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
			return list._size == 0 ? 0 : new List<long>(list).Sort()._items[(list._size - 1) / 2];
		else return source is long[] array
			? array.Length == 0 ? 0 : new List<long>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<long> list2
			? list2.Count == 0 ? 0 : new List<long>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<long>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static mpz_t MedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
			return list._size == 0 ? 0 : new List<mpz_t>(list).Sort()._items[(list._size - 1) / 2];
		else return source is mpz_t[] array
			? array.Length == 0 ? 0 : new List<mpz_t>(array).Sort()._items[(array.Length - 1) / 2]
			: source is G.IList<mpz_t> list2
			? list2.Count == 0 ? 0 : new List<mpz_t>(list2).Sort()._items[(list2.Count - 1) / 2]
			: CreateVar(new List<mpz_t>(source), out var col).Length == 0 ? 0 : col.Sort()._items[(col.Length - 1) / 2];
	}

	internal static TResult? MedianEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? default : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? default : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? default : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else return TryGetLengthEasilyEnumerable(source, out var length)
			? length == 0 ? default : ConvertEnumerable(source, function).Sort()._items[(length - 1) / 2]
			: MedianEnumerable(new List<T>(source), function);
	}

	internal static TResult? MedianEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			return list._size == 0 ? default : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			return array.Length == 0 ? default : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			return list2.Count == 0 ? default : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else return TryGetLengthEasilyEnumerable(source, out var length)
			? length == 0 ? default : ConvertEnumerable(source, function).Sort()._items[(length - 1) / 2]
			: MedianEnumerable(new List<T>(source), function);
	}

	internal static T? MedianEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
			return list._size == 0 ? default : new List<T>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is T[] array)
			return array.Length == 0 ? default : new List<T>(array).Sort()._items[(array.Length - 1) / 2];
		else return source is G.IList<T> list2
			? list2.Count == 0 ? default : new List<T>(list2).Sort()._items[(list2.Count - 1) / 2]
			: TryGetLengthEasilyEnumerable(source, out var length)
			? length == 0 ? default : new List<T>(source).Sort()._items[(length - 1) / 2]
			: MedianEnumerable(new List<T>(source));
	}

	internal static decimal MinEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MinEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MinEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MinEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is T[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is decimal[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is double[] array)
		{
			double indicator = 0;
			double f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			double indicator = 0;
			double f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is int[] array)
		{
			var indicator = 0;
			int f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var indicator = 0;
			int f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			var indicator = 0;
			int f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is uint[] array)
		{
			uint indicator = 0;
			uint f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			uint indicator = 0;
			uint f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is long[] array)
		{
			long indicator = 0;
			long f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			long indicator = 0;
			long f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is mpz_t[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			var i = 0;
			foreach (var item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static List<TResult> OfTypeEnumerable<TResult>(IEnumerable source)
	{
		List<TResult> result = new();
		foreach (var item in source)
			if (item is TResult resultElement)
				result.Add(resultElement);
		return result;
	}

	internal static T? ProgressionEnumerable(IEnumerable<T> source, Func<T, T, T> function)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			T? result = default;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else if (source is T[] array)
		{
			T? result = default;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			T? result = default;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result = result == null || i == 0 ? item : function(result, item);
			}
			return result;
		}
		else
		{
			T? result = default;
			var i = 0;
			foreach (var item in source)
			{
				result = result == null || i == 0 ? item : function(result, item);
				i++;
			}
			return result;
		}
	}

	internal static TResult? ProgressionEnumerable<TResult>(IEnumerable<T> source, TResult seed, Func<TResult, T, TResult> function)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			var result = seed;
			for (var i = 0; i < length; i++)
				result = function(result, list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			var result = seed;
			for (var i = 0; i < array.Length; i++)
				result = function(result, array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = seed;
			for (var i = 0; i < length; i++)
				result = function(result, list2[i]);
			return result;
		}
		else
		{
			var result = seed;
			var i = 0;
			foreach (var item in source)
			{
				result = function(result, item);
				i++;
			}
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source)
	{
		FastDelHashSet<T> hs = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		FastDelHashSet<T> hs = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static List<T> RemoveDoublesEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(1024);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				if (hs.TryAdd(item))
					result.Add(item);
			}
			result.TrimExcess();
			return result;
		}
		else
		{
			List<T> result = new(1024);
			var i = 0;
			foreach (var item in source)
			{
				if (hs.TryAdd(item))
					result.Add(item);
				i++;
			}
			result.TrimExcess();
			return result;
		}
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new();
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new();
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		FastDelHashSet<T> hs = new();
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2));
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, comparer);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(comparer);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, comparer);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, IEqualityComparer<T> comparer)
	{
		FastDelHashSet<T> hs = new(comparer);
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), comparer);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), equalFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction, hashCodeFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction, hashCodeFunction);
	}

	internal static (List<T>, List<T2>) RemoveDoublesEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Math.Min(list._size, list2._size);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Math.Min(array.Length, array2.Length);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Math.Min(list2_.Count, list2_2.Count);
			List<T> result = new(length);
			List<T2> result2 = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), equalFunction, hashCodeFunction);
	}

	internal static List<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source)
	{
		ListHashSet<T> dic = new();
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<int> RepresentIntoNumbersEnumerable(IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		if (source is List<T> list)
		{
			var length = list._size;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<int> result = new(array.Length);
			var j = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<int> result = new(length);
			var j = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
			}
			result._size = length;
			return result;
		}
		else
		{
			List<int> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var j = 0;
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<T> ReverseEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
		{
			var length = list._size;
			List<T> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result._items[^(i + 1)] = item;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			List<T> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[^(i + 1)] = item;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			List<T> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[^(i + 1)] = item;
			}
			result._size = length;
			return result;
		}
		else
		{
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var length) ? length : 0);
			var i = 0;
			foreach (var item in source)
			{
				result._items[^(i + 1)] = item;
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value)
	{
		if (source is List<T> list)
			return list.SetAll(value);
		else
		{
			for (var i = 0; i < source.Count; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, Index index)
	{
		if (source is List<T> list)
			return list.SetAll(value, index);
		else
		{
			for (var i = index.GetOffset(source.Count); i < source.Count; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, int index)
	{
		if (source is List<T> list)
			return list.SetAll(value, index);
		else
		{
			for (var i = index; i < source.Count; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, int index, int length)
	{
		if (source is List<T> list)
			return list.SetAll(value, index, length);
		else
		{
			var endIndex = index + length;
			for (var i = index; i < endIndex; i++)
				source[i] = value;
			return source;
		}
	}

	internal static G.IList<T> SetAllEnumerable(G.IList<T> source, T value, Range range)
	{
		if (source is List<T> list)
			return list.SetAll(value, range);
		else
		{
			var (startIndex, length) = range.GetOffsetAndLength(source.Count);
			for (var i = startIndex; i < startIndex + length; i++)
				source[i] = value;
			return source;
		}
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source)
	{
		List<TResult> result = new();
		foreach (var item in source)
			result.Add((TResult)item);
		return result;
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source, Func<object?, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is ArrayList list)
		{
			var length = list.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list[i]);
			result._size = length;
			return result;
		}
		else if (source is BitArray bitArray)
		{
			List<TResult> result = new(bitArray.Length);
			for (var i = 0; i < bitArray.Length; i++)
				result._items[i] = function(bitArray[i]);
			result._size = bitArray.Length;
			return result;
		}
		else if (source is System.Collections.IList list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<TResult> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<TResult> result = new();
			var i = 0;
			foreach (var item in source)
			{
				result.Add(function(item));
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source, Func<object?, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is ArrayList list)
		{
			var length = list.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list[i], i);
			result._size = length;
			return result;
		}
		else if (source is BitArray bitArray)
		{
			List<TResult> result = new(bitArray.Length);
			for (var i = 0; i < bitArray.Length; i++)
				result._items[i] = function(bitArray[i], i);
			result._size = bitArray.Length;
			return result;
		}
		else if (source is System.Collections.IList list2)
		{
			var length = list2.Count;
			List<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i], i);
			result._size = length;
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			List<TResult> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = i;
			return result;
		}
		else
		{
			List<TResult> result = new();
			var i = 0;
			foreach (var item in source)
			{
				result.Add(function(item, i));
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static Slice<T> SkipEnumerable(IEnumerable<T> source, int length)
	{
		if (source is List<T> list)
			return list.Skip(length);
		else if (length <= 0)
			return new(source.ToList());
		else
		{
			var en = source.GetEnumerator();
			for (var i = 0; i < length; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new(TryGetLengthEasilyEnumerable(source, out var count2) ? Math.Max(count2 - length, 0) : 1024);
			while (en.MoveNext())
				result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipLastEnumerable(IEnumerable<T> source, int length)
	{
		if (source is List<T> list)
			return list.SkipLast(length);
		else if (length <= 0)
			return new(source.ToList());
		else if (TryGetLengthEasilyEnumerable(source, out var count2))
		{
			var end = Math.Max(count2 - length, 0);
			List<T> result = new(end);
			var en = source.GetEnumerator();
			var i = 0;
			for (; i < end && en.MoveNext(); i++)
				result._items[i] = en.Current;
			result._size = i;
			return result.GetSlice();
		}
		else
		{
			List<T> result = new();
			LimitedQueue<T> queue = new(length);
			var en = source.GetEnumerator();
			while (en.MoveNext())
				queue.Enqueue(en.Current, result);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is List<T> list)
			return list.SkipWhile(function);
		else
		{
			List<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is List<T> list)
			return list.SkipWhile(function);
		else
		{
			List<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current, i); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static List<List<T>> SplitIntoEqualEnumerable(IEnumerable<T> source, int fragmentLength)
	{
		if (fragmentLength <= 0)
			throw new ArgumentException(null, nameof(fragmentLength));
		if (source is List<T> list)
		{
			var length = GetArrayLength(list._size, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = list._size / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list._items[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = list._size % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = list._items[index++];
				result._items[count2]._size = rest;
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			var length = GetArrayLength(array.Length, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = array.Length / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = array[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = array.Length % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = array[index++];
				result._items[count2]._size = rest;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = GetArrayLength(list2.Count, fragmentLength);
			List<List<T>> result = new(length);
			var count2 = list2.Count / fragmentLength;
			var index = 0;
			for (var i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (var j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list2[index++];
				result._items[i]._size = fragmentLength;
			}
			var rest = list2.Count % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (var j = 0; j < rest; j++)
					result._items[count2]._items[j] = list2[index++];
				result._items[count2]._size = rest;
			}
			result._size = length;
			return result;
		}
		else
		{
			if (!source.Any())
				return new();
			List<List<T>> result = new(64);
			int i = 0, j = 0, k = 0;
			result.Add(new(fragmentLength));
			foreach (var item in source)
			{
				result._items[j]._items[k++] = item;
				if (k >= fragmentLength)
				{
					result._items[j++]._size = fragmentLength;
					result.Add(new(fragmentLength));
					k = 0;
				}
				i++;
			}
			if (k != 0)
				result._items[j]._size = k;
			return result;
		}
	}

	internal static bool StartsWithEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size < list2._size)
				return false;
			var length = list2._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length < array2.Length)
				return false;
			for (var i = 0; i < array2.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count < list2_2.Count)
				return false;
			var length = list2_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else
		{
			bool b2;
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			while (en.MoveNext() & (b2 = en2.MoveNext()))
			{
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2))
					return false;
			}
			return !b2;
		}
	}

	internal static bool StartsWithEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size < list2._size)
				return false;
			var length = list2._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length < array2.Length)
				return false;
			for (var i = 0; i < array2.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count < list2_2.Count)
				return false;
			var length = list2_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else
		{
			bool b2;
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			var i = 0;
			while (en.MoveNext() & (b2 = en2.MoveNext()))
			{
				var item = en.Current;
				var item2 = en2.Current;
				if (!function(item, item2, i))
					return false;
				i++;
			}
			return !b2;
		}
	}

	internal static bool StartsWithEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2)
	{
		if (source is List<T> list && source2 is List<T2> list2)
		{
			if (list._size < list2._size)
				return false;
			var length = list2._size;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				var item2 = list2._items[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			if (array.Length < array2.Length)
				return false;
			for (var i = 0; i < array2.Length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			if (list2_.Count < list2_2.Count)
				return false;
			var length = list2_2.Count;
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return true;
		}
		else
		{
			bool b2;
			var en = source.GetEnumerator();
			var en2 = source2.GetEnumerator();
			while (en.MoveNext() & (b2 = en2.MoveNext()))
			{
				var item = en.Current;
				var item2 = en2.Current;
				if (!(item?.Equals(item2) ?? item2 == null))
					return false;
			}
			return !b2;
		}
	}

	internal static decimal SumEnumerable(IEnumerable<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static decimal SumEnumerable(IEnumerable<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			var result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else
		{
			var result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			var result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			uint result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			uint result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			uint result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else
		{
			uint result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			uint result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			uint result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			long result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			long result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			long result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else
		{
			long result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			long result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			long result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static mpz_t SumEnumerable(IEnumerable<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			mpz_t result = 0;
			for (var i = 0; i < length; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			mpz_t result = 0;
			for (var i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			mpz_t result = 0;
			for (var i = 0; i < length; i++)
				result += function(list2[i]);
			return result;
		}
		else
		{
			mpz_t result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
	}

	internal static mpz_t SumEnumerable(IEnumerable<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			mpz_t result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			mpz_t result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			mpz_t result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else
		{
			mpz_t result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
	}

	internal static decimal SumEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			var length = list._size;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			decimal result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			var length = list2.Count;
			decimal result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			decimal result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			var length = list._size;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is double[] array)
		{
			double result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			var length = list2.Count;
			double result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			double result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			var length = list._size;
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is int[] array)
		{
			var result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			var length = list2.Count;
			var result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			var result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			var length = list._size;
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is uint[] array)
		{
			uint result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			var length = list2.Count;
			uint result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			uint result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			var length = list._size;
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is long[] array)
		{
			long result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			var length = list2.Count;
			long result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			long result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static mpz_t SumEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			var length = list._size;
			mpz_t result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			mpz_t result = 0;
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			var length = list2.Count;
			mpz_t result = 0;
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			mpz_t result = 0;
			var i = 0;
			foreach (var item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static Slice<T> TakeEnumerable(IEnumerable<T> source, int length)
	{
		if (length <= 0)
			return new();
		else if (source is List<T> list)
			return list.Take(length);
		else
		{
			List<T> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i++] = item;
				if (i >= length)
					break;
			}
			result._size = i;
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeEnumerable(IEnumerable<T> source, Range range)
	{
		if (source is List<T> list)
		{
			var start = Clamp(range.Start.GetOffset(list.Length), 0, list.Length);
			var end = Clamp(range.End.GetOffset(list.Length), 0, list.Length);
			return start >= end ? new() : list.GetSlice(start, end - start);
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var start = Clamp(range.Start.GetOffset(length), 0, length);
			var end = Clamp(range.End.GetOffset(length), 0, length);
			if (start >= end)
				return new();
			List<T> result = new(end - start);
			var i = 0;
			foreach (var item in source)
			{
				if (i >= start)
					result._items[i - start] = item;
				i++;
				if (i >= end)
					break;
			}
			result._size = end - start;
			return result.GetSlice();
		}
		int index = range.Start.Value, index2 = range.End.Value;
		var en = source.GetEnumerator();
		if (!range.Start.IsFromEnd && !range.End.IsFromEnd)
		{
			if (index >= index2)
				return new();
			var i = 0;
			for (; i < index; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new(index2 - index);
			for (; i < index2 && en.MoveNext(); i++)
				result._items[i - index] = en.Current;
			result._size = i - index;
			return result.GetSlice();
		}
		else if (!range.Start.IsFromEnd && range.End.IsFromEnd)
		{
			var i = 0;
			for (; i < index; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new();
			LimitedQueue<T> queue = new(index2);
			while (en.MoveNext())
				queue.Enqueue(en.Current, result);
			return result.GetSlice();
		}
		else if (range.Start.IsFromEnd && !range.End.IsFromEnd)
		{
			LimitedQueue<T> queue = new(index);
			var i = 0;
			while (en.MoveNext())
			{
				queue.Enqueue(en.Current);
				i++;
				if (i >= index + index2)
					return new();
			}
			List<T> result = new(Math.Min(index + index2 - i, i));
			for (i = 0; i < result._items.Length; i++)
				result._items[i] = queue.Dequeue();
			result._size = result._items.Length;
			return result.GetSlice();
		}
		else if (range.Start.IsFromEnd && range.End.IsFromEnd)
		{
			LimitedQueue<T> queue = new(index);
			while (en.MoveNext())
				queue.Enqueue(en.Current);
			if (queue.Length <= index2)
				return new();
			List<T> result = new(queue.Length - index2);
			for (var i = 0; i < result._items.Length; i++)
				result._items[i] = queue.Dequeue();
			result._size = result._items.Length;
			return result.GetSlice();
		}
		else
			return new();
	}

	internal static Slice<T> TakeLastEnumerable(IEnumerable<T> source, int length)
	{
		if (length <= 0)
			return new();
		else if (source is List<T> list)
			return list.TakeLast(length);
		else if (TryGetLengthEasilyEnumerable(source, out var count2))
		{
			var start = Math.Max(count2 - length, 0);
			var en = source.GetEnumerator();
			var i = 0;
			for (; i < start; i++)
				if (!en.MoveNext())
					return new();
			List<T> result = new(Math.Min(length, count2));
			for (i = 0; i < result._items.Length && en.MoveNext(); i++)
				result._items[i] = en.Current;
			result._size = result._items.Length;
			return result.GetSlice();
		}
		else
		{
			LimitedQueue<T> queue = new(length);
			var en = source.GetEnumerator();
			while (en.MoveNext())
				queue.Enqueue(en.Current);
			return queue.ToList().GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is List<T> list)
			return list.TakeWhile(function);
		else
		{
			List<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is List<T> list)
			return list.TakeWhile(function);
		else
		{
			List<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current, i); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static TResult[] ToArrayEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
				result[i] = function(list._items[i]);
			return result;
		}
		else if (source is T[] array)
		{
			var result = new TResult[array.Length];
			for (var i = 0; i < array.Length; i++)
				result[i] = function(array[i]);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
				result[i] = function(list2[i]);
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var result = new TResult[length];
			var i = 0;
			foreach (var item in source)
			{
				result[i] = function(item);
				i++;
			}
			return result;
		}
		else
			return ToArrayEnumerable(new List<T>(source), function);
	}

	internal static TResult[] ToArrayEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list._size;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
			{
				var item = list._items[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is T[] array)
		{
			var result = new TResult[array.Length];
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = new TResult[length];
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var result = new TResult[length];
			var i = 0;
			foreach (var item in source)
			{
				result[i] = function(item, i);
				i++;
			}
			return result;
		}
		else
			return ToArrayEnumerable(new List<T>(source), function);
	}

	internal static T[] ToArrayEnumerable(IEnumerable<T> source)
	{
		if (source is List<T> list)
			return list.ToArray();
		else if (source is T[] array)
		{
			var result = new T[array.Length];
			Array.Copy(array, result, array.Length);
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			var result = new T[length];
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result[i] = item;
			}
			return result;
		}
		else if (TryGetLengthEasilyEnumerable(source, out var length))
		{
			var result = new T[length];
			var i = 0;
			foreach (var item in source)
			{
				result[i] = item;
				i++;
			}
			return result;
		}
		else
			return new List<T>(source).ToArray();
	}

	internal static bool TryGetLengthEasilyEnumerable(IEnumerable<T> source, out int length)
	{
		try
		{
			if (source is G.ICollection<T> col)
			{
				length = col.Count;
				return length >= 0;
			}
			else if (source is G.IReadOnlyCollection<T> col2)
			{
				length = col2.Count;
				return length >= 0;
			}
			else if (source is System.Collections.ICollection col3)
			{
				length = col3.Count;
				return length >= 0;
			}
			else if (source is string s)
			{
				length = s.Length;
				return length >= 0;
			}
			else if (CreateVar(Assembly.Load("System.Linq").GetType("System.Linq.IIListProvider`1")?.MakeGenericType(typeof(T)) ?? throw new InvalidOperationException(), out var targetType).IsInstanceOfType(source) && targetType.GetMethod("GetCount")?.Invoke(source, new object[] { true }) is int n)
			{
				length = n;
				return length >= 0;
			}
		}
		catch
		{
		}
		length = -1;
		return false;
	}

	internal static bool TryGetLengthEasilyEnumerable(IEnumerable source, out int length)
	{
		try
		{
			if (source is System.Collections.ICollection col)
			{
				length = col.Count;
				return length >= 0;
			}
			else if (source is string s)
			{
				length = s.Length;
				return length >= 0;
			}
		}
		catch
		{
		}
		length = -1;
		return false;
	}

	internal static bool TryWrapEnumerable(IEnumerable<T> source, Func<IEnumerable<T>, List<T>> function, out List<T>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TResult>(IEnumerable<T> source, Func<IEnumerable<T>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool TryWrapEnumerable(List<T> source, Func<List<T>, List<T>> function, out List<T>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TResult>(List<T> source, Func<List<T>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool TryWrapEnumerable(T[] source, Func<T[], List<T>> function, out List<T>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TResult>(T[] source, Func<T[], TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool TryWrapEnumerable(G.IList<T> source, Func<G.IList<T>, List<T>> function, out List<T>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TResult>(G.IList<T> source, Func<G.IList<T>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool AllEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i]))
				return false;
		return true;
	}

	internal static bool AllEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i], i))
				return false;
		return true;
	}

	internal static bool AnyEnumerable(ReadOnlySpan<T> source)
	{
		var length = source.Length;
		return length != 0;
	}

	internal static bool AnyEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				return true;
		return false;
	}

	internal static bool AnyEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				return true;
		return false;
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<T>, List<T2>) BreakEnumerable<T2>(ReadOnlySpan<(T, T2)> source)
	{
		var length = source.Length;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<T>, List<T2>, List<T3>) BreakEnumerable<T2, T3>(ReadOnlySpan<(T, T2, T3)> source)
	{
		var length = source.Length;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		List<T3> result3 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static List<T> BreakFilterEnumerable(ReadOnlySpan<T> source, Func<T, bool> function, out List<T> result2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(length / 2);
		result2 = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				result.Add(item);
			else
				result2.Add(item);
		}
		result.TrimExcess();
		result2.TrimExcess();
		return result;
	}

	internal static List<T> BreakFilterEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function, out List<T> result2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(length / 2);
		result2 = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				result.Add(item);
			else
				result2.Add(item);
		}
		result.TrimExcess();
		result2.TrimExcess();
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Math.Min(source.Length, source2.Length);
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Math.Min(source.Length, source2.Length);
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], i);
		result._size = length;
		return result;
	}

	internal static List<(T, T2)> CombineEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2)
	{
		var length = Math.Min(source.Length, source2.Length);
		List<(T, T2)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> CombineEnumerable<T2, T3, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i], i);
		result._size = length;
		return result;
	}

	internal static List<(T, T2, T3)> CombineEnumerable<T2, T3>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3)
	{
		var length = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<(T, T2, T3)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> ConvertEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i]);
		result._size = length;
		return result;
	}

	internal static List<TResult> ConvertEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], i);
		result._size = length;
		return result;
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source[i]));
		return result;
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source[i], i));
		return result;
	}

	internal static int CountEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				result++;
		return result;
	}

	internal static int CountEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				result++;
		return result;
	}

	internal static int CountEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				result++;
		return result;
	}

	internal static bool EqualsEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source.Length != source2.Length)
			return false;
		var length = Math.Min(source.Length, source2.Length);
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i]))
				return false;
		return true;
	}

	internal static bool EqualsEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source.Length != source2.Length)
			return false;
		var length = Math.Min(source.Length, source2.Length);
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i], i))
				return false;
		return true;
	}

	internal static bool EqualsEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2)
	{
		if (source.Length != source2.Length)
			return false;
		var length = Math.Min(source.Length, source2.Length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (item == null || !item.Equals(source2[i]))
				return false;
		}
		return true;
	}

	internal static List<T> FilterEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FilterEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static T? FindEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				return item;
		}
		return default;
	}

	internal static T? FindEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				return item;
		}
		return default;
	}

	internal static List<T> FindAllEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (function(item, i))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<T> FindAllMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<T> FindAllMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result.Add(item);
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> FindAllMinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<T> result = new(1024);
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result.Add(item);
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result.Clear();
			}
			else if (f == indicator!)
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindIndexesEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int FindIndexEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i]))
				return i;
		return -1;
	}

	internal static int FindIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (function(source[i], i))
				return i;
		return -1;
	}

	internal static int FindLastIndexEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
			if (function(source[i]))
				return i;
		return -1;
	}

	internal static int FindLastIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
			if (function(source[i], i))
				return i;
		return -1;
	}

	internal static T? FindLastEnumerable(ReadOnlySpan<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (function(item))
				return item;
		}
		return default;
	}

	internal static T? FindLastEnumerable(ReadOnlySpan<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (function(item, i))
				return item;
		}
		return default;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindLastMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindLastMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindLastMinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static T? FindMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static T? FindMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static T? FindMinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		T? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (int)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (uint)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (long)value;
		return value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MeanEnumerable(source, function);
		var value2 = (mpz_t)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static void ForEachEnumerable(ReadOnlySpan<T> source, Action<T> action)
	{
		if (action == null)
			throw new ArgumentNullException(nameof(action));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			action(source[i]);
	}

	internal static void ForEachEnumerable(ReadOnlySpan<T> source, Action<T, int> action)
	{
		if (action == null)
			throw new ArgumentNullException(nameof(action));
		var length = source.Length;
		for (var i = 0; i < length; i++)
			action(source[i], i);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i]), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i], i), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(ReadOnlySpan<T> source)
	{
		ListHashSet<T> dic = new();
		var length = source.Length;
		List<(T Key, int Count)> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = source[i], out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i]), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i], i), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<(T Key, int Count)> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = source[i], out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i]), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<(TResult Key, int Count)> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = function(source[i], i), out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(T Key, int Count)> FrequencyTableEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<(T Key, int Count)> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			if (!dic.TryAdd(f = source[i], out var index))
				result._items[index].Count++;
			else
				result._items[j++] = (f, 1);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source)
	{
		ListHashSet<T> dic = new();
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, TResult>> GroupEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<T, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<T, T>> GroupEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<T, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(item);
			else
				result._items[j++] = new((List<T>)item, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new();
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source)
	{
		ListHashSet<T> dic = new();
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(comparer);
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source, IEqualityComparer<T> comparer)
	{
		ListHashSet<T> dic = new(comparer);
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, TResult>> GroupIndexesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		ListHashSet<TResult> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<int, TResult>> result = new(length);
		var j = 0;
		TResult f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = function(item, i), out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<int, T>> GroupIndexesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<Group<int, T>> result = new(length);
		var j = 0;
		T f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (!dic.TryAdd(f = item, out var index))
				result._items[index].Add(i);
			else
				result._items[j++] = new((List<int>)i, f);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		List<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return List<decimal>.IndexesOfEnumerable(list_, value);
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return List<decimal>.IndexesOfEnumerable(list_, value);
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return List<double>.IndexesOfEnumerable(list_, value);
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		return List<double>.IndexesOfEnumerable(list_, value);
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (int)value;
		return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (int)value;
		return value == value2 ? List<int>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (long)value;
		return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (long)value;
		return value == value2 ? List<long>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (mpz_t)value;
		return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (mpz_t)value;
		return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var value = MeanEnumerable(source);
		return List<decimal>.IndexesOfEnumerable(source, value);
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		var value = MeanEnumerable(source);
		return List<double>.IndexesOfEnumerable(source, value);
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (int)value;
		return value == value2 ? List<int>.IndexesOfEnumerable(source, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.IndexesOfEnumerable(source, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (long)value;
		return value == value2 ? List<long>.IndexesOfEnumerable(source, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (mpz_t)value;
		return value2 == null ? new() : value == value2 ? List<mpz_t>.IndexesOfEnumerable(source, value2) : new();
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<decimal>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<double>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<int>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<uint>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<long>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<mpz_t>.IndexesOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<decimal> source)
	{
		return List<decimal>.IndexesOfEnumerable(source, MedianEnumerable(source));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<double> source)
	{
		return List<double>.IndexesOfEnumerable(source, MedianEnumerable(source));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<int> source)
	{
		return List<int>.IndexesOfEnumerable(source, MedianEnumerable(source));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<uint> source)
	{
		return List<uint>.IndexesOfEnumerable(source, MedianEnumerable(source));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<long> source)
	{
		return List<long>.IndexesOfEnumerable(source, MedianEnumerable(source));
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<mpz_t> source)
	{
		return List<mpz_t>.IndexesOfEnumerable(source, MedianEnumerable(source));
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		decimal indicator = 0;
		var j = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		double indicator = 0;
		var j = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		var indicator = 0;
		var j = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		uint indicator = 0;
		var j = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		long indicator = 0;
		var j = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		List<int> result = new(length);
		mpz_t indicator = 0;
		var j = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
				j++;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int IndexOfEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				return i;
		return -1;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (int)value;
		return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (int)value;
		return value == value2 ? List<int>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (long)value;
		return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (long)value;
		return value == value2 ? List<long>.IndexOfEnumerable(list_, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (mpz_t)value;
		return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (mpz_t)value;
		return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(list_, value2) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<decimal>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<double>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (int)value;
		return value == value2 ? List<int>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (long)value;
		return value == value2 ? List<long>.IndexOfEnumerable(source, value2) : -1;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (mpz_t)value;
		return value2 == null ? -1 : value == value2 ? List<mpz_t>.IndexOfEnumerable(source, value2) : default;
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<decimal>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<double>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<int>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<uint>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<long>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<mpz_t>.IndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<decimal> source)
	{
		return List<decimal>.IndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<double> source)
	{
		return List<double>.IndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<int> source)
	{
		return List<int>.IndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<uint> source)
	{
		return List<uint>.IndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<long> source)
	{
		return List<long>.IndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<mpz_t> source)
	{
		return List<mpz_t>.IndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<List<T>> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source) where TSource : IEnumerable<TResult>
	{
		var length = source.Length;
		List<TResult> result = new(1024);
		for (var i = 0; i < length; i++)
			result.AddRange(source[i]);
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<T[]> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<G.IList<T>> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<T> JoinIntoSingleEnumerable(ReadOnlySpan<IEnumerable<T>> source)
	{
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static int LastIndexOfEnumerable(ReadOnlySpan<T> source, T target)
	{
		var length = source.Length;
		for (var i = 0; i < length; i++)
			if (source[i]?.Equals(target) ?? false)
				return i;
		return -1;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<decimal>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = value;
		return value == value2 ? List<double>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (int)value;
		return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (int)value;
		return value == value2 ? List<int>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (long)value;
		return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (long)value;
		return value == value2 ? List<long>.LastIndexOfEnumerable(list_, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (mpz_t)value;
		return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		var value = MeanEnumerable(list_);
		var value2 = (mpz_t)value;
		return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(list_, value2) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<decimal>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		var value = MeanEnumerable(source);
		var value2 = value;
		return value == value2 ? List<double>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (int)value;
		return value == value2 ? List<int>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (uint)value;
		return value == value2 ? List<uint>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (long)value;
		return value == value2 ? List<long>.LastIndexOfEnumerable(source, value2) : -1;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var value = MeanEnumerable(source);
		var value2 = (mpz_t)value;
		return value2 == null ? -1 : value == value2 ? List<mpz_t>.LastIndexOfEnumerable(source, value2) : default;
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<decimal>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<double>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<int>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<uint>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<long>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var list_ = ConvertEnumerable(source, function);
		return List<mpz_t>.LastIndexOfEnumerable(list_, MedianEnumerable(list_));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<decimal> source)
	{
		return List<decimal>.LastIndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<double> source)
	{
		return List<double>.LastIndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<int> source)
	{
		return List<int>.LastIndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<uint> source)
	{
		return List<uint>.LastIndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<long> source)
	{
		return List<long>.LastIndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<mpz_t> source)
	{
		return List<mpz_t>.LastIndexOfEnumerable(source, MedianEnumerable(source));
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		var result = -1;
		decimal indicator = 0;
		decimal f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		var result = -1;
		double indicator = 0;
		double f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = -1;
		var indicator = 0;
		int f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		var result = -1;
		uint indicator = 0;
		uint f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		var result = -1;
		long indicator = 0;
		long f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		var result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = length - 1; i >= 0; i--)
		{
			var item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MaxEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MaxEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += (double)function(source[i], i);
		return result / source.Length;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += (double)item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += (double)item;
		}
		return result / source.Length;
	}

	internal static decimal MedianEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static decimal MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static double MedianEnumerable(ReadOnlySpan<T> source, Func<T, double> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static double MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static int MedianEnumerable(ReadOnlySpan<T> source, Func<T, int> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static int MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static uint MedianEnumerable(ReadOnlySpan<T> source, Func<T, uint> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static uint MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static long MedianEnumerable(ReadOnlySpan<T> source, Func<T, long> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static long MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? default : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static mpz_t MedianEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? 0 : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static mpz_t MedianEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => function == null
			? throw new ArgumentNullException(nameof(function))
			: source.Length == 0 ? 0 : ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];

	internal static decimal MedianEnumerable(ReadOnlySpan<decimal> source) => source.Length == 0 ? default : new List<decimal>(source).Sort()[(source.Length - 1) / 2];

	internal static double MedianEnumerable(ReadOnlySpan<double> source) => source.Length == 0 ? default : new List<double>(source).Sort()[(source.Length - 1) / 2];

	internal static int MedianEnumerable(ReadOnlySpan<int> source) => source.Length == 0 ? default : new List<int>(source).Sort()[(source.Length - 1) / 2];

	internal static uint MedianEnumerable(ReadOnlySpan<uint> source) => source.Length == 0 ? default : new List<uint>(source).Sort()[(source.Length - 1) / 2];

	internal static long MedianEnumerable(ReadOnlySpan<long> source) => source.Length == 0 ? default : new List<long>(source).Sort()[(source.Length - 1) / 2];

	internal static mpz_t MedianEnumerable(ReadOnlySpan<mpz_t> source) => source.Length == 0 ? 0 : new List<mpz_t>(source).Sort()[(source.Length - 1) / 2];

	internal static T? MedianEnumerable(ReadOnlySpan<T> source) => source.Length == 0 ? default : new List<T>(source).Sort()[(source.Length - 1) / 2];

	internal static decimal MinEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MinEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MinEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MinEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MinEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		decimal indicator = 0;
		decimal f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		double indicator = 0;
		double f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var indicator = 0;
		int f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		uint indicator = 0;
		uint f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		long indicator = 0;
		long f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static T? ProgressionEnumerable(ReadOnlySpan<T> source, Func<T, T, T> function)
	{
		var length = source.Length;
		T? result = default;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result = result == null ? item : function(result, item);
		}
		return result;
	}

	internal static TResult? ProgressionEnumerable<TResult>(ReadOnlySpan<T> source, TResult seed, Func<TResult, T, TResult> function)
	{
		var length = source.Length;
		TResult? result = default;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result = result == null ? seed : function(result, item);
		}
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable(ReadOnlySpan<T> source)
	{
		FastDelHashSet<T> hs = new(EqualityComparer<T>.Default);
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<T> RemoveDoublesEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<T> result = new(1024);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result.TrimExcess();
		return result;
	}

	internal static List<int> RepresentIntoNumbersEnumerable(ReadOnlySpan<T> source)
	{
		ListHashSet<T> dic = new();
		var length = source.Length;
		List<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static List<int> RepresentIntoNumbersEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source.Length;
		List<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static List<int> RepresentIntoNumbersEnumerable(ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source.Length;
		List<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static List<T> ReverseEnumerable(ReadOnlySpan<T> source)
	{
		var length = source.Length;
		List<T> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[^(i + 1)] = source[i];
		result._size = length;
		return result;
	}

	internal static Span<T> SetAllEnumerable(Span<T> source, T value)
	{
		for (var i = 0; i < source.Length; i++)
			source[i] = value;
		return source;
	}

	internal static bool StartsWithEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source.Length < source2.Length)
			return false;
		var length = source2.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i]))
				return false;
		return true;
	}

	internal static bool StartsWithEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source.Length < source2.Length)
			return false;
		var length = source2.Length;
		for (var i = 0; i < length; i++)
			if (!function(source[i], source2[i], i))
				return false;
		return true;
	}

	internal static bool StartsWithEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2)
	{
		if (source.Length < source2.Length)
			return false;
		var length = source2.Length;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			if (item == null || !item.Equals(source2[i]))
				return false;
		}
		return true;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<T> source, Func<T, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<T> source, Func<T, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<T> source, Func<T, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<T> source, Func<T, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<T> source, Func<T, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<T> source, Func<T, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<T> source, Func<T, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		uint result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<T> source, Func<T, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		uint result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<T> source, Func<T, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		long result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<T> source, Func<T, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		long result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static mpz_t SumEnumerable(ReadOnlySpan<T> source, Func<T, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		mpz_t result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i]);
		return result;
	}

	internal static mpz_t SumEnumerable(ReadOnlySpan<T> source, Func<T, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		mpz_t result = 0;
		for (var i = 0; i < length; i++)
			result += function(source[i], i);
		return result;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<decimal> source)
	{
		var length = source.Length;
		decimal result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<double> source)
	{
		var length = source.Length;
		double result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<int> source)
	{
		var length = source.Length;
		var result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<uint> source)
	{
		var length = source.Length;
		uint result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<long> source)
	{
		var length = source.Length;
		long result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static mpz_t SumEnumerable(ReadOnlySpan<mpz_t> source)
	{
		var length = source.Length;
		mpz_t result = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result += item;
		}
		return result;
	}

	internal static TResult[] ToArrayEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = function(source[i]);
		return result;
	}

	internal static TResult[] ToArrayEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		var result = new TResult[length];
		for (var i = 0; i < length; i++)
			result[i] = function(source[i], i);
		return result;
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<T>, List<T2>) PBreakEnumerable<T2>(G.IList<(T, T2)> source)
	{
		var length = source.Count;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, int, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<T>, List<T2>, List<T3>) PBreakEnumerable<T2, T3>(G.IList<(T, T2, T3)> source)
	{
		var length = source.Count;
		List<T> result = new(length);
		List<T2> result2 = new(length);
		List<T3> result3 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i], result3._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<TResult> result = new(length);
		List<TResult2> result2 = new(length);
		List<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static List<TResult> PCombineEnumerable<T2, TResult>(G.IList<T> source, G.IList<T2> source2, Func<T, T2, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Math.Min(source.Count, source2.Count);
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2);
		});
		result._size = length;
		return result;
	}

	internal static List<TResult> PCombineEnumerable<T2, TResult>(G.IList<T> source, G.IList<T2> source2, Func<T, T2, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Math.Min(source.Count, source2.Count);
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2, i);
		});
		result._size = length;
		return result;
	}

	internal static List<(T, T2)> PCombineEnumerable<T2>(G.IList<T> source, G.IList<T2> source2)
	{
		var length = Math.Min(source.Count, source2.Count);
		List<(T, T2)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = (item, item2);
		});
		result._size = length;
		return result;
	}

	internal static List<TResult> PCombineEnumerable<T2, T3, TResult>(G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static List<TResult> PCombineEnumerable<T2, T3, TResult>(G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		List<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3, i);
		});
		result._size = length;
		return result;
	}

	internal static List<(T, T2, T3)> PCombineEnumerable<T2, T3>(G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3)
	{
		var length = MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		List<(T, T2, T3)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = (item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (item?.Equals(target) ?? false)
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target, IEqualityComparer<T> comparer)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static List<TResult> PConvertEnumerable<TResult>(G.IList<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(source[i]));
		result._size = length;
		return result;
	}

	internal static List<TResult> PConvertEnumerable<TResult>(G.IList<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(source[i], i));
		result._size = length;
		return result;
	}

	internal static List<TResult> PFillEnumerable<TResult>(TResult elem, int length)
	{
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = elem);
		result._size = length;
		return result;
	}

	internal static List<TResult> PFillEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		List<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(i));
		result._size = length;
		return result;
	}

	internal static TResult[] PFillArrayEnumerable<TResult>(TResult elem, int length)
	{
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = elem);
		return result;
	}

	internal static TResult[] PFillArrayEnumerable<TResult>(Func<int, TResult> function, int length)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = function(i));
		return result;
	}

	internal static List<T> PFilterEnumerable(G.IList<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i]));
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static List<T> PFilterEnumerable(G.IList<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		List<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i], i));
		List<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static TResult[] PToArrayEnumerable<TResult>(G.IList<T> source, Func<T, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = function(source[i]));
		return result;
	}

	internal static TResult[] PToArrayEnumerable<TResult>(G.IList<T> source, Func<T, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		var result = new TResult[length];
		Parallel.For(0, length, i => result[i] = function(source[i], i));
		return result;
	}

	internal static T[] PToArrayEnumerable(G.IList<T> source)
	{
		var length = source.Count;
		var result = new T[length];
		Parallel.For(0, length, i => result[i] = source[i]);
		return result;
	}

	internal static IEnumerable<TResult> ConvertAndJoin<TCollection, TResult>(IEnumerable<T> source, Func<T, int, IEnumerable<TCollection>> collectionSelector, Func<T, TCollection, int, TResult> resultSelector)
	{
		int i = 0, j = 0;
		return Enumerable.SelectMany(source, x => collectionSelector(x, i++), (x, y) => resultSelector(x, y, j++));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), comparer);
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TKey, TElement>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++));
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), comparer);
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Group<TKey, TElement, TResult>(IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static TResult? Max<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.Max(source, x => function(x, i++));
	}

	internal static TResult? Min<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.Min(source, x => function(x, i++));
	}

	internal static IEnumerable<T> Sort<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++));
	}

	internal static IEnumerable<T> Sort<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer)
	{
		var i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++), comparer);
	}

	internal static IEnumerable<T> Sort<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction)
	{
		var i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++), new Comparer<TResult>(compareFunction));
	}

	internal static IEnumerable<T> SortDesc<TResult>(IEnumerable<T> source, Func<T, int, TResult> function)
	{
		var i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++));
	}

	internal static IEnumerable<T> SortDesc<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer)
	{
		var i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++), comparer);
	}

	internal static IEnumerable<T> SortDesc<TResult>(IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction)
	{
		var i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++), new Comparer<TResult>(compareFunction));
	}
}

public unsafe partial class NList<T>
{
	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<T>, NList<T2>) BreakEnumerable<T2>(IEnumerable<(T, T2)> source) where T2 : unmanaged
	{
		if (source is List<(T, T2)> list)
		{
			var length = list.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is (T, T2)[] array)
		{
			var length = array.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<(T, T2)> list2)
		{
			var length = list2.Count;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<T> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<T2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i]) = item;
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i]) = function(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i]) = function(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			return (result, result2);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<T>, NList<T2>, NList<T3>) BreakEnumerable<T2, T3>(IEnumerable<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		if (source is List<(T, T2, T3)> list)
		{
			var length = list.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is (T, T2, T3)[] array)
		{
			var length = array.Length;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = array[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<(T, T2, T3)> list2)
		{
			var length = list2.Count;
			NList<T> result = new(length);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			for (var i = 0; i < length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list2[i];
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<T> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<T2> result2 = new(length);
			NList<T3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = item;
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is T[] array)
		{
			var length = array.Length;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			NList<TResult2> result2 = new(length);
			NList<TResult3> result3 = new(length);
			var i = 0;
			foreach (var item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
				i++;
			}
			result._size = length;
			result2._size = length;
			result3._size = length;
			return (result, result2, result3);
		}
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<T>, NList<T2>) BreakEnumerable<T2>(ReadOnlySpan<(T, T2)> source) where T2 : unmanaged
	{
		var length = source.Length;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<T>, NList<T2>, NList<T3>) BreakEnumerable<T2, T3>(ReadOnlySpan<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		var length = source.Length;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		NList<T3> result3 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source[i];
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<T>, NList<T2>) BreakEnumerable<T2>(NList<(T, T2)> source) where T2 : unmanaged
	{
		var length = source._size;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i]) = source._items[i];
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TResult, TResult2>(NList<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<T>, NList<T2>, NList<T3>) BreakEnumerable<T2, T3>(NList<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		var length = source._size;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		NList<T3> result3 = new(length);
		for (var i = 0; i < length; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source._items[i];
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TResult, TResult2, TResult3>(NList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Min(list.Length, list2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				var item2 = list2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Min(array.Length, array2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Min(list2_.Count, list2_2.Count);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = function(item, item2);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), function);
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Min(list.Length, list2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				var item2 = list2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Min(array.Length, array2.Length);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Min(list2_.Count, list2_2.Count);
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), function);
	}

	internal static NList<(T, T2)> CombineEnumerable<T2>(IEnumerable<T> source, IEnumerable<T2> source2) where T2 : unmanaged
	{
		if (source is List<T> list && source2 is List<T2> list2)
		{
			var length = Min(list.Length, list2.Length);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				var item2 = list2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2)
		{
			var length = Min(array.Length, array2.Length);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2)
		{
			var length = Min(list2_.Count, list2_2.Count);
			NList<(T, T2)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				result._items[i] = (item, item2);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2));
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = List<int>.MinEnumerable(new[] { list.Length, list2.Length, list3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				var item2 = list2[i];
				var item3 = list3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), List<T3>.ReturnOrConstruct(source3), function);
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = List<int>.MinEnumerable(new[] { list.Length, list2.Length, list3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				var item2 = list2[i];
				var item3 = list3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), List<T3>.ReturnOrConstruct(source3), function);
	}

	internal static NList<(T, T2, T3)> CombineEnumerable<T2, T3>(IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		if (source is List<T> list && source2 is List<T2> list2 && source3 is List<T3> list3)
		{
			var length = List<int>.MinEnumerable(new[] { list.Length, list2.Length, list3.Length }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				var item2 = list2[i];
				var item3 = list3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array && source2 is T2[] array2 && source3 is T3[] array3)
		{
			var length = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = array[i];
				var item2 = array2[i];
				var item3 = array3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else if (source is G.IList<T> list2_ && source2 is G.IList<T2> list2_2 && source3 is G.IList<T3> list2_3)
		{
			var length = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<(T, T2, T3)> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2_[i];
				var item2 = list2_2[i];
				var item3 = list2_3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = length;
			return result;
		}
		else
			return CombineEnumerable(List<T>.ReturnOrConstruct(source), List<T2>.ReturnOrConstruct(source2), List<T3>.ReturnOrConstruct(source3));
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Min(source.Length, source2.Length);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Min(source.Length, source2.Length);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2)> CombineEnumerable<T2>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) where T2 : unmanaged
	{
		var length = Min(source.Length, source2.Length);
		NList<(T, T2)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source.Length, source2.Length, source3.Length });
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source.Length, source2.Length, source3.Length });
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], source2[i], source3[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2, T3)> CombineEnumerable<T2, T3>(ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source.Length, source2.Length, source3.Length });
		NList<(T, T2, T3)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source[i], source2[i], source3[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(NList<T> source, NList<T2> source2, Func<T, T2, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Min(source._size, source2._size);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, TResult>(NList<T> source, NList<T2> source2, Func<T, T2, int, TResult> function) where T2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Min(source._size, source2._size);
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2)> CombineEnumerable<T2>(NList<T> source, NList<T2> source2) where T2 : unmanaged
	{
		var length = Min(source._size, source2._size);
		NList<(T, T2)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source._items[i], source2._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source._size, source2._size, source3._size });
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i], source3._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<T2, T3, TResult>(NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, int, TResult> function) where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source._size, source2._size, source3._size });
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i], source2._items[i], source3._items[i], i);
		result._size = length;
		return result;
	}

	internal static NList<(T, T2, T3)> CombineEnumerable<T2, T3>(NList<T> source, NList<T2> source2, NList<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		var length = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source._size, source2._size, source3._size });
		NList<(T, T2, T3)> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = (source._items[i], source2._items[i], source3._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ConvertEnumerable<TResult>(IEnumerable<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list[i]);
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			NList<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
				result._items[i] = function(list2[i]);
			result._size = length;
			return result;
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = length;
			return result;
		}
	}

	internal static NList<TResult> ConvertEnumerable<TResult>(IEnumerable<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<T> list)
		{
			var length = list.Length;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else if (source is T[] array)
		{
			NList<TResult> result = new(array.Length);
			for (var i = 0; i < array.Length; i++)
			{
				var item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<T> list2)
		{
			var length = list2.Count;
			NList<TResult> result = new(length);
			for (var i = 0; i < length; i++)
			{
				var item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = length;
			return result;
		}
		else
		{
			NList<TResult> result = new(List<T>.TryGetLengthEasilyEnumerable(source, out var length) ? length : length = 1024);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = length;
			return result;
		}
	}

	internal static NList<TResult> ConvertEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ConvertEnumerable<TResult>(ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Length;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source[i], i);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ConvertEnumerable<TResult>(NList<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(source._items[i]);
		result._size = length;
		return result;
	}

	internal static NList<TResult> ConvertEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = function(item, i);
		}
		result._size = length;
		return result;
	}

	internal static NList<TResult> ConvertAndJoinEnumerable<TResult>(NList<T> source, Func<T, IEnumerable<TResult>> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source._items[i]));
		return result;
	}

	internal static NList<TResult> ConvertAndJoinEnumerable<TResult>(NList<T> source, Func<T, int, IEnumerable<TResult>> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result.AddRange(function(source._items[i], i));
		return result;
	}

	internal static NList<T> EmptyListEnumerable(int length) => new(length) { _size = length };

	internal static NList<TResult> FillEnumerable<TResult>(TResult elem, int length) where TResult : unmanaged
	{
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = elem;
		result._size = length;
		return result;
	}

	internal static NList<TResult> FillEnumerable<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		NList<TResult> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[i] = function(i);
		result._size = length;
		return result;
	}

	internal static NList<T> FilterEnumerable(NList<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> FilterEnumerable(NList<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item, i))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> FindAllEnumerable(NList<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> FindAllEnumerable(NList<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (function(item, i))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfEnumerable(NList<T> source, T target)
	{
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
			if (source._items[i].Equals(target))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable(NList<T> source)
	{
		FastDelHashSet<T> hs = new(EqualityComparer<T>.Default);
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable(NList<T> source, Func<T, T, bool> equalFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable<TResult>(NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		FastDelHashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<T> RemoveDoublesEnumerable(NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		FastDelHashSet<T> hs = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<T> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			if (hs.TryAdd(item))
				result.Add(item);
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(NList<T> source)
	{
		ListHashSet<T> dic = new();
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(NList<T> source, Func<T, T, bool> equalFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction));
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable(NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		ListHashSet<T> dic = new(new EComparer<T>(equalFunction, hashCodeFunction));
		var length = source._size;
		NList<int> result = new(length);
		var j = 0;
		for (var i = 0; i < length; i++)
		{
			var item = source._items[i];
			result._items[i] = !dic.TryAdd(item, out var index) ? index : j++;
		}
		result._size = length;
		return result;
	}

	internal static NList<T> ReverseEnumerable(NList<T> source)
	{
		var length = source._size;
		NList<T> result = new(length);
		for (var i = 0; i < length; i++)
			result._items[source._size - 1 - i] = source._items[i];
		result._size = length;
		return result;
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is NList<T> list)
			return list.SkipWhile(function);
		else
		{
			NList<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static Slice<T> SkipWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is NList<T> list)
			return list.SkipWhile(function);
		else
		{
			NList<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			for (; en.MoveNext() && function(en.Current, i); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result.GetSlice();
		}
	}

	internal static List<NList<T>> SplitIntoEqualEnumerable(NList<T> source, int fragmentLength)
	{
		if (fragmentLength <= 0)
			throw new ArgumentException(null, nameof(fragmentLength));
		var length = GetArrayLength(source._size, fragmentLength);
		List<NList<T>> result = new(length);
		var count2 = source._size / fragmentLength;
		var index = 0;
		for (var i = 0; i < count2; i++)
		{
			result.Add(new(fragmentLength));
			for (var j = 0; j < fragmentLength; j++)
				result[i]._items[j] = source[index++];
			result[i]._size = fragmentLength;
		}
		var rest = source._size % fragmentLength;
		if (rest != 0)
		{
			result.Add(new(rest));
			for (var j = 0; j < rest; j++)
				result[count2]._items[j] = source[index++];
			result[count2]._size = rest;
		}
		return result;
	}

	internal static Slice<T> TakeEnumerable(IEnumerable<T> source, int length)
	{
		if (length == 0)
			return new();
		else if (source is NList<T> list)
			return list.Take(length);
		else
		{
			NList<T> result = new(length);
			var i = 0;
			foreach (var item in source)
			{
				result._items[i++] = item;
				if (i >= length)
					break;
			}
			result._size = i;
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, bool> function)
	{
		if (source is NList<T> list)
			return list.TakeWhile(function);
		else
		{
			NList<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static Slice<T> TakeWhileEnumerable(IEnumerable<T> source, Func<T, int, bool> function)
	{
		if (source is NList<T> list)
			return list.TakeWhile(function);
		else
		{
			NList<T> result = new();
			var en = source.GetEnumerator();
			var i = 0;
			T item;
			for (; en.MoveNext() && function(item = en.Current, i); i++) result.Add(item);
			return result.GetSlice();
		}
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<T>, NList<T2>) PBreakEnumerable<T2>(G.IList<(T, T2)> source) where T2 : unmanaged
	{
		var length = source.Count;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) PBreakEnumerable<TResult, TResult2>(G.IList<T> source, Func<T, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<T>, NList<T2>, NList<T3>) PBreakEnumerable<T2, T3>(G.IList<(T, T2, T3)> source) where T2 : unmanaged where T3 : unmanaged
	{
		var length = source.Count;
		NList<T> result = new(length);
		NList<T2> result2 = new(length);
		NList<T3> result3 = new(length);
		Parallel.For(0, length, i => (result._items[i], result2._items[i], result3._items[i]) = source[i]);
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) PBreakEnumerable<TResult, TResult2, TResult3>(G.IList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<TResult> result = new(length);
		NList<TResult2> result2 = new(length);
		NList<TResult3> result3 = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		});
		result._size = length;
		result2._size = length;
		result3._size = length;
		return (result, result2, result3);
	}

	internal static NList<TResult> PCombineEnumerable<T2, TResult>(G.IList<T> source, G.IList<T2> source2, Func<T, T2, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Min(source.Count, source2.Count);
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PCombineEnumerable<T2, TResult>(G.IList<T> source, G.IList<T2> source2, Func<T, T2, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = Min(source.Count, source2.Count);
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = function(item, item2, i);
		});
		result._size = length;
		return result;
	}

	internal static NList<(T, T2)> PCombineEnumerable<T2>(G.IList<T> source, G.IList<T2> source2) where T2 : unmanaged
	{
		var length = Min(source.Count, source2.Count);
		NList<(T, T2)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			result._items[i] = (item, item2);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PCombineEnumerable<T2, T3, TResult>(G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = List<int>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PCombineEnumerable<T2, T3, TResult>(G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = List<int>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = function(item, item2, item3, i);
		});
		result._size = length;
		return result;
	}

	internal static NList<(T, T2, T3)> PCombineEnumerable<T2, T3>(G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3) where T2 : unmanaged where T3 : unmanaged
	{
		var length = List<int>.MinEnumerable(new[] { source.Count, source2.Count, source3.Count }.AsSpan());
		NList<(T, T2, T3)> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			var item2 = source2[i];
			var item3 = source3[i];
			result._items[i] = (item, item2, item3);
		});
		result._size = length;
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (item.Equals(target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target, IEqualityComparer<T> comparer)
	{
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target, Func<T, T, bool> equalFunction)
	{
		var comparer = new EComparer<T>(equalFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static bool PContainsEnumerable(G.IList<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction)
	{
		var comparer = new EComparer<T>(equalFunction, hashCodeFunction);
		var length = source.Count;
		var result = false;
		Parallel.For(0, length, (i, pls) =>
		{
			var item = source[i];
			if (comparer.Equals(item, target))
			{
				result = true;
				pls.Stop();
			}
		});
		return result;
	}

	internal static NList<TResult> PConvertEnumerable<TResult>(G.IList<T> source, Func<T, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(source[i]));
		result._size = length;
		return result;
	}

	internal static NList<TResult> PConvertEnumerable<TResult>(G.IList<T> source, Func<T, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<TResult> result = new(length);
		Parallel.For(0, length, i =>
		{
			var item = source[i];
			result._items[i] = function(item, i);
		});
		result._size = length;
		return result;
	}

	internal static NList<TResult> PFillEnumerable<TResult>(TResult elem, int length) where TResult : unmanaged
	{
		NList<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = elem);
		result._size = length;
		return result;
	}

	internal static NList<TResult> PFillEnumerable<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		NList<TResult> result = new(length);
		Parallel.For(0, length, i => result._items[i] = function(i));
		result._size = length;
		return result;
	}

	internal static NList<T> PFilterEnumerable(G.IList<T> source, Func<T, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i]));
		NList<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}

	internal static NList<T> PFilterEnumerable(G.IList<T> source, Func<T, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		var length = source.Count;
		NList<bool> values = new(length);
		Parallel.For(0, length, i => values._items[i] = function(source[i], i));
		NList<T> result = new(length / 2);
		for (var i = 0; i < length; i++)
			if (values._items[i])
				result.Add(source[i]);
		result.TrimExcess();
		return result;
	}
}

public static class RedStarLinq
{
	public static bool All<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool All<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool Any<T>(this IEnumerable<T> source) => List<T>.AnyEnumerable(source);
	public static bool Any<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.AnyEnumerable(source, function);
	public static bool Any<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.AnyEnumerable(source, function);
	public static IEnumerable<T> AsEnumerable<T>(this IEnumerable<T> source) => source;
	public static Span<T> AsSpan<T>(this IEnumerable<T> source) => source is BaseIndexable<T> collection ? collection.AsSpan() : source is T[] array ? MemoryExtensions.AsSpan(array) : List<T>.ReturnOrConstruct(source).AsSpan();
	public static Span<T> AsSpan<T>(this IEnumerable<T> source, int index) => source is BaseIndexable<T> collection ? collection.AsSpan(index) : source is T[] array ? MemoryExtensions.AsSpan(array, index) : List<T>.ReturnOrConstruct(source).AsSpan(index);
	public static Span<T> AsSpan<T>(this IEnumerable<T> source, int index, int length) => source is BaseIndexable<T> collection ? collection.AsSpan(index, length) : source is T[] array ? MemoryExtensions.AsSpan(array, index, length) : List<T>.ReturnOrConstruct(source).AsSpan(index, length);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<T>, List<T2>) Break<T, T2>(this IEnumerable<(T, T2)> source) => List<T>.BreakEnumerable(source);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this IEnumerable<(T, T2, T3)> source) => List<T>.BreakEnumerable(source);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static List<T> BreakFilter<T>(this IEnumerable<T> source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static List<T> BreakFilter<T>(this IEnumerable<T> source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static (List<T>, List<T>) BreakFilter<T>(this IEnumerable<T> source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this IEnumerable<T> source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static List<TResult> Combine<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static List<TResult> Combine<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static List<(T, T2)> Combine<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.CombineEnumerable(source, source2);
	public static List<TResult> Combine<T, T2, T3, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this IEnumerable<T> source, IEnumerable<T2> source2, IEnumerable<T3> source3) => List<T>.CombineEnumerable(source, source2, source3);
	public static List<TResult> Combine<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T2, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, function);
	public static List<TResult> Combine<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, function);
	public static List<(T, T2)> Combine<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source) => List<T>.CombineEnumerable(source.Item1, source.Item2);
	public static List<TResult> Combine<T, T2, T3, TResult>(this (IEnumerable<T>, IEnumerable<T2>, IEnumerable<T3>) source, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this (IEnumerable<T>, IEnumerable<T2>, IEnumerable<T3>) source, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this (IEnumerable<T>, IEnumerable<T2>, IEnumerable<T3>) source) => List<T>.CombineEnumerable(source.Item1, source.Item2, source.Item3);
	public static List<T> Concat<T>(this IEnumerable<T> source, params IEnumerable<T>[] collections) => List<T>.ConcatEnumerable(source, collections);
	public static bool Contains<T>(this IEnumerable<T> source, T target) => List<T>.ContainsEnumerable(source, target);
	public static bool Contains<T>(this IEnumerable<T> source, T target, IEqualityComparer<T> comparer) => List<T>.ContainsEnumerable(source, target, comparer);
	public static bool Contains<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.ContainsEnumerable(source, target, equalFunction);
	public static bool Contains<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.ContainsEnumerable(source, target, equalFunction, hashCodeFunction);
	public static List<TResult> Convert<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static List<TResult> Convert<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this IEnumerable<T> source, Func<T, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this IEnumerable<T> source, Func<T, int, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable(source, function);
	public static IEnumerable<TResult> ConvertAndJoin<T, TCollection, TResult>(this IEnumerable<T> source, Func<T, IEnumerable<TCollection>> collectionSelector, Func<T, TCollection, TResult> resultSelector) => Enumerable.SelectMany(source, collectionSelector, resultSelector);
	public static IEnumerable<TResult> ConvertAndJoin<T, TCollection, TResult>(this IEnumerable<T> source, Func<T, int, IEnumerable<TCollection>> collectionSelector, Func<T, TCollection, int, TResult> resultSelector) => List<T>.ConvertAndJoin(source, collectionSelector, resultSelector);
	public static List<List<T>> CopyDoubleList<T>(this List<List<T>> source) => source.Convert(x => x.Copy());
	public static List<List<List<T>>> CopyTripleList<T>(this List<List<List<T>>> source) => source.Convert(x => x.CopyDoubleList());
	public static int Count<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this IEnumerable<T> source, T target) => List<T>.CountEnumerable(source, target);
	public static IEnumerable<T?> DefaultIfEmpty<T>(this IEnumerable<T> source) => Enumerable.DefaultIfEmpty(source);
	public static IEnumerable<T> DefaultIfEmpty<T>(this IEnumerable<T> source, T defaultValue) => Enumerable.DefaultIfEmpty(source, defaultValue);
	public static T ElementAt<T>(this IEnumerable<T> source, int index) => Enumerable.ElementAt(source, index);
	public static T? ElementAtOrDefault<T>(this IEnumerable<T> source, int index) => Enumerable.ElementAtOrDefault(source, index);
	public static IEnumerable<T?> Empty<T>() => Enumerable.Empty<T>();
	public static List<T> EmptyList<T>(int length) => List<T>.EmptyListEnumerable(length);
	public static bool Equals<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.EqualsEnumerable(source, source2);
	public static IEnumerable<T> Except<T>(this IEnumerable<T> source, IEnumerable<T> source2) => Enumerable.Except(source, source2);
	public static IEnumerable<T> Except<T>(this IEnumerable<T> source, IEnumerable<T> source2, IEqualityComparer<T> comparer) => Enumerable.Except(source, source2, comparer);
	public static List<TResult> Fill<TResult>(TResult elem, int length) => List<bool>.FillEnumerable(elem, length);
	public static List<TResult> Fill<TResult>(Func<int, TResult> function, int length) => List<bool>.FillEnumerable(function, length);
	public static List<TResult> Fill<TResult>(int length, Func<int, TResult> function) => List<bool>.FillEnumerable(function, length);
	public static TResult[] FillArray<TResult>(TResult elem, int length) => List<bool>.FillArrayEnumerable(elem, length);
	public static TResult[] FillArray<TResult>(Func<int, TResult> function, int length) => List<bool>.FillArrayEnumerable(function, length);
	public static TResult[] FillArray<TResult>(int length, Func<int, TResult> function) => List<bool>.FillArrayEnumerable(function, length);
	public static List<T> Filter<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FilterEnumerable(source, function);
	public static List<T> Filter<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FilterEnumerable(source, function);
	public static T? Find<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindEnumerable(source, function);
	public static T? Find<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindEnumerable(source, function);
	public static List<T> FindAll<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAll<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<int> FindIndexes<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindIndexesEnumerable(source, function);
	public static List<int> FindIndexes<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindIndexesEnumerable(source, function);
	public static int FindIndex<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindIndexEnumerable(source, function);
	public static int FindIndex<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindIndexEnumerable(source, function);
	public static T? FindLast<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static T? FindLast<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static int FindLastIndex<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.FindLastIndexEnumerable(source, function);
	public static int FindLastIndex<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.FindLastIndexEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMinEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static void ForEach<T>(this IEnumerable<T> source, Action<T> action) => List<T>.ForEachEnumerable(source, action);
	public static void ForEach<T>(this IEnumerable<T> source, Action<T, int> action) => List<T>.ForEachEnumerable(source, action);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source) where T : notnull => List<T>.FrequencyTableEnumerable(source);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, comparer);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, comparer);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.FrequencyTableEnumerable(source, comparer);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source) where T : notnull => List<T>.GroupEnumerable(source);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable(source, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector) => Enumerable.GroupBy(source, keySelector, elementSelector);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector) => List<T>.Group(source, keySelector, elementSelector);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, elementSelector, comparer);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, IEqualityComparer<TKey> comparer) => List<T>.Group(source, keySelector, elementSelector, comparer);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction) => List<T>.Group(source, keySelector, elementSelector, equalFunction);
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<IGrouping<TKey, TElement>> Group<T, TKey, TElement>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<T>.Group(source, keySelector, elementSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector) => Enumerable.GroupBy(source, keySelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector) => List<T>.Group(source, keySelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<T>.Group(source, keySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<T>.Group(source, keySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<TKey, IEnumerable<T>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Group<T, TKey, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<TKey, IEnumerable<T>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<T>.Group(source, keySelector, resultSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector) => List<T>.Group(source, keySelector, elementSelector, resultSelector);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<T>.Group(source, keySelector, elementSelector, resultSelector, comparer);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<T>.Group(source, keySelector, elementSelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Group<T, TKey, TElement, TResult>(this IEnumerable<T> source, Func<T, int, TKey> keySelector, Func<T, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<T>.Group(source, keySelector, elementSelector, resultSelector, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source) where T : notnull => List<T>.GroupIndexesEnumerable(source);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable(source, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static List<int> IndexesOf<T>(this IEnumerable<T> source, T target) => List<T>.IndexesOfEnumerable(source, target);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this IEnumerable<double> source) => List<double>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this IEnumerable<int> source) => List<int>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this IEnumerable<uint> source) => List<int>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this IEnumerable<long> source) => List<long>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this IEnumerable<double> source) => List<double>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this IEnumerable<int> source) => List<int>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this IEnumerable<uint> source) => List<int>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this IEnumerable<long> source) => List<long>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this IEnumerable<double> source) => List<double>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this IEnumerable<int> source) => List<int>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this IEnumerable<uint> source) => List<int>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this IEnumerable<long> source) => List<long>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this IEnumerable<double> source) => List<double>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this IEnumerable<int> source) => List<int>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this IEnumerable<uint> source) => List<int>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this IEnumerable<long> source) => List<long>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMinEnumerable(source);
	public static int IndexOf<T>(this IEnumerable<T> source, T target) => List<T>.IndexOfEnumerable(source, target);
	public static int IndexOf<T>(this IEnumerable<T> source, T target, IEqualityComparer<T> comparer) => List<T>.IndexOfEnumerable(source, target, comparer);
	public static int IndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.IndexOfEnumerable(source, target, equalFunction);
	public static int IndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.IndexOfEnumerable(source, target, equalFunction, hashCodeFunction);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax(this IEnumerable<decimal> source) => List<decimal>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<double> source) => List<double>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<int> source) => List<int>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<uint> source) => List<int>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<long> source) => List<long>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMaxEnumerable(source);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean(this IEnumerable<decimal> source) => List<decimal>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<double> source) => List<double>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<int> source) => List<int>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<uint> source) => List<int>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<long> source) => List<long>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMeanEnumerable(source);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian(this IEnumerable<decimal> source) => List<decimal>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<double> source) => List<double>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<int> source) => List<int>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<uint> source) => List<int>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<long> source) => List<long>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMedianEnumerable(source);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin(this IEnumerable<decimal> source) => List<decimal>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<double> source) => List<double>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<int> source) => List<int>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<uint> source) => List<int>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<long> source) => List<long>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMinEnumerable(source);
	public static IEnumerable<T> Intersect<T>(this IEnumerable<T> source, IEnumerable<T> source2) => Enumerable.Intersect(source, source2);
	public static IEnumerable<T> Intersect<T>(this IEnumerable<T> source, IEnumerable<T> source2, IEqualityComparer<T> comparer) => Enumerable.Intersect(source, source2, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<bool>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<List<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T[]> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<G.IList<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<IEnumerable<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<TResult> JoinIntoSingle<T, TResult>(this IEnumerable<T> source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>(source);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target) => List<T>.LastIndexOfEnumerable(source, target);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target, IEqualityComparer<T> comparer) => List<T>.LastIndexOfEnumerable(source, target, comparer);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.LastIndexOfEnumerable(source, target, equalFunction);
	public static int LastIndexOf<T>(this IEnumerable<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.LastIndexOfEnumerable(source, target, equalFunction, hashCodeFunction);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<double> source) => List<double>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<int> source) => List<int>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<uint> source) => List<int>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<long> source) => List<long>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<double> source) => List<double>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<int> source) => List<int>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<uint> source) => List<int>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<long> source) => List<long>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<double> source) => List<double>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<int> source) => List<int>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<uint> source) => List<int>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<long> source) => List<long>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<double> source) => List<double>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<int> source) => List<int>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<uint> source) => List<int>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<long> source) => List<long>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMinEnumerable(source);
	public static int Length<T>(this IEnumerable<T> source) => List<T>.LengthEnumerable(source);
	public static decimal Max<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MaxEnumerable(source, function);
	public static mpz_t Max<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.MaxEnumerable(source, function);
	public static mpz_t Max<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max(this IEnumerable<decimal> source) => List<decimal>.MaxEnumerable(source);
	public static double Max(this IEnumerable<double> source) => List<double>.MaxEnumerable(source);
	public static int Max(this IEnumerable<int> source) => List<int>.MaxEnumerable(source);
	public static uint Max(this IEnumerable<uint> source) => List<int>.MaxEnumerable(source);
	public static long Max(this IEnumerable<long> source) => List<long>.MaxEnumerable(source);
	public static mpz_t Max(this IEnumerable<mpz_t> source) => List<mpz_t>.MaxEnumerable(source);
	public static TResult? Max<T, TResult>(this IEnumerable<T> source, Func<T, TResult> selector) => Enumerable.Max(source, selector);
	public static TResult? Max<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> selector) => List<T>.Max(source, selector);
	public static T? Max<T>(this IEnumerable<T> source) => Enumerable.Max(source);
	public static decimal Max(params decimal[] source) => List<decimal>.MaxEnumerable(source.AsSpan());
	public static double Max(params double[] source) => List<double>.MaxEnumerable(source.AsSpan());
	public static int Max(params int[] source) => List<int>.MaxEnumerable(source.AsSpan());
	public static uint Max(params uint[] source) => List<uint>.MaxEnumerable(source.AsSpan());
	public static long Max(params long[] source) => List<long>.MaxEnumerable(source.AsSpan());
	public static mpz_t Max(params mpz_t[] source) => List<mpz_t>.MaxEnumerable(source.AsSpan());
	public static T? Max<T>(params T?[] source) => Enumerable.Max(source);
	public static decimal Mean<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean(this IEnumerable<decimal> source) => List<decimal>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<double> source) => List<double>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<int> source) => List<int>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<uint> source) => List<int>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<long> source) => List<long>.MeanEnumerable(source);
	public static double Mean(this IEnumerable<mpz_t> source) => List<mpz_t>.MeanEnumerable(source);
	public static decimal Mean(params decimal[] source) => List<decimal>.MeanEnumerable(source.AsSpan());
	public static double Mean(params double[] source) => List<double>.MeanEnumerable(source.AsSpan());
	public static double Mean(params int[] source) => List<int>.MeanEnumerable(source.AsSpan());
	public static double Mean(params uint[] source) => List<uint>.MeanEnumerable(source.AsSpan());
	public static double Mean(params long[] source) => List<long>.MeanEnumerable(source.AsSpan());
	public static double Mean(params mpz_t[] source) => List<mpz_t>.MeanEnumerable(source.AsSpan());
	public static decimal Median<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MedianEnumerable(source, function);
	public static mpz_t Median<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.MedianEnumerable(source, function);
	public static mpz_t Median<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median(this IEnumerable<decimal> source) => List<decimal>.MedianEnumerable(source);
	public static double Median(this IEnumerable<double> source) => List<double>.MedianEnumerable(source);
	public static int Median(this IEnumerable<int> source) => List<int>.MedianEnumerable(source);
	public static uint Median(this IEnumerable<uint> source) => List<int>.MedianEnumerable(source);
	public static long Median(this IEnumerable<long> source) => List<long>.MedianEnumerable(source);
	public static mpz_t Median(this IEnumerable<mpz_t> source) => List<mpz_t>.MedianEnumerable(source);
	public static TResult? Median<T, TResult>(this IEnumerable<T> source, Func<T, TResult> selector) => List<T>.MedianEnumerable(source, selector);
	public static TResult? Median<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> selector) => List<T>.MedianEnumerable(source, selector);
	public static T? Median<T>(this IEnumerable<T> source) => List<T>.MedianEnumerable(source);
	public static decimal Median(params decimal[] source) => List<decimal>.MedianEnumerable(source.AsSpan());
	public static double Median(params double[] source) => List<double>.MedianEnumerable(source.AsSpan());
	public static int Median(params int[] source) => List<int>.MedianEnumerable(source.AsSpan());
	public static uint Median(params uint[] source) => List<uint>.MedianEnumerable(source.AsSpan());
	public static long Median(params long[] source) => List<long>.MedianEnumerable(source.AsSpan());
	public static mpz_t Median(params mpz_t[] source) => List<mpz_t>.MedianEnumerable(source.AsSpan());
	public static T? Median<T>(params T?[] source) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static decimal Min<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.MinEnumerable(source, function);
	public static mpz_t Min<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.MinEnumerable(source, function);
	public static mpz_t Min<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min(this IEnumerable<decimal> source) => List<decimal>.MinEnumerable(source);
	public static double Min(this IEnumerable<double> source) => List<double>.MinEnumerable(source);
	public static int Min(this IEnumerable<int> source) => List<int>.MinEnumerable(source);
	public static uint Min(this IEnumerable<uint> source) => List<int>.MinEnumerable(source);
	public static long Min(this IEnumerable<long> source) => List<long>.MinEnumerable(source);
	public static mpz_t Min(this IEnumerable<mpz_t> source) => List<mpz_t>.MinEnumerable(source);
	public static TResult? Min<T, TResult>(this IEnumerable<T> source, Func<T, TResult> selector) => Enumerable.Min(source, selector);
	public static TResult? Min<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> selector) => List<T>.Min(source, selector);
	public static T? Min<T>(this IEnumerable<T> source) => Enumerable.Min(source);
	public static decimal Min(params decimal[] source) => List<decimal>.MinEnumerable(source.AsSpan());
	public static double Min(params double[] source) => List<double>.MinEnumerable(source.AsSpan());
	public static int Min(params int[] source) => List<int>.MinEnumerable(source.AsSpan());
	public static uint Min(params uint[] source) => List<uint>.MinEnumerable(source.AsSpan());
	public static long Min(params long[] source) => List<long>.MinEnumerable(source.AsSpan());
	public static mpz_t Min(params mpz_t[] source) => List<mpz_t>.MinEnumerable(source.AsSpan());
	public static T? Min<T>(params T?[] source) => Enumerable.Min(source);
	public static List<TResult> OfType<TResult>(this IEnumerable source) => List<bool>.OfTypeEnumerable<TResult>(source);
	public static IEnumerable<T> Prepend<T>(this IEnumerable<T> source, T element) => Enumerable.Prepend(source, element);
	public static T? Progression<T>(this IEnumerable<T> source, Func<T, T, T> function) => List<T>.ProgressionEnumerable(source, function);
	public static TResult? Progression<T, TResult>(this IEnumerable<T> source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable(source, seed, function);
	public static T Random<T>(this G.IList<T> source) => source[random.Next(source.Count)];
	public static T Random<T>(this G.IList<T> source, Random randomObj) => source[randomObj.Next(source.Count)];
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source) => List<T>.RemoveDoublesEnumerable(source);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, comparer);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, comparer);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) => List<T>.RemoveDoublesEnumerable(source, comparer);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source, source2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source, source2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.RemoveDoublesEnumerable(source, source2);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, IEqualityComparer<T> comparer) => List<T>.RemoveDoublesEnumerable(source, source2, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, source2, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, source2, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, IEqualityComparer<T> comparer) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, comparer);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2, TResult>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	public static (List<T>, List<T2>) RemoveDoubles<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction, hashCodeFunction);
	public static List<int> RepresentIntoNumbers<T>(this IEnumerable<T> source) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source);
	public static List<int> RepresentIntoNumbers<T>(this IEnumerable<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, comparer);
	public static List<int> RepresentIntoNumbers<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static List<int> RepresentIntoNumbers<T>(this IEnumerable<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static List<T> Reverse<T>(this IEnumerable<T> source) => List<T>.ReverseEnumerable(source);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value) => List<T>.SetAllEnumerable(source, value);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, Index index) => List<T>.SetAllEnumerable(source, value, index);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, int index) => List<T>.SetAllEnumerable(source, value, index);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, int index, int length) => List<T>.SetAllEnumerable(source, value, index, length);
	public static G.IList<T> SetAll<T>(this G.IList<T> source, T value, Range range) => List<T>.SetAllEnumerable(source, value, range);
	public static T[] SetAll<T>(this T[] source, T value) => List<T>.SetAllEnumerable((G.IList<T>)source, value) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, Index index) => List<T>.SetAllEnumerable(source, value, index) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, int index) => List<T>.SetAllEnumerable(source, value, index) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, int index, int length) => List<T>.SetAllEnumerable(source, value, index, length) as T[] ?? throw new InvalidOperationException();
	public static T[] SetAll<T>(this T[] source, T value, Range range) => List<T>.SetAllEnumerable(source, value, range) as T[] ?? throw new InvalidOperationException();
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source) => List<bool>.SetInnerTypeEnumerable<TResult>(source);
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source, Func<object?, TResult> function) => List<bool>.SetInnerTypeEnumerable(source, function);
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source, Func<object?, int, TResult> function) => List<bool>.SetInnerTypeEnumerable(source, function);
	public static Slice<T> Skip<T>(this IEnumerable<T> source, int length) => List<T>.SkipEnumerable(source, length);
	public static Slice<T> SkipLast<T>(this IEnumerable<T> source, int length) => List<T>.SkipLastEnumerable(source, length);
	public static Slice<T> SkipWhile<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.SkipWhileEnumerable(source, function);
	public static Slice<T> SkipWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.SkipWhileEnumerable(source, function);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => Enumerable.OrderBy(source, function);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.Sort(source, function);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IComparer<TResult> comparer) => Enumerable.OrderBy(source, function, comparer);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer) => List<T>.Sort(source, function, comparer);
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, int> compareFunction) => Enumerable.OrderBy(source, function, new Comparer<TResult>(compareFunction));
	public static IEnumerable<T> Sort<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction) => List<T>.Sort(source, function, compareFunction);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => Enumerable.OrderByDescending(source, function);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.SortDesc(source, function);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, IComparer<TResult> comparer) => Enumerable.OrderByDescending(source, function, comparer);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, IComparer<TResult> comparer) => List<T>.SortDesc(source, function, comparer);
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function, Func<TResult, TResult, int> compareFunction) => Enumerable.OrderByDescending(source, function, new Comparer<TResult>(compareFunction));
	public static IEnumerable<T> SortDesc<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<TResult, TResult, int> compareFunction) => List<T>.SortDesc(source, function, compareFunction);
	public static List<List<T>> SplitIntoEqual<T>(this IEnumerable<T> source, int fragmentLength) => List<T>.SplitIntoEqualEnumerable(source, fragmentLength);
	public static bool StartsWith<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) => List<T>.StartsWithEnumerable(source, source2);
	public static decimal Sum<T>(this IEnumerable<T> source, Func<T, decimal> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum<T>(this IEnumerable<T> source, Func<T, int, decimal> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this IEnumerable<T> source, Func<T, double> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this IEnumerable<T> source, Func<T, int, double> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this IEnumerable<T> source, Func<T, int> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this IEnumerable<T> source, Func<T, int, int> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this IEnumerable<T> source, Func<T, uint> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this IEnumerable<T> source, Func<T, int, uint> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this IEnumerable<T> source, Func<T, long> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this IEnumerable<T> source, Func<T, int, long> function) => List<T>.SumEnumerable(source, function);
	public static mpz_t Sum<T>(this IEnumerable<T> source, Func<T, mpz_t> function) => List<T>.SumEnumerable(source, function);
	public static mpz_t Sum<T>(this IEnumerable<T> source, Func<T, int, mpz_t> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum(this IEnumerable<decimal> source) => List<decimal>.SumEnumerable(source);
	public static double Sum(this IEnumerable<double> source) => List<double>.SumEnumerable(source);
	public static int Sum(this IEnumerable<int> source) => List<int>.SumEnumerable(source);
	public static uint Sum(this IEnumerable<uint> source) => List<int>.SumEnumerable(source);
	public static long Sum(this IEnumerable<long> source) => List<long>.SumEnumerable(source);
	public static mpz_t Sum(this IEnumerable<mpz_t> source) => List<mpz_t>.SumEnumerable(source);
	public static Slice<T> Take<T>(this IEnumerable<T> source, int length) => List<T>.TakeEnumerable(source, length);
	public static Slice<T> Take<T>(this IEnumerable<T> source, Range range) => List<T>.TakeEnumerable(source, range);
	public static Slice<T> TakeLast<T>(this IEnumerable<T> source, int length) => List<T>.TakeLastEnumerable(source, length);
	public static Slice<T> TakeWhile<T>(this IEnumerable<T> source, Func<T, bool> function) => List<T>.TakeWhileEnumerable(source, function);
	public static Slice<T> TakeWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) => List<T>.TakeWhileEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static T[] ToArray<T>(this IEnumerable<T> source) => List<T>.ToArrayEnumerable(source);
	public static BitList ToBitList(this IEnumerable<bool> source) => new(source);
	public static BitList ToBitList(this IEnumerable<byte> source) => new(source);
	public static BitList ToBitList(this IEnumerable<int> source) => new(source);
	public static BitList ToBitList(this IEnumerable<uint> source) => new(source);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2));
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2));
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2), comparer);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2), comparer);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2), equalFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2), equalFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, TKey> function, Func<T, TValue> function2, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2), equalFunction, hashCodeFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, TKey> function, Func<T, int, TValue> function2, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), List<T>.ConvertEnumerable(source, function2), equalFunction, hashCodeFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function));
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function));
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), comparer);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), comparer);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function));
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function));
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), comparer);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), comparer);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> source, Func<T, int, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<T>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2) where T : notnull => new(source, source2);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, IEqualityComparer<T> comparer) where T : notnull => new(source, source2, comparer);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction) where T : notnull => new(source, source2, equalFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<T> source, IEnumerable<T2> source2, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => new(source, source2, equalFunction, hashCodeFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source) where T : notnull => new(source.Item1, source.Item2);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, IEqualityComparer<T> comparer) where T : notnull => new(source.Item1, source.Item2, comparer);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction) where T : notnull => new(source.Item1, source.Item2, equalFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this (IEnumerable<T>, IEnumerable<T2>) source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => new(source.Item1, source.Item2, equalFunction, hashCodeFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source) where T : notnull => new(source);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, IEqualityComparer<T> comparer) where T : notnull => new(source, comparer);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, Func<T, T, bool> equalFunction) where T : notnull => new(source, equalFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<(T, T2)> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => new(source, equalFunction, hashCodeFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source) where T : notnull => new(source);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, IEqualityComparer<T> comparer) where T : notnull => new(source, comparer);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, Func<T, T, bool> equalFunction) where T : notnull => new(source, equalFunction);
	public static Dictionary<T, T2> ToDictionary<T, T2>(this IEnumerable<KeyValuePair<T, T2>> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => new(source, equalFunction, hashCodeFunction);
	public static ListHashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new(source);
	public static List<T> ToList<T>(this IEnumerable<T> source) => List<T>.ReturnOrConstruct(source);
	public static NList<T> ToNList<T>(this IEnumerable<T> source) where T : unmanaged => NList<T>.ReturnOrConstruct(source);
	public static string ToString<T>(this IEnumerable<T> source, Func<T, char> function) => new(List<T>.ToArrayEnumerable(source, function));
	public static string ToString<T>(this IEnumerable<T> source, Func<T, int, char> function) => new(List<T>.ToArrayEnumerable(source, function));
	public static string ToString(this IEnumerable<char> source) => new(List<char>.ToArrayEnumerable(source));
	public static List<List<T>> Transpose<T>(this List<List<T>> source, bool widen = false) => List<T>.Transpose(source, widen);
	public static bool TryGetLengthEasily<T>(this IEnumerable<T> source, out int length) => List<T>.TryGetLengthEasilyEnumerable(source, out length);
	public static bool TryGetLengthEasily<T>(this IEnumerable source, out int length) => List<T>.TryGetLengthEasilyEnumerable(source, out length);
	public static bool TryWrap<T>(this IEnumerable<T> source, Func<IEnumerable<T>, List<T>> function, out List<T>? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T, TResult>(this IEnumerable<T> source, Func<IEnumerable<T>, TResult> function, out TResult? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T>(this List<T> source, Func<List<T>, List<T>> function, out List<T>? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T, TResult>(this List<T> source, Func<List<T>, TResult> function, out TResult? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T>(this T[] source, Func<T[], List<T>> function, out List<T>? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T, TResult>(this T[] source, Func<T[], TResult> function, out TResult? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T>(this G.IList<T> source, Func<G.IList<T>, List<T>> function, out List<T>? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static bool TryWrap<T, TResult>(this G.IList<T> source, Func<G.IList<T>, TResult> function, out TResult? result) => List<T>.TryWrapEnumerable(source, function, out result);
	public static IEnumerable<T> Union<T>(this IEnumerable<T> source, IEnumerable<T> source2) => Enumerable.Union(source, source2);
	public static IEnumerable<T> Union<T>(this IEnumerable<T> source, IEnumerable<T> source2, IEqualityComparer<T> comparer) => Enumerable.Union(source, source2, comparer);
	public static List<T> Wrap<T>(this IEnumerable<T> source, Func<IEnumerable<T>, List<T>> function) => function(source);
	public static TResult Wrap<T, TResult>(this IEnumerable<T> source, Func<IEnumerable<T>, TResult> function) => function(source);
	public static List<T> Wrap<T>(this List<T> source, Func<List<T>, List<T>> function) => function(source);
	public static TResult Wrap<T, TResult>(this List<T> source, Func<List<T>, TResult> function) => function(source);
	public static List<T> Wrap<T>(this T[] source, Func<T[], List<T>> function) => function(source);
	public static TResult Wrap<T, TResult>(this T[] source, Func<T[], TResult> function) => function(source);
	public static List<T> Wrap<T>(this G.IList<T> source, Func<G.IList<T>, List<T>> function) => function(source);
	public static TResult Wrap<T, TResult>(this G.IList<T> source, Func<G.IList<T>, TResult> function) => function(source);
	public static bool All<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool All<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.AllEnumerable(source, function);
	public static bool All<T>(this Span<T> source, Func<T, bool> function) => List<T>.AllEnumerable((ReadOnlySpan<T>)source, function);
	public static bool All<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.AllEnumerable((ReadOnlySpan<T>)source, function);
	public static bool All<T>(this T[] source, Func<T, bool> function) => List<T>.AllEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static bool All<T>(this T[] source, Func<T, int, bool> function) => List<T>.AllEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static bool Any<T>(this ReadOnlySpan<T> source) => List<T>.AnyEnumerable(source);
	public static bool Any<T>(this Span<T> source) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source);
	public static bool Any<T>(this T[] source) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static bool Any<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.AnyEnumerable(source, function);
	public static bool Any<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.AnyEnumerable(source, function);
	public static bool Any<T>(this Span<T> source, Func<T, bool> function) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source, function);
	public static bool Any<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source, function);
	public static bool Any<T>(this T[] source, Func<T, bool> function) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static bool Any<T>(this T[] source, Func<T, int, bool> function) => List<T>.AnyEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2);
	public static (List<T>, List<T2>) Break<T, T2>(this ReadOnlySpan<(T, T2)> source) => List<T>.BreakEnumerable(source);
	public static (List<T>, List<T2>) Break<T, T2>(this Span<(T, T2)> source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source);
	public static (List<T>, List<T2>) Break<T, T2>(this (T, T2)[] source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source.AsSpan());
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this Span<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, (TResult, TResult2)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (List<TResult>, List<TResult2>) Break<T, TResult, TResult2>(this T[] source, Func<T, int, (TResult, TResult2)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2, function3);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this ReadOnlySpan<(T, T2, T3)> source) => List<T>.BreakEnumerable(source);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this Span<(T, T2, T3)> source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source);
	public static (List<T>, List<T2>, List<T3>) Break<T, T2, T3>(this (T, T2, T3)[] source) => List<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source.AsSpan());
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static List<T> BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable(source, function, out result2);
	public static List<T> BreakFilter<T>(this Span<T> source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out result2);
	public static List<T> BreakFilter<T>(this Span<T> source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out result2);
	public static List<T> BreakFilter<T>(this T[] source, Func<T, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, out result2);
	public static List<T> BreakFilter<T>(this T[] source, Func<T, int, bool> function, out List<T> result2) => List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, out result2);
	public static (List<T>, List<T>) BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable(source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this Span<T> source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this Span<T> source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source, function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this T[] source, Func<T, bool> function) => (List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, out var result2), result2);
	public static (List<T>, List<T>) BreakFilter<T>(this T[] source, Func<T, int, bool> function) => (List<T>.BreakFilterEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, out var result2), result2);
	public static List<TResult> Combine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static List<TResult> Combine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable(source, source2, function);
	public static List<TResult> Combine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static List<TResult> Combine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static List<TResult> Combine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static List<TResult> Combine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, int, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static List<(T, T2)> Combine<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) => List<T>.CombineEnumerable(source, source2);
	public static List<(T, T2)> Combine<T, T2>(this Span<T> source, Span<T2> source2) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static List<(T, T2)> Combine<T, T2>(this T[] source, T2[] source2) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan());
	public static List<TResult> Combine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable(source, source2, source3, function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), (ReadOnlySpan<T3>)source3.AsSpan(), function);
	public static List<TResult> Combine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, int, TResult> function) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), (ReadOnlySpan<T3>)source3.AsSpan(), function);
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3) => List<T>.CombineEnumerable(source, source2, source3);
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this Span<T> source, Span<T2> source2, Span<T3> source3) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3);
	public static List<(T, T2, T3)> Combine<T, T2, T3>(this T[] source, T2[] source2, T3[] source3) => List<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), (ReadOnlySpan<T3>)source3.AsSpan());
	public static List<TResult> Convert<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static List<TResult> Convert<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => List<T>.ConvertEnumerable(source, function);
	public static List<TResult> Convert<T, TResult>(this Span<T> source, Func<T, TResult> function) => List<T>.ConvertEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> Convert<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => List<T>.ConvertEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> Convert<T, TResult>(this T[] source, Func<T, TResult> function) => List<T>.ConvertEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<TResult> Convert<T, TResult>(this T[] source, Func<T, int, TResult> function) => List<T>.ConvertEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this ReadOnlySpan<T> source, Func<T, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable(source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this Span<T> source, Func<T, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this Span<T> source, Func<T, int, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this T[] source, Func<T, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<TResult> ConvertAndJoin<T, TResult>(this T[] source, Func<T, int, IEnumerable<TResult>> function) => List<T>.ConvertAndJoinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Count<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.CountEnumerable(source, function);
	public static int Count<T>(this Span<T> source, Func<T, bool> function) => List<T>.CountEnumerable((ReadOnlySpan<T>)source, function);
	public static int Count<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.CountEnumerable((ReadOnlySpan<T>)source, function);
	public static int Count<T>(this T[] source, Func<T, bool> function) => List<T>.CountEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Count<T>(this T[] source, Func<T, int, bool> function) => List<T>.CountEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static bool Equals<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable(source, source2, function);
	public static bool Equals<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool Equals<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool Equals<T, T2>(this T[] source, T2[] source2, Func<T, T2, bool> function) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static bool Equals<T, T2>(this T[] source, T2[] source2, Func<T, T2, int, bool> function) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static bool Equals<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) => List<T>.EqualsEnumerable(source, source2);
	public static bool Equals<T, T2>(this Span<T> source, Span<T2> source2) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static bool Equals<T, T2>(this T[] source, T2[] source2) => List<T>.EqualsEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan());
	public static List<T> Filter<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FilterEnumerable(source, function);
	public static List<T> Filter<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FilterEnumerable(source, function);
	public static List<T> Filter<T>(this Span<T> source, Func<T, bool> function) => List<T>.FilterEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> Filter<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FilterEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> Filter<T>(this T[] source, Func<T, bool> function) => List<T>.FilterEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> Filter<T>(this T[] source, Func<T, int, bool> function) => List<T>.FilterEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? Find<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FindEnumerable(source, function);
	public static T? Find<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FindEnumerable(source, function);
	public static T? Find<T>(this Span<T> source, Func<T, bool> function) => List<T>.FindEnumerable((ReadOnlySpan<T>)source, function);
	public static T? Find<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FindEnumerable((ReadOnlySpan<T>)source, function);
	public static T? Find<T>(this T[] source, Func<T, bool> function) => List<T>.FindEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? Find<T>(this T[] source, Func<T, int, bool> function) => List<T>.FindEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAll<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAll<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FindAllEnumerable(source, function);
	public static List<T> FindAll<T>(this Span<T> source, Func<T, bool> function) => List<T>.FindAllEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAll<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FindAllEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAll<T>(this T[] source, Func<T, bool> function) => List<T>.FindAllEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAll<T>(this T[] source, Func<T, int, bool> function) => List<T>.FindAllEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMaxEnumerable(source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMax<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindAllMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMeanEnumerable(source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindAllMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMedianEnumerable(source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMedian<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindAllMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, decimal> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, double> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, double> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, double> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, int> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, uint> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, long> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, long> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, long> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMinEnumerable(source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> FindAllMin<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindAllMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLast<T>(this ReadOnlySpan<T> source, Func<T, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static T? FindLast<T>(this ReadOnlySpan<T> source, Func<T, int, bool> function) => List<T>.FindLastEnumerable(source, function);
	public static T? FindLast<T>(this Span<T> source, Func<T, bool> function) => List<T>.FindLastEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLast<T>(this Span<T> source, Func<T, int, bool> function) => List<T>.FindLastEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLast<T>(this T[] source, Func<T, bool> function) => List<T>.FindLastEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLast<T>(this T[] source, Func<T, int, bool> function) => List<T>.FindLastEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxEnumerable(source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMax<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMax<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanEnumerable(source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianEnumerable(source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMedian<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMinEnumerable(source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindLastMin<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindLastMin<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable(source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMaxIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable(source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMeanIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable(source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMedianIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMinIndexEnumerable(source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindLastMinIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindLastMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, double> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, int> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, uint> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, long> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxEnumerable(source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMax<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMax<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, double> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, int> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, uint> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, long> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanEnumerable(source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, double> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, int> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, uint> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, long> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianEnumerable(source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMedian<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMedian<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, double> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, int> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, uint> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, long> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinEnumerable(source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source, function);
	public static T? FindMin<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static T? FindMin<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, double> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, uint> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, long> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexesEnumerable(source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMaxIndexes<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, double> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, uint> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, long> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexesEnumerable(source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMeanIndexes<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, double> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, uint> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, long> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexesEnumerable(source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMedianIndexes<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, double> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, uint> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, long> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexesEnumerable(source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> FindMinIndexes<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexEnumerable(source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMaxIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMaxIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexEnumerable(source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMeanIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMeanIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexEnumerable(source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMedianIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMedianIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, decimal> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, decimal> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, decimal> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, double> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, double> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, double> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, double> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, int> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, int> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, uint> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, uint> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, uint> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, long> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, long> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, long> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, long> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexEnumerable(source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source, function);
	public static int FindMinIndex<T>(this T[] source, Func<T, mpz_t> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int FindMinIndex<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.FindMinIndexEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static void ForEach<T>(this ReadOnlySpan<T> source, Action<T> action) => List<T>.ForEachEnumerable(source, action);
	public static void ForEach<T>(this ReadOnlySpan<T> source, Action<T, int> action) => List<T>.ForEachEnumerable(source, action);
	public static void ForEach<T>(this Span<T> source, Action<T> action) => List<T>.ForEachEnumerable((ReadOnlySpan<T>)source, action);
	public static void ForEach<T>(this Span<T> source, Action<T, int> action) => List<T>.ForEachEnumerable((ReadOnlySpan<T>)source, action);
	public static void ForEach<T>(this T[] source, Action<T> action) => List<T>.ForEachEnumerable((ReadOnlySpan<T>)source.AsSpan(), action);
	public static void ForEach<T>(this T[] source, Action<T, int> action) => List<T>.ForEachEnumerable((ReadOnlySpan<T>)source.AsSpan(), action);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<(T Key, int Count)> FrequencyTable<T>(this ReadOnlySpan<T> source) where T : notnull => List<T>.FrequencyTableEnumerable(source);
	public static List<(T Key, int Count)> FrequencyTable<T>(this Span<T> source) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source);
	public static List<(T Key, int Count)> FrequencyTable<T>(this T[] source) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<(TResult Key, int Count)> FrequencyTable<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable(source, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<(T Key, int Count)> FrequencyTable<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.FrequencyTableEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable(source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source) where T : notnull => List<T>.GroupEnumerable(source);
	public static List<Group<T, T>> Group<T>(this Span<T> source) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source);
	public static List<Group<T, T>> Group<T>(this T[] source) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable(source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, comparer);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable(source, comparer);
	public static List<Group<T, T>> Group<T>(this Span<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, comparer);
	public static List<Group<T, T>> Group<T>(this T[] source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), comparer);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction);
	public static List<Group<T, T>> Group<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<Group<T, T>> Group<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<Group<T, TResult>> Group<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<Group<T, T>> Group<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source) where T : notnull => List<T>.GroupIndexesEnumerable(source);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable(source, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, comparer);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source, IEqualityComparer<T> comparer) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), comparer);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<Group<int, TResult>> GroupIndexes<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable(source, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<Group<int, T>> GroupIndexes<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.GroupIndexesEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction, hashCodeFunction);
	public static List<int> IndexesOf<T>(this ReadOnlySpan<T> source, T target) => List<T>.IndexesOfEnumerable(source, target);
	public static List<int> IndexesOf<T>(this Span<T> source, T target) => List<T>.IndexesOfEnumerable((ReadOnlySpan<T>)source, target);
	public static List<int> IndexesOf<T>(this T[] source, T target) => List<T>.IndexesOfEnumerable((ReadOnlySpan<T>)source.AsSpan(), target);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, double> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, uint> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, long> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMaxEnumerable(source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this Span<decimal> source) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	public static List<int> IndexesOfMax(this decimal[] source) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static List<int> IndexesOfMax(this ReadOnlySpan<double> source) => List<double>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this Span<double> source) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<double>)source);
	public static List<int> IndexesOfMax(this double[] source) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static List<int> IndexesOfMax(this ReadOnlySpan<int> source) => List<int>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this Span<int> source) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<int>)source);
	public static List<int> IndexesOfMax(this int[] source) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static List<int> IndexesOfMax(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this Span<uint> source) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<uint>)source);
	public static List<int> IndexesOfMax(this uint[] source) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static List<int> IndexesOfMax(this ReadOnlySpan<long> source) => List<long>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this Span<long> source) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<long>)source);
	public static List<int> IndexesOfMax(this long[] source) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static List<int> IndexesOfMax(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMaxEnumerable(source);
	public static List<int> IndexesOfMax(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<mpz_t>)source);
	public static List<int> IndexesOfMax(this mpz_t[] source) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, double> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, uint> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, long> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMeanEnumerable(source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this Span<decimal> source) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	public static List<int> IndexesOfMean(this decimal[] source) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static List<int> IndexesOfMean(this ReadOnlySpan<double> source) => List<double>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this Span<double> source) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<double>)source);
	public static List<int> IndexesOfMean(this double[] source) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static List<int> IndexesOfMean(this ReadOnlySpan<int> source) => List<int>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this Span<int> source) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<int>)source);
	public static List<int> IndexesOfMean(this int[] source) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static List<int> IndexesOfMean(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this Span<uint> source) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<uint>)source);
	public static List<int> IndexesOfMean(this uint[] source) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static List<int> IndexesOfMean(this ReadOnlySpan<long> source) => List<long>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this Span<long> source) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<long>)source);
	public static List<int> IndexesOfMean(this long[] source) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static List<int> IndexesOfMean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMeanEnumerable(source);
	public static List<int> IndexesOfMean(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<mpz_t>)source);
	public static List<int> IndexesOfMean(this mpz_t[] source) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, double> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, uint> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, long> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMedianEnumerable(source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this Span<decimal> source) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	public static List<int> IndexesOfMedian(this decimal[] source) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static List<int> IndexesOfMedian(this ReadOnlySpan<double> source) => List<double>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this Span<double> source) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<double>)source);
	public static List<int> IndexesOfMedian(this double[] source) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static List<int> IndexesOfMedian(this ReadOnlySpan<int> source) => List<int>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this Span<int> source) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<int>)source);
	public static List<int> IndexesOfMedian(this int[] source) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static List<int> IndexesOfMedian(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this Span<uint> source) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<uint>)source);
	public static List<int> IndexesOfMedian(this uint[] source) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static List<int> IndexesOfMedian(this ReadOnlySpan<long> source) => List<long>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this Span<long> source) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<long>)source);
	public static List<int> IndexesOfMedian(this long[] source) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static List<int> IndexesOfMedian(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMedianEnumerable(source);
	public static List<int> IndexesOfMedian(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<mpz_t>)source);
	public static List<int> IndexesOfMedian(this mpz_t[] source) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, double> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, uint> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, long> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMinEnumerable(source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexesOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<int> IndexesOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this Span<decimal> source) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<decimal>)source);
	public static List<int> IndexesOfMin(this decimal[] source) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static List<int> IndexesOfMin(this ReadOnlySpan<double> source) => List<double>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this Span<double> source) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<double>)source);
	public static List<int> IndexesOfMin(this double[] source) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static List<int> IndexesOfMin(this ReadOnlySpan<int> source) => List<int>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this Span<int> source) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<int>)source);
	public static List<int> IndexesOfMin(this int[] source) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static List<int> IndexesOfMin(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this Span<uint> source) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<uint>)source);
	public static List<int> IndexesOfMin(this uint[] source) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static List<int> IndexesOfMin(this ReadOnlySpan<long> source) => List<long>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this Span<long> source) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<long>)source);
	public static List<int> IndexesOfMin(this long[] source) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static List<int> IndexesOfMin(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMinEnumerable(source);
	public static List<int> IndexesOfMin(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<mpz_t>)source);
	public static List<int> IndexesOfMin(this mpz_t[] source) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int IndexOf<T>(this ReadOnlySpan<T> source, T target) => List<T>.IndexOfEnumerable(source, target);
	public static int IndexOf<T>(this Span<T> source, T target) => List<T>.IndexOfEnumerable((ReadOnlySpan<T>)source, target);
	public static int IndexOf<T>(this T[] source, T target) => List<T>.IndexOfEnumerable((ReadOnlySpan<T>)source.AsSpan(), target);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMaxEnumerable(source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMax<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<decimal> source) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMax(this decimal[] source) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<double> source) => List<double>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<double> source) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMax(this double[] source) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<int> source) => List<int>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<int> source) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMax(this int[] source) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<uint> source) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMax(this uint[] source) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<long> source) => List<long>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<long> source) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMax(this long[] source) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMax(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMaxEnumerable(source);
	public static int IndexOfMax(this Span<mpz_t> source) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int IndexOfMax(this mpz_t[] source) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMeanEnumerable(source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<decimal> source) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMean(this decimal[] source) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<double> source) => List<double>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<double> source) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMean(this double[] source) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<int> source) => List<int>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<int> source) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMean(this int[] source) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<uint> source) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMean(this uint[] source) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<long> source) => List<long>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<long> source) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMean(this long[] source) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMeanEnumerable(source);
	public static int IndexOfMean(this Span<mpz_t> source) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int IndexOfMean(this mpz_t[] source) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMedianEnumerable(source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<decimal> source) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMedian(this decimal[] source) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<double> source) => List<double>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<double> source) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMedian(this double[] source) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<int> source) => List<int>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<int> source) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMedian(this int[] source) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<uint> source) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMedian(this uint[] source) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<long> source) => List<long>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<long> source) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMedian(this long[] source) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMedian(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMedianEnumerable(source);
	public static int IndexOfMedian(this Span<mpz_t> source) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int IndexOfMedian(this mpz_t[] source) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, decimal> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, double> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, double> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, double> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, int> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, uint> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, long> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, long> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, long> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMinEnumerable(source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int IndexOfMin<T>(this T[] source, Func<T, mpz_t> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.IndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int IndexOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<decimal> source) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<decimal>)source);
	public static int IndexOfMin(this decimal[] source) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<double> source) => List<double>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<double> source) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<double>)source);
	public static int IndexOfMin(this double[] source) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<int> source) => List<int>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<int> source) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<int>)source);
	public static int IndexOfMin(this int[] source) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<uint> source) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<uint>)source);
	public static int IndexOfMin(this uint[] source) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<long> source) => List<long>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<long> source) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<long>)source);
	public static int IndexOfMin(this long[] source) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int IndexOfMin(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMinEnumerable(source);
	public static int IndexOfMin(this Span<mpz_t> source) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int IndexOfMin(this mpz_t[] source) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<List<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<List<T>> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source);
	public static List<T> JoinIntoSingle<T>(this List<T>[] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<List<T>>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<T[]> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<T[]> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source);
	public static List<T> JoinIntoSingle<T>(this T[][] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<T[]>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<G.IList<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<G.IList<T>> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source);
	public static List<T> JoinIntoSingle<T>(this G.IList<T>[] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<T>>)source.AsSpan());
	public static List<T> JoinIntoSingle<T>(this ReadOnlySpan<IEnumerable<T>> source) => List<T>.JoinIntoSingleEnumerable(source);
	public static List<T> JoinIntoSingle<T>(this Span<IEnumerable<T>> source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source);
	public static List<T> JoinIntoSingle<T>(this IEnumerable<T>[] source) => List<T>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<T>>)source.AsSpan());
	public static List<TResult> JoinIntoSingle<T, TResult>(this ReadOnlySpan<T> source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>(source);
	public static List<TResult> JoinIntoSingle<T, TResult>(this Span<T> source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>((ReadOnlySpan<T>)source);
	public static List<TResult> JoinIntoSingle<T, TResult>(this T[] source) where T : IEnumerable<TResult> => List<T>.JoinIntoSingleEnumerable<T, TResult>((ReadOnlySpan<T>)source.AsSpan());
	public static int LastIndexOf<T>(this ReadOnlySpan<T> source, T target) => List<T>.LastIndexOfEnumerable(source, target);
	public static int LastIndexOf<T>(this Span<T> source, T target) => List<T>.LastIndexOfEnumerable((ReadOnlySpan<T>)source, target);
	public static int LastIndexOf<T>(this T[] source, T target) => List<T>.LastIndexOfEnumerable((ReadOnlySpan<T>)source.AsSpan(), target);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable(source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMax(this decimal[] source) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<double> source) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMax(this double[] source) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<int> source) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMax(this int[] source) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<uint> source) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMax(this uint[] source) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<long> source) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMax(this long[] source) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMax(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMaxEnumerable(source);
	public static int LastIndexOfMax(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int LastIndexOfMax(this mpz_t[] source) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable(source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMean(this decimal[] source) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<double> source) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMean(this double[] source) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<int> source) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMean(this int[] source) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<uint> source) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMean(this uint[] source) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<long> source) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMean(this long[] source) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMeanEnumerable(source);
	public static int LastIndexOfMean(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int LastIndexOfMean(this mpz_t[] source) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable(source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMedian(this decimal[] source) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<double> source) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMedian(this double[] source) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<int> source) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMedian(this int[] source) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<uint> source) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMedian(this uint[] source) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<long> source) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMedian(this long[] source) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMedian(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMedianEnumerable(source);
	public static int LastIndexOfMedian(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int LastIndexOfMedian(this mpz_t[] source) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, decimal> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, decimal> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, double> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, double> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, int> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, uint> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, uint> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, long> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, long> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMinEnumerable(source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source, function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, mpz_t> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.LastIndexOfMinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int LastIndexOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<decimal> source) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<decimal>)source);
	public static int LastIndexOfMin(this decimal[] source) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<double> source) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<double>)source);
	public static int LastIndexOfMin(this double[] source) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<int> source) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<int>)source);
	public static int LastIndexOfMin(this int[] source) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<uint> source) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<uint>)source);
	public static int LastIndexOfMin(this uint[] source) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<long> source) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<long>)source);
	public static int LastIndexOfMin(this long[] source) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static int LastIndexOfMin(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMinEnumerable(source);
	public static int LastIndexOfMin(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source);
	public static int LastIndexOfMin(this mpz_t[] source) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static decimal Max<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MaxEnumerable(source, function);
	public static decimal Max<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Max<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Max<T>(this T[] source, Func<T, decimal> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Max<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Max<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MaxEnumerable(source, function);
	public static double Max<T>(this Span<T> source, Func<T, double> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static double Max<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static double Max<T>(this T[] source, Func<T, double> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Max<T>(this T[] source, Func<T, int, double> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Max<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MaxEnumerable(source, function);
	public static int Max<T>(this Span<T> source, Func<T, int> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int Max<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static int Max<T>(this T[] source, Func<T, int> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Max<T>(this T[] source, Func<T, int, int> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Max<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MaxEnumerable(source, function);
	public static uint Max<T>(this Span<T> source, Func<T, uint> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Max<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Max<T>(this T[] source, Func<T, uint> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Max<T>(this T[] source, Func<T, int, uint> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Max<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MaxEnumerable(source, function);
	public static long Max<T>(this Span<T> source, Func<T, long> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static long Max<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static long Max<T>(this T[] source, Func<T, long> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Max<T>(this T[] source, Func<T, int, long> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Max<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.MaxEnumerable(source, function);
	public static mpz_t Max<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.MaxEnumerable(source, function);
	public static mpz_t Max<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Max<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Max<T>(this T[] source, Func<T, mpz_t> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Max<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.MaxEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Max(this ReadOnlySpan<decimal> source) => List<decimal>.MaxEnumerable(source);
	public static decimal Max(this Span<decimal> source) => List<decimal>.MaxEnumerable((ReadOnlySpan<decimal>)source);
	public static double Max(this ReadOnlySpan<double> source) => List<double>.MaxEnumerable(source);
	public static double Max(this Span<double> source) => List<double>.MaxEnumerable((ReadOnlySpan<double>)source);
	public static int Max(this ReadOnlySpan<int> source) => List<int>.MaxEnumerable(source);
	public static int Max(this Span<int> source) => List<int>.MaxEnumerable((ReadOnlySpan<int>)source);
	public static uint Max(this ReadOnlySpan<uint> source) => List<uint>.MaxEnumerable(source);
	public static uint Max(this Span<uint> source) => List<uint>.MaxEnumerable((ReadOnlySpan<uint>)source);
	public static long Max(this ReadOnlySpan<long> source) => List<long>.MaxEnumerable(source);
	public static long Max(this Span<long> source) => List<long>.MaxEnumerable((ReadOnlySpan<long>)source);
	public static mpz_t Max(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MaxEnumerable(source);
	public static mpz_t Max(this Span<mpz_t> source) => List<mpz_t>.MaxEnumerable((ReadOnlySpan<mpz_t>)source);
	public static decimal Mean<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MeanEnumerable(source, function);
	public static decimal Mean<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Mean<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Mean<T>(this T[] source, Func<T, decimal> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Mean<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, double> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, double> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this T[] source, Func<T, int, double> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, int> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this T[] source, Func<T, int, int> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, uint> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, uint> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this T[] source, Func<T, int, uint> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, long> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, long> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this T[] source, Func<T, int, long> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.MeanEnumerable(source, function);
	public static double Mean<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source, function);
	public static double Mean<T>(this T[] source, Func<T, mpz_t> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Mean<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.MeanEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Mean(this ReadOnlySpan<decimal> source) => List<decimal>.MeanEnumerable(source);
	public static decimal Mean(this Span<decimal> source) => List<decimal>.MeanEnumerable((ReadOnlySpan<decimal>)source);
	public static double Mean(this ReadOnlySpan<double> source) => List<double>.MeanEnumerable(source);
	public static double Mean(this Span<double> source) => List<double>.MeanEnumerable((ReadOnlySpan<double>)source);
	public static double Mean(this ReadOnlySpan<int> source) => List<int>.MeanEnumerable(source);
	public static double Mean(this Span<int> source) => List<int>.MeanEnumerable((ReadOnlySpan<int>)source);
	public static double Mean(this ReadOnlySpan<uint> source) => List<uint>.MeanEnumerable(source);
	public static double Mean(this Span<uint> source) => List<uint>.MeanEnumerable((ReadOnlySpan<uint>)source);
	public static double Mean(this ReadOnlySpan<long> source) => List<long>.MeanEnumerable(source);
	public static double Mean(this Span<long> source) => List<long>.MeanEnumerable((ReadOnlySpan<long>)source);
	public static double Mean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MeanEnumerable(source);
	public static double Mean(this Span<mpz_t> source) => List<mpz_t>.MeanEnumerable((ReadOnlySpan<mpz_t>)source);
	public static decimal Median<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MedianEnumerable(source, function);
	public static decimal Median<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Median<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Median<T>(this T[] source, Func<T, decimal> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Median<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Median<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MedianEnumerable(source, function);
	public static double Median<T>(this Span<T> source, Func<T, double> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static double Median<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static double Median<T>(this T[] source, Func<T, double> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Median<T>(this T[] source, Func<T, int, double> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Median<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MedianEnumerable(source, function);
	public static int Median<T>(this Span<T> source, Func<T, int> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int Median<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static int Median<T>(this T[] source, Func<T, int> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Median<T>(this T[] source, Func<T, int, int> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Median<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MedianEnumerable(source, function);
	public static uint Median<T>(this Span<T> source, Func<T, uint> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Median<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Median<T>(this T[] source, Func<T, uint> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Median<T>(this T[] source, Func<T, int, uint> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Median<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MedianEnumerable(source, function);
	public static long Median<T>(this Span<T> source, Func<T, long> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static long Median<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static long Median<T>(this T[] source, Func<T, long> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Median<T>(this T[] source, Func<T, int, long> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Median<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.MedianEnumerable(source, function);
	public static mpz_t Median<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.MedianEnumerable(source, function);
	public static mpz_t Median<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Median<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Median<T>(this T[] source, Func<T, mpz_t> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Median<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.MedianEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Median(this ReadOnlySpan<decimal> source) => List<decimal>.MedianEnumerable(source);
	public static decimal Median(this Span<decimal> source) => List<decimal>.MedianEnumerable((ReadOnlySpan<decimal>)source);
	public static double Median(this ReadOnlySpan<double> source) => List<double>.MedianEnumerable(source);
	public static double Median(this Span<double> source) => List<double>.MedianEnumerable((ReadOnlySpan<double>)source);
	public static int Median(this ReadOnlySpan<int> source) => List<int>.MedianEnumerable(source);
	public static int Median(this Span<int> source) => List<int>.MedianEnumerable((ReadOnlySpan<int>)source);
	public static uint Median(this ReadOnlySpan<uint> source) => List<uint>.MedianEnumerable(source);
	public static uint Median(this Span<uint> source) => List<uint>.MedianEnumerable((ReadOnlySpan<uint>)source);
	public static long Median(this ReadOnlySpan<long> source) => List<long>.MedianEnumerable(source);
	public static long Median(this Span<long> source) => List<long>.MedianEnumerable((ReadOnlySpan<long>)source);
	public static mpz_t Median(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MedianEnumerable(source);
	public static mpz_t Median(this Span<mpz_t> source) => List<mpz_t>.MedianEnumerable((ReadOnlySpan<mpz_t>)source);
	public static decimal Min<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.MinEnumerable(source, function);
	public static decimal Min<T>(this Span<T> source, Func<T, decimal> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Min<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Min<T>(this T[] source, Func<T, decimal> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Min<T>(this T[] source, Func<T, int, decimal> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Min<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.MinEnumerable(source, function);
	public static double Min<T>(this Span<T> source, Func<T, double> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static double Min<T>(this Span<T> source, Func<T, int, double> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static double Min<T>(this T[] source, Func<T, double> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Min<T>(this T[] source, Func<T, int, double> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Min<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.MinEnumerable(source, function);
	public static int Min<T>(this Span<T> source, Func<T, int> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static int Min<T>(this Span<T> source, Func<T, int, int> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static int Min<T>(this T[] source, Func<T, int> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Min<T>(this T[] source, Func<T, int, int> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Min<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.MinEnumerable(source, function);
	public static uint Min<T>(this Span<T> source, Func<T, uint> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Min<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Min<T>(this T[] source, Func<T, uint> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Min<T>(this T[] source, Func<T, int, uint> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Min<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.MinEnumerable(source, function);
	public static long Min<T>(this Span<T> source, Func<T, long> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static long Min<T>(this Span<T> source, Func<T, int, long> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static long Min<T>(this T[] source, Func<T, long> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Min<T>(this T[] source, Func<T, int, long> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Min<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.MinEnumerable(source, function);
	public static mpz_t Min<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.MinEnumerable(source, function);
	public static mpz_t Min<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Min<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Min<T>(this T[] source, Func<T, mpz_t> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Min<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.MinEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Min(this ReadOnlySpan<decimal> source) => List<decimal>.MinEnumerable(source);
	public static decimal Min(this Span<decimal> source) => List<decimal>.MinEnumerable((ReadOnlySpan<decimal>)source);
	public static double Min(this ReadOnlySpan<double> source) => List<double>.MinEnumerable(source);
	public static double Min(this Span<double> source) => List<double>.MinEnumerable((ReadOnlySpan<double>)source);
	public static int Min(this ReadOnlySpan<int> source) => List<int>.MinEnumerable(source);
	public static int Min(this Span<int> source) => List<int>.MinEnumerable((ReadOnlySpan<int>)source);
	public static uint Min(this ReadOnlySpan<uint> source) => List<uint>.MinEnumerable(source);
	public static uint Min(this Span<uint> source) => List<uint>.MinEnumerable((ReadOnlySpan<uint>)source);
	public static long Min(this ReadOnlySpan<long> source) => List<long>.MinEnumerable(source);
	public static long Min(this Span<long> source) => List<long>.MinEnumerable((ReadOnlySpan<long>)source);
	public static mpz_t Min(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MinEnumerable(source);
	public static mpz_t Min(this Span<mpz_t> source) => List<mpz_t>.MinEnumerable((ReadOnlySpan<mpz_t>)source);
	public static T? Progression<T>(this ReadOnlySpan<T> source, Func<T, T, T> function) => List<T>.ProgressionEnumerable(source, function);
	public static T? Progression<T>(this Span<T> source, Func<T, T, T> function) => List<T>.ProgressionEnumerable((ReadOnlySpan<T>)source, function);
	public static T? Progression<T>(this T[] source, Func<T, T, T> function) => List<T>.ProgressionEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static TResult? Progression<T, TResult>(this ReadOnlySpan<T> source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable(source, seed, function);
	public static TResult? Progression<T, TResult>(this Span<T> source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable((ReadOnlySpan<T>)source, seed, function);
	public static TResult? Progression<T, TResult>(this T[] source, TResult seed, Func<TResult, T, TResult> function) => List<T>.ProgressionEnumerable((ReadOnlySpan<T>)source.AsSpan(), seed, function);
	public static T Random<T>(this ReadOnlySpan<T> source) => source[random.Next(source.Length)];
	public static T Random<T>(this Span<T> source) => source[random.Next(source.Length)];
	public static T Random<T>(this T[] source) => source[random.Next(source.Length)];
	public static T Random<T>(this ReadOnlySpan<T> source, Random randomObj) => source[randomObj.Next(source.Length)];
	public static T Random<T>(this Span<T> source, Random randomObj) => source[randomObj.Next(source.Length)];
	public static T Random<T>(this T[] source, Random randomObj) => source[randomObj.Next(source.Length)];
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable(source, function);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, TResult> function) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, int, TResult> function) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static List<T> RemoveDoubles<T>(this ReadOnlySpan<T> source) => List<T>.RemoveDoublesEnumerable(source);
	public static List<T> RemoveDoubles<T>(this Span<T> source) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source);
	public static List<T> RemoveDoubles<T>(this T[] source) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction);
	public static List<T> RemoveDoubles<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction);
	public static List<T> RemoveDoubles<T>(this Span<T> source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<T> RemoveDoubles<T>(this T[] source, Func<T, T, bool> equalFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this Span<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T, TResult>(this T[] source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<T> RemoveDoubles<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.RemoveDoublesEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction, hashCodeFunction);
	public static List<int> RepresentIntoNumbers<T>(this ReadOnlySpan<T> source) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source);
	public static List<int> RepresentIntoNumbers<T>(this Span<T> source) where T : notnull => List<T>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source);
	public static List<int> RepresentIntoNumbers<T>(this T[] source) where T : notnull => List<T>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static List<int> RepresentIntoNumbers<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static List<int> RepresentIntoNumbers<T>(this Span<T> source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source, equalFunction);
	public static List<int> RepresentIntoNumbers<T>(this T[] source, Func<T, T, bool> equalFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction);
	public static List<int> RepresentIntoNumbers<T>(this ReadOnlySpan<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static List<int> RepresentIntoNumbers<T>(this Span<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source, equalFunction, hashCodeFunction);
	public static List<int> RepresentIntoNumbers<T>(this T[] source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : notnull => List<T>.RepresentIntoNumbersEnumerable((ReadOnlySpan<T>)source.AsSpan(), equalFunction, hashCodeFunction);
	public static List<T> Reverse<T>(this ReadOnlySpan<T> source) => List<T>.ReverseEnumerable(source);
	public static List<T> Reverse<T>(this Span<T> source) => List<T>.ReverseEnumerable((ReadOnlySpan<T>)source);
	public static List<T> Reverse<T>(this T[] source) => List<T>.ReverseEnumerable((ReadOnlySpan<T>)source.AsSpan());
	public static Span<T> SetAll<T>(Span<T> source, T value) => List<T>.SetAllEnumerable(source, value);
	public static bool StartsWith<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable(source, source2, function);
	public static bool StartsWith<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool StartsWith<T, T2>(this Span<T> source, Span<T2> source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static bool StartsWith<T, T2>(this T[] source, T2[] source2, Func<T, T2, bool> function) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static bool StartsWith<T, T2>(this T[] source, T2[] source2, Func<T, T2, int, bool> function) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static bool StartsWith<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) => List<T>.StartsWithEnumerable(source, source2);
	public static bool StartsWith<T, T2>(this Span<T> source, Span<T2> source2) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static bool StartsWith<T, T2>(this T[] source, T2[] source2) => List<T>.StartsWithEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan());
	public static decimal Sum<T>(this ReadOnlySpan<T> source, Func<T, decimal> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum<T>(this ReadOnlySpan<T> source, Func<T, int, decimal> function) => List<T>.SumEnumerable(source, function);
	public static decimal Sum<T>(this Span<T> source, Func<T, decimal> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Sum<T>(this Span<T> source, Func<T, int, decimal> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static decimal Sum<T>(this T[] source, Func<T, decimal> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Sum<T>(this T[] source, Func<T, int, decimal> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Sum<T>(this ReadOnlySpan<T> source, Func<T, double> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this ReadOnlySpan<T> source, Func<T, int, double> function) => List<T>.SumEnumerable(source, function);
	public static double Sum<T>(this Span<T> source, Func<T, double> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static double Sum<T>(this Span<T> source, Func<T, int, double> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static double Sum<T>(this T[] source, Func<T, double> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static double Sum<T>(this T[] source, Func<T, int, double> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Sum<T>(this ReadOnlySpan<T> source, Func<T, int> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this ReadOnlySpan<T> source, Func<T, int, int> function) => List<T>.SumEnumerable(source, function);
	public static int Sum<T>(this Span<T> source, Func<T, int> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static int Sum<T>(this Span<T> source, Func<T, int, int> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static int Sum<T>(this T[] source, Func<T, int> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static int Sum<T>(this T[] source, Func<T, int, int> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Sum<T>(this ReadOnlySpan<T> source, Func<T, uint> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this ReadOnlySpan<T> source, Func<T, int, uint> function) => List<T>.SumEnumerable(source, function);
	public static uint Sum<T>(this Span<T> source, Func<T, uint> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Sum<T>(this Span<T> source, Func<T, int, uint> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static uint Sum<T>(this T[] source, Func<T, uint> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static uint Sum<T>(this T[] source, Func<T, int, uint> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Sum<T>(this ReadOnlySpan<T> source, Func<T, long> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this ReadOnlySpan<T> source, Func<T, int, long> function) => List<T>.SumEnumerable(source, function);
	public static long Sum<T>(this Span<T> source, Func<T, long> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static long Sum<T>(this Span<T> source, Func<T, int, long> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static long Sum<T>(this T[] source, Func<T, long> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static long Sum<T>(this T[] source, Func<T, int, long> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Sum<T>(this ReadOnlySpan<T> source, Func<T, mpz_t> function) => List<T>.SumEnumerable(source, function);
	public static mpz_t Sum<T>(this ReadOnlySpan<T> source, Func<T, int, mpz_t> function) => List<T>.SumEnumerable(source, function);
	public static mpz_t Sum<T>(this Span<T> source, Func<T, mpz_t> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Sum<T>(this Span<T> source, Func<T, int, mpz_t> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source, function);
	public static mpz_t Sum<T>(this T[] source, Func<T, mpz_t> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static mpz_t Sum<T>(this T[] source, Func<T, int, mpz_t> function) => List<T>.SumEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static decimal Sum(this ReadOnlySpan<decimal> source) => List<decimal>.SumEnumerable(source);
	public static decimal Sum(this Span<decimal> source) => List<decimal>.SumEnumerable((ReadOnlySpan<decimal>)source);
	public static decimal Sum(this decimal[] source) => List<decimal>.SumEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	public static double Sum(this ReadOnlySpan<double> source) => List<double>.SumEnumerable(source);
	public static double Sum(this Span<double> source) => List<double>.SumEnumerable((ReadOnlySpan<double>)source);
	public static double Sum(this double[] source) => List<double>.SumEnumerable((ReadOnlySpan<double>)source.AsSpan());
	public static int Sum(this ReadOnlySpan<int> source) => List<int>.SumEnumerable(source);
	public static int Sum(this Span<int> source) => List<int>.SumEnumerable((ReadOnlySpan<int>)source);
	public static int Sum(this int[] source) => List<int>.SumEnumerable((ReadOnlySpan<int>)source.AsSpan());
	public static uint Sum(this ReadOnlySpan<uint> source) => List<uint>.SumEnumerable(source);
	public static uint Sum(this Span<uint> source) => List<uint>.SumEnumerable((ReadOnlySpan<uint>)source);
	public static uint Sum(this uint[] source) => List<uint>.SumEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	public static long Sum(this ReadOnlySpan<long> source) => List<long>.SumEnumerable(source);
	public static long Sum(this Span<long> source) => List<long>.SumEnumerable((ReadOnlySpan<long>)source);
	public static long Sum(this long[] source) => List<long>.SumEnumerable((ReadOnlySpan<long>)source.AsSpan());
	public static mpz_t Sum(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.SumEnumerable(source);
	public static mpz_t Sum(this Span<mpz_t> source) => List<mpz_t>.SumEnumerable((ReadOnlySpan<mpz_t>)source);
	public static mpz_t Sum(this mpz_t[] source) => List<mpz_t>.SumEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	public static TResult[] ToArray<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) => List<T>.ToArrayEnumerable(source, function);
	public static TResult[] ToArray<T, TResult>(this Span<T> source, Func<T, TResult> function) => List<T>.ToArrayEnumerable((ReadOnlySpan<T>)source, function);
	public static TResult[] ToArray<T, TResult>(this Span<T> source, Func<T, int, TResult> function) => List<T>.ToArrayEnumerable((ReadOnlySpan<T>)source, function);
	public static BitList ToBitList(this ReadOnlySpan<bool> source) => new(source.ToArray());
	public static BitList ToBitList(this ReadOnlySpan<byte> source) => new(source.ToArray());
	public static BitList ToBitList(this ReadOnlySpan<int> source) => new(source.ToArray());
	public static BitList ToBitList(this ReadOnlySpan<uint> source) => new(source);
	public static BitList ToBitList(this Span<bool> source) => new(source.ToArray());
	public static BitList ToBitList(this Span<byte> source) => new(source.ToArray());
	public static BitList ToBitList(this Span<int> source) => new(source.ToArray());
	public static BitList ToBitList(this Span<uint> source) => new(source);
	public static BitList ToBitList(this bool[] source) => new(source);
	public static BitList ToBitList(this byte[] source) => new(source);
	public static BitList ToBitList(this int[] source) => new(source);
	public static BitList ToBitList(this uint[] source) => new(source);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) => List<T>.PBreakEnumerable(source, function, function2);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) => List<T>.PBreakEnumerable(source, function, function2);
	public static (List<T>, List<T2>) PBreak<T, T2>(this G.IList<(T, T2)> source) => List<T>.PBreakEnumerable(source);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, (TResult, TResult2)> function) => List<T>.PBreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>) PBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, int, (TResult, TResult2)> function) => List<T>.PBreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) => List<T>.PBreakEnumerable(source, function, function2, function3);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) => List<T>.PBreakEnumerable(source, function, function2, function3);
	public static (List<T>, List<T2>, List<T3>) PBreak<T, T2, T3>(this G.IList<(T, T2, T3)> source) => List<T>.PBreakEnumerable(source);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, (TResult, TResult2, TResult3)> function) => List<T>.PBreakEnumerable(source, function);
	public static (List<TResult>, List<TResult2>, List<TResult3>) PBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) => List<T>.PBreakEnumerable(source, function);
	public static List<TResult> PCombine<T, T2, TResult>(this G.IList<T> source, G.IList<T2> source2, Func<T, T2, TResult> function) => List<T>.PCombineEnumerable(source, source2, function);
	public static List<TResult> PCombine<T, T2, TResult>(this G.IList<T> source, G.IList<T2> source2, Func<T, T2, int, TResult> function) => List<T>.PCombineEnumerable(source, source2, function);
	public static List<(T, T2)> PCombine<T, T2>(this G.IList<T> source, G.IList<T2> source2) => List<T>.PCombineEnumerable(source, source2);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, TResult> function) => List<T>.PCombineEnumerable(source, source2, source3, function);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, int, TResult> function) => List<T>.PCombineEnumerable(source, source2, source3, function);
	public static List<(T, T2, T3)> PCombine<T, T2, T3>(this G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3) => List<T>.PCombineEnumerable(source, source2, source3);
	public static List<TResult> PCombine<T, T2, TResult>(this (G.IList<T>, G.IList<T2>) source, Func<T, T2, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, function);
	public static List<TResult> PCombine<T, T2, TResult>(this (G.IList<T>, G.IList<T2>) source, Func<T, T2, int, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, function);
	public static List<(T, T2)> PCombine<T, T2>(this (G.IList<T>, G.IList<T2>) source) => List<T>.PCombineEnumerable(source.Item1, source.Item2);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this (G.IList<T>, G.IList<T2>, G.IList<T3>) source, Func<T, T2, T3, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static List<TResult> PCombine<T, T2, T3, TResult>(this (G.IList<T>, G.IList<T2>, G.IList<T3>) source, Func<T, T2, T3, int, TResult> function) => List<T>.PCombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	public static List<(T, T2, T3)> PCombine<T, T2, T3>(this (G.IList<T>, G.IList<T2>, G.IList<T3>) source) => List<T>.PCombineEnumerable(source.Item1, source.Item2, source.Item3);
	public static bool PContains<T>(this G.IList<T> source, T target) => List<T>.PContainsEnumerable(source, target);
	public static bool PContains<T>(this G.IList<T> source, T target, IEqualityComparer<T> comparer) => List<T>.PContainsEnumerable(source, target, comparer);
	public static bool PContains<T>(this G.IList<T> source, T target, Func<T, T, bool> equalFunction) => List<T>.PContainsEnumerable(source, target, equalFunction);
	public static bool PContains<T>(this G.IList<T> source, T target, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) => List<T>.PContainsEnumerable(source, target, equalFunction, hashCodeFunction);
	public static List<TResult> PConvert<T, TResult>(this G.IList<T> source, Func<T, TResult> function) => List<T>.PConvertEnumerable(source, function);
	public static List<TResult> PConvert<T, TResult>(this G.IList<T> source, Func<T, int, TResult> function) => List<T>.PConvertEnumerable(source, function);
	public static List<TResult> PFill<TResult>(TResult elem, int length) => List<bool>.PFillEnumerable(elem, length);
	public static List<TResult> PFill<TResult>(Func<int, TResult> function, int length) => List<bool>.PFillEnumerable(function, length);
	public static List<TResult> PFill<TResult>(int length, Func<int, TResult> function) => List<bool>.PFillEnumerable(function, length);
	public static TResult[] PFillArray<TResult>(TResult elem, int length) => List<bool>.PFillArrayEnumerable(elem, length);
	public static TResult[] PFillArray<TResult>(Func<int, TResult> function, int length) => List<bool>.PFillArrayEnumerable(function, length);
	public static TResult[] PFillArray<TResult>(int length, Func<int, TResult> function) => List<bool>.PFillArrayEnumerable(function, length);
	public static List<T> PFilter<T>(this G.IList<T> source, Func<T, bool> function) => List<T>.PFilterEnumerable(source, function);
	public static List<T> PFilter<T>(this G.IList<T> source, Func<T, int, bool> function) => List<T>.PFilterEnumerable(source, function);
	public static TResult[] PToArray<T, TResult>(this G.IList<T> source, Func<T, TResult> function) => List<T>.PToArrayEnumerable(source, function);
	public static TResult[] PToArray<T, TResult>(this G.IList<T> source, Func<T, int, TResult> function) => List<T>.PToArrayEnumerable(source, function);
	public static T[] PToArray<T>(this G.IList<T> source) => List<T>.PToArrayEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this IEnumerable<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this IEnumerable<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this IEnumerable<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this ReadOnlySpan<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this Span<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this (T, T2)[] source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2)>)source.AsSpan());
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this Span<T> source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this T[] source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this ReadOnlySpan<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this Span<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this (T, T2, T3)[] source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<(T, T2, T3)>)source.AsSpan());
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this ReadOnlySpan<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this Span<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this T[] source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function, function2);
	public static (NList<T>, NList<T2>) NBreak<T, T2>(this NList<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<T, TResult, TResult2>(this NList<T> source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) NBreak<T, T2, T3>(this NList<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<T, TResult, TResult2, TResult3>(this NList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.BreakEnumerable(source, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this Span<T> source, Span<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static NList<TResult> NCombine<T, T2, TResult>(this T[] source, T2[] source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), function);
	public static NList<(T, T2)> NCombine<T, T2>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<(T, T2)> NCombine<T, T2>(this Span<T> source, Span<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2);
	public static NList<(T, T2)> NCombine<T, T2>(this T[] source, T2[] source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan());
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this Span<T> source, Span<T2> source2, Span<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), (ReadOnlySpan<T3>)source3.AsSpan(), function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this T[] source, T2[] source2, T3[] source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), (ReadOnlySpan<T3>)source3.AsSpan(), function);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this ReadOnlySpan<T> source, ReadOnlySpan<T2> source2, ReadOnlySpan<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this Span<T> source, Span<T2> source2, Span<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source, (ReadOnlySpan<T2>)source2, (ReadOnlySpan<T3>)source3);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this T[] source, T2[] source2, T3[] source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable((ReadOnlySpan<T>)source.AsSpan(), (ReadOnlySpan<T2>)source2.AsSpan(), (ReadOnlySpan<T3>)source3.AsSpan());
	public static NList<TResult> NCombine<T, T2, TResult>(this NList<T> source, NList<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<T, T2, TResult>(this NList<T> source, NList<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where T2 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<(T, T2)> NCombine<T, T2>(this NList<T> source, NList<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<T, T2, T3, TResult>(this NList<T> source, NList<T2> source2, NList<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where T2 : unmanaged where T3 : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<(T, T2, T3)> NCombine<T, T2, T3>(this NList<T> source, NList<T2> source2, NList<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> NConvert<T, TResult>(this IEnumerable<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<T, TResult>(this IEnumerable<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<T, TResult>(this ReadOnlySpan<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<T, TResult>(this ReadOnlySpan<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<T, TResult>(this Span<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<TResult> NConvert<T, TResult>(this Span<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable((ReadOnlySpan<T>)source, function);
	public static NList<TResult> NConvert<T, TResult>(this T[] source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static NList<TResult> NConvert<T, TResult>(this T[] source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable((ReadOnlySpan<T>)source.AsSpan(), function);
	public static NList<TResult> NConvert<T, TResult>(this NList<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<T, TResult>(this NList<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvertAndJoin<T, TResult>(this NList<T> source, Func<T, IEnumerable<TResult>> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertAndJoinEnumerable(source, function);
	public static NList<TResult> NConvertAndJoin<T, TResult>(this NList<T> source, Func<T, int, IEnumerable<TResult>> function) where T : unmanaged where TResult : unmanaged => NList<T>.ConvertAndJoinEnumerable(source, function);
	public static NList<T> NEmptyList<T>(int length) where T : unmanaged => NList<T>.EmptyListEnumerable(length);
	public static NList<TResult> NFill<TResult>(TResult elem, int length) where TResult : unmanaged => NList<TResult>.FillEnumerable(elem, length);
	public static NList<TResult> NFill<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged => NList<TResult>.FillEnumerable(function, length);
	public static NList<TResult> NFill<TResult>(int length, Func<int, TResult> function) where TResult : unmanaged => NList<TResult>.FillEnumerable(function, length);
	public static NList<T> NFilter<T>(this NList<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.FilterEnumerable(source, function);
	public static NList<T> NFilter<T>(this NList<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.FilterEnumerable(source, function);
	public static NList<T> NFindAll<T>(this NList<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.FindAllEnumerable(source, function);
	public static NList<T> NFindAll<T>(this NList<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.FindAllEnumerable(source, function);
	public static NList<int> NIndexesOf<T>(this NList<T> source, T target) where T : unmanaged => NList<T>.IndexesOfEnumerable(source, target);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function);
	public static NList<T> NRemoveDoubles<T>(this NList<T> source) where T : unmanaged => NList<T>.RemoveDoublesEnumerable(source);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static NList<T> NRemoveDoubles<T>(this NList<T> source, Func<T, T, bool> equalFunction) where T : unmanaged => NList<T>.RemoveDoublesEnumerable(source, equalFunction);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static NList<T> NRemoveDoubles<T, TResult>(this NList<T> source, Func<T, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where T : unmanaged where TResult : unmanaged => NList<T>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static NList<T> NRemoveDoubles<T>(this NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : unmanaged => NList<T>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<int> NRepresentIntoNumbers<T>(this NList<T> source) where T : unmanaged => NList<T>.RepresentIntoNumbersEnumerable(source);
	public static NList<int> NRepresentIntoNumbers<T>(this NList<T> source, Func<T, T, bool> equalFunction) where T : unmanaged => NList<T>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static NList<int> NRepresentIntoNumbers<T>(this NList<T> source, Func<T, T, bool> equalFunction, Func<T, int> hashCodeFunction) where T : unmanaged => NList<T>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<T> NReverse<T>(this NList<T> source) where T : unmanaged => NList<T>.ReverseEnumerable(source);
	public static Slice<T> NSkipWhile<T>(this IEnumerable<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.SkipWhileEnumerable(source, function);
	public static Slice<T> NSkipWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.SkipWhileEnumerable(source, function);
	public static List<NList<T>> NSplitIntoEqual<T>(this NList<T> source, int fragmentLength) where T : unmanaged => NList<T>.SplitIntoEqualEnumerable(source, fragmentLength);
	public static Slice<T> NTake<T>(this IEnumerable<T> source, int length) where T : unmanaged => NList<T>.TakeEnumerable(source, length);
	public static Slice<T> NTakeWhile<T>(this IEnumerable<T> source, Func<T, bool> function) where T : unmanaged => NList<T>.TakeWhileEnumerable(source, function);
	public static Slice<T> NTakeWhile<T>(this IEnumerable<T> source, Func<T, int, bool> function) where T : unmanaged => NList<T>.TakeWhileEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.PBreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.PBreakEnumerable(source, function, function2);
	public static (NList<T>, NList<T2>) PNBreak<T, T2>(this G.IList<(T, T2)> source) where T : unmanaged where T2 : unmanaged => NList<T>.PBreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.PBreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) PNBreak<T, TResult, TResult2>(this G.IList<T> source, Func<T, int, (TResult, TResult2)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<T>.PBreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, TResult> function, Func<T, TResult2> function2, Func<T, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.PBreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, int, TResult> function, Func<T, int, TResult2> function2, Func<T, int, TResult3> function3) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.PBreakEnumerable(source, function, function2, function3);
	public static (NList<T>, NList<T2>, NList<T3>) PNBreak<T, T2, T3>(this G.IList<(T, T2, T3)> source) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.PBreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.PBreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) PNBreak<T, TResult, TResult2, TResult3>(this G.IList<T> source, Func<T, int, (TResult, TResult2, TResult3)> function) where T : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<T>.PBreakEnumerable(source, function);
	public static NList<TResult> PNCombine<T, T2, TResult>(this G.IList<T> source, G.IList<T2> source2, Func<T, T2, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<TResult> PNCombine<T, T2, TResult>(this G.IList<T> source, G.IList<T2> source2, Func<T, T2, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, function);
	public static NList<(T, T2)> PNCombine<T, T2>(this G.IList<T> source, G.IList<T2> source2) where T : unmanaged where T2 : unmanaged => NList<T>.CombineEnumerable(source, source2);
	public static NList<TResult> PNCombine<T, T2, T3, TResult>(this G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> PNCombine<T, T2, T3, TResult>(this G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3, Func<T, T2, T3, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.CombineEnumerable(source, source2, source3, function);
	public static NList<(T, T2, T3)> PNCombine<T, T2, T3>(this G.IList<T> source, G.IList<T2> source2, G.IList<T3> source3) where T : unmanaged where T2 : unmanaged where T3 : unmanaged => NList<T>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> PNConvert<T, TResult>(this G.IList<T> source, Func<T, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.PConvertEnumerable(source, function);
	public static NList<TResult> PNConvert<T, TResult>(this G.IList<T> source, Func<T, int, TResult> function) where T : unmanaged where TResult : unmanaged => NList<T>.PConvertEnumerable(source, function);
	public static NList<TResult> PNFill<TResult>(TResult elem, int length) where TResult : unmanaged => NList<TResult>.PFillEnumerable(elem, length);
	public static NList<TResult> PNFill<TResult>(Func<int, TResult> function, int length) where TResult : unmanaged => NList<TResult>.PFillEnumerable(function, length);
	public static NList<TResult> PNFill<TResult>(int length, Func<int, TResult> function) where TResult : unmanaged => NList<TResult>.PFillEnumerable(function, length);
}
