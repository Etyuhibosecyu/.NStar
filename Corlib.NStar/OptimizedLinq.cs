using Mpir.NET;
#if !RELEASE
using NativeFunctions;
#endif
using System.Collections;
using System.Text;
using static Corlib.NStar.Extents;

namespace Corlib.NStar;
public partial class List<T, TCertain>
{
	internal static bool AllEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
				if (!function(list._items[i]))
					return false;
			return true;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
				if (!function(array[i]))
					return false;
			return true;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
				if (!function(list2[i]))
					return false;
			return true;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (!function(item))
					return false;
				i++;
			}
			return true;
		}
		else
			return AllEnumerable(new List<TSource>(source), function);
	}

	internal static bool AllEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (!function(item, i))
					return false;
			}
			return true;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (!function(item, i))
					return false;
				i++;
			}
			return true;
		}
		else
			return AllEnumerable(new List<TSource>(source), function);
	}

	internal static bool AnyEnumerable<TSource>(IEnumerable<TSource> source)
	{
		if (source is List<TSource> list)
		{
			if (list._size != 0)
				return true;
			return false;
		}
		else if (source is TSource[] array)
		{
			if (array.Length != 0)
				return true;
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			if (list2.Count != 0)
				return true;
			return false;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			if (count != 0)
				return true;
			return false;
		}
		else
			return source.GetEnumerator().MoveNext();
	}

	internal static bool AnyEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
				if (function(list._items[i]))
					return true;
			return false;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
				if (function(array[i]))
					return true;
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
				if (function(list2[i]))
					return true;
			return false;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item))
					return true;
				i++;
			}
			return false;
		}
		else
			return AnyEnumerable(new List<TSource>(source), function);
	}

	internal static bool AnyEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item, i))
					return true;
			}
			return false;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item, i))
					return true;
				i++;
			}
			return false;
		}
		else
			return AnyEnumerable(new List<TSource>(source), function);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2);
	}

	internal static (List<TSource>, List<TSource2>) BreakEnumerable<TSource, TSource2>(IEnumerable<(TSource, TSource2)> source)
	{
		if (source is List<(TSource, TSource2)> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i]) = list._items[i];
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is (TSource, TSource2)[] array)
		{
			int count = array.Length;
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i]) = array[i];
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<(TSource, TSource2)> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i]) = list2[i];
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int i = 0;
			foreach ((TSource, TSource2) item in source)
			{
				(result._items[i], result2._items[i]) = item;
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<(TSource, TSource2)>(source));
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i]) = function(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i]) = function(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2, function3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2, function3);
	}

	internal static (List<TSource>, List<TSource2>, List<TSource3>) BreakEnumerable<TSource, TSource2, TSource3>(IEnumerable<(TSource, TSource2, TSource3)> source)
	{
		if (source is List<(TSource, TSource2, TSource3)> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			List<TSource3> result3 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list._items[i];
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is (TSource, TSource2, TSource3)[] array)
		{
			int count = array.Length;
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			List<TSource3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = array[i];
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<(TSource, TSource2, TSource3)> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			List<TSource3> result3 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list2[i];
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			List<TSource3> result3 = new(count);
			int i = 0;
			foreach ((TSource, TSource2, TSource3) item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = item;
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<(TSource, TSource2, TSource3)>(source));
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			List<TResult2> result2 = new(count);
			List<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				result._items[i] = function(item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				result._items[i] = function(item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				result._items[i] = function(item, item2);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static List<(TSource, TSource2)> CombineEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2)
	{
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<(TSource, TSource2)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				result._items[i] = (item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<(TSource, TSource2)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				result._items[i] = (item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<(TSource, TSource2)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				result._items[i] = (item, item2);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2));
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2 && source3 is List<TSource3> list3)
		{
			int count = MinEnumerable(new[] { list._size, list2._size, list3._size }.AsSpan());
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				TSource3 item3 = list3._items[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2 && source3 is TSource3[] array3)
		{
			int count = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				TSource3 item3 = array3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2 && source3 is G.IList<TSource3> list2_3)
		{
			int count = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				TSource3 item3 = list2_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), ReturnOrConstruct(source3), function);
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2 && source3 is List<TSource3> list3)
		{
			int count = MinEnumerable(new[] { list._size, list2._size, list3._size }.AsSpan());
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				TSource3 item3 = list3._items[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2 && source3 is TSource3[] array3)
		{
			int count = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				TSource3 item3 = array3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2 && source3 is G.IList<TSource3> list2_3)
		{
			int count = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				TSource3 item3 = list2_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), ReturnOrConstruct(source3), function);
	}

	internal static List<(TSource, TSource2, TSource3)> CombineEnumerable<TSource, TSource2, TSource3>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3)
	{
		if (source is List<TSource> list && source2 is List<TSource2> list2 && source3 is List<TSource3> list3)
		{
			int count = MinEnumerable(new[] { list._size, list2._size, list3._size }.AsSpan());
			List<(TSource, TSource2, TSource3)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				TSource3 item3 = list3._items[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2 && source3 is TSource3[] array3)
		{
			int count = MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			List<(TSource, TSource2, TSource3)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				TSource3 item3 = array3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2 && source3 is G.IList<TSource3> list2_3)
		{
			int count = MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			List<(TSource, TSource2, TSource3)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				TSource3 item3 = list2_3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), ReturnOrConstruct(source3));
	}

	internal static List<TSource> ConcatEnumerable<TSource>(IEnumerable<TSource> source, params IEnumerable<TSource>[] collections)
	{
		List<TSource> result = new(source);
		for (int i = 0; i < collections.Length; i++)
			result.AddRange(collections[i]);
		return result;
	}

	internal static bool ContainsEnumerable<TSource>(IEnumerable<TSource> source, TSource target)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (item?.Equals(target) ?? false)
					return true;
			}
			return false;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (item?.Equals(target) ?? false)
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable<TSource>(IEnumerable<TSource> source, TSource target, IEqualityComparer<TSource> comparer)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable<TSource>(IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction)
	{
		var comparer = new EComparer<TSource>(equalFunction);
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static bool ContainsEnumerable<TSource>(IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction)
	{
		var comparer = new EComparer<TSource>(equalFunction, hashCodeFunction);
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return true;
			}
			return false;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, target))
					return true;
				i++;
			}
			return false;
		}
	}

	internal static List<TResult> ConvertEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list._items[i]);
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list2[i]);
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return ConvertEnumerable(new List<TSource>(source), function);
	}

	internal static List<TResult> ConvertEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result._items[i] = function(item, i);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return ConvertEnumerable(new List<TSource>(source), function);
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result.AddRange(function(list._items[i]));
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
				result.AddRange(function(array[i]));
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result.AddRange(function(list2[i]));
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result.AddRange(function(item));
				i++;
			}
			return result;
		}
		else
			return ConvertAndJoinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result.AddRange(function(item, i));
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result.AddRange(function(item, i));
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result.AddRange(function(item, i));
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result.AddRange(function(item, i));
				i++;
			}
			return result;
		}
		else
			return ConvertAndJoinEnumerable(new List<TSource>(source), function);
	}

	internal static int CountEnumerable<TSource>(IEnumerable<TSource> source)
	{
		if (TryGetCountEasilyEnumerable(source, out int count))
			return count;
		else
		{
			int n = 0;
			IEnumerator<TSource> en = source.GetEnumerator();
			while (en.MoveNext()) n++;
			return n;
		}
	}

	internal static int CountEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int n = 0;
			for (int i = 0; i < count; i++)
				if (function(list._items[i]))
					n++;
			return n;
		}
		else if (source is TSource[] array)
		{
			int n = 0;
			for (int i = 0; i < array.Length; i++)
				if (function(array[i]))
					n++;
			return n;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int n = 0;
			for (int i = 0; i < count; i++)
				if (function(list2[i]))
					n++;
			return n;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int n = 0;
			foreach (TSource item in source)
				if (function(item))
					n++;
			return n;
		}
		else
			return CountEnumerable(new List<TSource>(source), function);
	}

	internal static int CountEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int n = 0;
			for (int i = 0; i < count; i++)
				if (function(list._items[i], i))
					n++;
			return n;
		}
		else if (source is TSource[] array)
		{
			int n = 0;
			for (int i = 0; i < array.Length; i++)
				if (function(array[i], i))
					n++;
			return n;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int n = 0;
			for (int i = 0; i < count; i++)
				if (function(list2[i], i))
					n++;
			return n;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int n = 0;
			int i = 0;
			foreach (TSource item in source)
				if (function(item, i++))
					n++;
			return n;
		}
		else
			return CountEnumerable(new List<TSource>(source), function);
	}

	internal static int CountEnumerable<TSource>(IEnumerable<TSource> source, TSource target)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			int n = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is TSource[] array)
		{
			int n = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int n = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (item?.Equals(target) ?? false)
					n++;
			}
			return n;
		}
		else
		{
			int n = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (item?.Equals(target) ?? false)
					n++;
				i++;
			}
			return n;
		}
	}

	internal static bool EqualsEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (!function(item, item2))
					return false;
			}
			if (list._size != list2._size)
				return false;
			return true;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			int count = list2_.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (!function(item, item2))
					return false;
			}
			return true;
		}
		else
			return EqualsEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static bool EqualsEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			if (list._size != list2._size)
				return false;
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			int count = list2_.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (!function(item, item2, i))
					return false;
			}
			return true;
		}
		else
			return EqualsEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static bool EqualsEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2)
	{
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			if (list._size != list2._size)
				return false;
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (item == null || !item.Equals(item2))
					return false;
			}
			return true;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			if (array.Length != array2.Length)
				return false;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (item == null || !item.Equals(item2))
					return false;
			}
			return true;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			if (list2_.Count != list2_2.Count)
				return false;
			int count = list2_.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (item == null || !item.Equals(item2))
					return false;
			}
			return true;
		}
		else
			return EqualsEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2));
	}

	internal static List<TResult> FillEnumerable<TResult>(TResult elem, int count)
	{
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = elem;
		result._size = count;
		return result;
	}

	internal static List<TResult> FillEnumerable<TResult>(Func<int, TResult> function, int count)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(i);
		result._size = count;
		return result;
	}

	internal static TResult[] FillArrayEnumerable<TResult>(TResult elem, int count)
	{
		TResult[] result = new TResult[count];
		for (int i = 0; i < count; i++)
			result[i] = elem;
		return result;
	}

	internal static TResult[] FillArrayEnumerable<TResult>(Func<int, TResult> function, int count)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		TResult[] result = new TResult[count];
		for (int i = 0; i < count; i++)
			result[i] = function(i);
		return result;
	}

	internal static List<TSource> FilterEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FilterEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FilterEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item, i))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item, i))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item, i))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item, i))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FilterEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item))
					return item;
				i++;
			}
			return default;
		}
		else
			return FindEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item, i))
					return item;
				i++;
			}
			return default;
		}
		else
			return FindEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item, i))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item, i))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item, i))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item, i))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindAllMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindAllEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindAllEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindAllEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindAllEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindAllMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = item;
				}
				else if (f == indicator!)
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindAllMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
				if (function(list._items[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
				if (function(array[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
				if (function(list2[i]))
					result._items[j++] = i;
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item))
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item, i))
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item, i))
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static int FindIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
				if (function(list._items[i]))
					return i;
			return default;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
				if (function(array[i]))
					return i;
			return default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
				if (function(list2[i]))
					return i;
			return default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item))
					return i;
				i++;
			}
			return default;
		}
		else
			return FindIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (function(item, i))
					return i;
				i++;
			}
			return -1;
		}
		else
			return FindIndexEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (function(item))
					return item;
			}
			return default;
		}
		else
			return FindLastEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (function(item, i))
					return item;
			}
			return default;
		}
		else
			return FindLastEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
				if (function(list._items[i]))
					return i;
			return -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			for (int i = count - 1; i >= 0; i--)
				if (function(array[i]))
					return i;
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
				if (function(list2[i]))
					return i;
			return -1;
		}
		else
			return FindLastIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (function(item, i))
					return i;
			}
			return -1;
		}
		else
			return FindLastIndexEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindLastEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindLastEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else
			return FindLastMinEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindLastMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x) => function(x) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindLastIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindLastIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindLastIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else
			return FindLastMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return FindLastMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = item;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? FindMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource? result = default;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = item;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = item;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMaxIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x) => function(x) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x) => function(x) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x) => function(x) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(array, (x, index) => function(x, index) == value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(list2, (x, index) => function(x, index) == value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
		}
		else
			return FindMeanIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindIndexesEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexesEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindIndexesEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FindMinIndexesEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMaxIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMaxIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MeanEnumerable(list, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MeanEnumerable(array.AsSpan(), function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MeanEnumerable(list2, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MeanEnumerable(source, function);
			decimal? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			double? value2 = value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			int? value2 = (int?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			uint? value2 = (uint?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			long? value2 = (long?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x) => function(x) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x) => function(x) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x) => function(x) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMeanIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MeanEnumerable(list, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MeanEnumerable(array.AsSpan(), function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(array, (x, index) => function(x, index) == value2) : default;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MeanEnumerable(list2, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(list2, (x, index) => function(x, index) == value2) : default;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MeanEnumerable(source, function);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
		}
		else
			return FindMeanIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			decimal? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			double? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			uint? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			long? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x) => function(x) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x) => function(x) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x) => function(x) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x) => function(x) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMedianIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t? value = MedianEnumerable(list, function);
			return FindIndexEnumerable(list, (x, index) => function(x, index) == value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			mpz_t? value = MedianEnumerable(array.AsSpan(), function);
			return FindIndexEnumerable(array, (x, index) => function(x, index) == value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t? value = MedianEnumerable(list2, function);
			return FindIndexEnumerable(list2, (x, index) => function(x, index) == value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t? value = MedianEnumerable(source, function);
			return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
		}
		else
			return FindMedianIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static int FindMinIndexEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return FindMinIndexEnumerable(new List<TSource>(source), function);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function);
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(IEnumerable<TSource> source) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TSource Key, int Count)> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source));
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function, comparer);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function, comparer);
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TSource Key, int Count)> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), comparer);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function, equalFunction);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function, equalFunction);
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TSource Key, int Count)> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), equalFunction);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function, equalFunction, hashCodeFunction);
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TResult Key, int Count)> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TResult Key, int Count)> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), function, equalFunction, hashCodeFunction);
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<(TSource Key, int Count)> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<(TSource Key, int Count)> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value] = (f, result._items[value].Count + 1);
				else
				{
					dic.Add(f, j);
					result._items[j++] = (f, 1);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return FrequencyTableEnumerable(new List<TSource>(source), equalFunction, hashCodeFunction);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function);
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(IEnumerable<TSource> source) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TSource>> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source));
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function, comparer);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function, comparer);
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TSource>> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), comparer);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function, equalFunction);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function, equalFunction);
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TSource>> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), equalFunction);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function, equalFunction, hashCodeFunction);
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TResult>> result = new(array.Length);
			int j = 0;
			TResult f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TResult>> result = new(count);
			int j = 0;
			TResult f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = function(item, i), out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), function, equalFunction, hashCodeFunction);
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<Group<TSource, TSource>> result = new(array.Length);
			int j = 0;
			TSource f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<Group<TSource, TSource>> result = new(count);
			int j = 0;
			TSource f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(f = item, out int value))
					result._items[value].Add(item);
				else
				{
					dic.Add(f, j);
					result._items[j++] = new((List<TSource>)item, f);
				}
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return GroupEnumerable(new List<TSource>(source), equalFunction, hashCodeFunction);
	}

	internal static List<int> IndexesOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (item?.Equals(target) ?? false)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfEnumerable(new List<TSource>(source), target);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is decimal[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (decimal item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<decimal>(source));
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is double[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (double item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<double>(source));
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is int[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (int item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<int>(source));
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is uint[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (uint item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<uint>(source));
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is long[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (long item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<long>(source));
	}

	internal static List<int> IndexesOfMaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is mpz_t[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (mpz_t item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMaxEnumerable(new List<mpz_t>(source));
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else
			return IndexesOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			List<decimal> list_ = ReturnOrConstruct(list);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is decimal[] array)
		{
			List<decimal> list_ = ReturnOrConstruct(array);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<decimal> list2)
		{
			List<decimal> list_ = ReturnOrConstruct(list2);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
		{
			List<decimal> list_ = ReturnOrConstruct(source);
			decimal? value = MeanEnumerable(list_);
			decimal? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			List<double> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is double[] array)
		{
			List<double> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<double> list2)
		{
			List<double> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
		{
			List<double> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			double? value2 = value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			List<int> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is int[] array)
		{
			List<int> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<int> list2)
		{
			List<int> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
		{
			List<int> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			List<uint> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is uint[] array)
		{
			List<uint> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<uint> list2)
		{
			List<uint> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
		{
			List<uint> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			List<long> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is long[] array)
		{
			List<long> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else if (source is G.IList<long> list2)
		{
			List<long> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
		else
		{
			List<long> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
		}
	}

	internal static List<int> IndexesOfMeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is mpz_t[] array)
		{
			List<mpz_t> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else if (source is G.IList<mpz_t> list2)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
		else
		{
			List<mpz_t> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
		}
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else
			return IndexesOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			List<decimal> list_ = ReturnOrConstruct(list);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is decimal[] array)
		{
			List<decimal> list_ = ReturnOrConstruct(array);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<decimal> list2)
		{
			List<decimal> list_ = ReturnOrConstruct(list2);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
		{
			List<decimal> list_ = ReturnOrConstruct(source);
			decimal? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			List<double> list_ = ReturnOrConstruct(list);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is double[] array)
		{
			List<double> list_ = ReturnOrConstruct(array);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<double> list2)
		{
			List<double> list_ = ReturnOrConstruct(list2);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
		{
			List<double> list_ = ReturnOrConstruct(source);
			double? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			List<int> list_ = ReturnOrConstruct(list);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is int[] array)
		{
			List<int> list_ = ReturnOrConstruct(array);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<int> list2)
		{
			List<int> list_ = ReturnOrConstruct(list2);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
		{
			List<int> list_ = ReturnOrConstruct(source);
			int? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			List<uint> list_ = ReturnOrConstruct(list);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is uint[] array)
		{
			List<uint> list_ = ReturnOrConstruct(array);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<uint> list2)
		{
			List<uint> list_ = ReturnOrConstruct(list2);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
		{
			List<uint> list_ = ReturnOrConstruct(source);
			uint? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			List<long> list_ = ReturnOrConstruct(list);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is long[] array)
		{
			List<long> list_ = ReturnOrConstruct(array);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<long> list2)
		{
			List<long> list_ = ReturnOrConstruct(list2);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
		else
		{
			List<long> list_ = ReturnOrConstruct(source);
			long? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
		}
	}

	internal static List<int> IndexesOfMedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (source is mpz_t[] array)
		{
			List<mpz_t> list_ = ReturnOrConstruct(array);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else if (source is G.IList<mpz_t> list2)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list2);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
		else
		{
			List<mpz_t> list_ = ReturnOrConstruct(source);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? new() : IndexesOfEnumerable(list_, value);
		}
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result._items[j++] = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result._items[j++] = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is decimal[] array)
		{
			List<int> result = new(array.Length);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			decimal indicator = 0;
			int j = 0;
			decimal f;
			int i = 0;
			foreach (decimal item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<decimal>(source));
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is double[] array)
		{
			List<int> result = new(array.Length);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			double indicator = 0;
			int j = 0;
			double f;
			int i = 0;
			foreach (double item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<double>(source));
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is int[] array)
		{
			List<int> result = new(array.Length);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int indicator = 0;
			int j = 0;
			int f;
			int i = 0;
			foreach (int item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<int>(source));
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is uint[] array)
		{
			List<int> result = new(array.Length);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			uint indicator = 0;
			int j = 0;
			uint f;
			int i = 0;
			foreach (uint item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<uint>(source));
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is long[] array)
		{
			List<int> result = new(array.Length);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			long indicator = 0;
			int j = 0;
			long f;
			int i = 0;
			foreach (long item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<long>(source));
	}

	internal static List<int> IndexesOfMinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is mpz_t[] array)
		{
			List<int> result = new(array.Length);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			mpz_t indicator = 0;
			int j = 0;
			mpz_t f;
			int i = 0;
			foreach (mpz_t item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result._items[j++] = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result._items[j = 0] = i;
				}
				else if (f == indicator!)
					result._items[j++] = i;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return IndexesOfMinEnumerable(new List<mpz_t>(source));
	}

	internal static int IndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (item?.Equals(target) ?? false)
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target, IEqualityComparer<TSource> comparer)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction)
	{
		var comparer = new EComparer<TSource>(equalFunction);
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction)
	{
		var comparer = new EComparer<TSource>(equalFunction, hashCodeFunction);
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, target))
					return i;
				i++;
			}
			return -1;
		}
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (decimal item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (double item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (int item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (uint item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (long item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (mpz_t item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else
			return IndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			List<decimal> list_ = ReturnOrConstruct(list);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is decimal[] array)
		{
			List<decimal> list_ = ReturnOrConstruct(array);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<decimal> list2)
		{
			List<decimal> list_ = ReturnOrConstruct(list2);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<decimal> list_ = ReturnOrConstruct(source);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			List<double> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is double[] array)
		{
			List<double> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<double> list2)
		{
			List<double> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<double> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			List<int> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is int[] array)
		{
			List<int> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<int> list2)
		{
			List<int> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
		{
			List<int> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			List<uint> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is uint[] array)
		{
			List<uint> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<uint> list2)
		{
			List<uint> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
		{
			List<uint> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			List<long> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is long[] array)
		{
			List<long> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<long> list2)
		{
			List<long> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
		{
			List<long> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : -1;
		}
	}

	internal static int IndexOfMeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is mpz_t[] array)
		{
			List<mpz_t> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
		else
		{
			List<mpz_t> list_ = ReturnOrConstruct(source);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : -1;
		}
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<decimal> list_ = ConvertEnumerable(source, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<double> list_ = ConvertEnumerable(source, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> list_ = ConvertEnumerable(source, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<uint> list_ = ConvertEnumerable(source, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<long> list_ = ConvertEnumerable(source, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<mpz_t> list_ = ConvertEnumerable(source, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else
			return IndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			List<decimal> list_ = ReturnOrConstruct(list);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is decimal[] array)
		{
			List<decimal> list_ = ReturnOrConstruct(array);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<decimal> list2)
		{
			List<decimal> list_ = ReturnOrConstruct(list2);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<decimal> list_ = ReturnOrConstruct(source);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			List<double> list_ = ReturnOrConstruct(list);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is double[] array)
		{
			List<double> list_ = ReturnOrConstruct(array);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<double> list2)
		{
			List<double> list_ = ReturnOrConstruct(list2);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<double> list_ = ReturnOrConstruct(source);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			List<int> list_ = ReturnOrConstruct(list);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is int[] array)
		{
			List<int> list_ = ReturnOrConstruct(array);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<int> list2)
		{
			List<int> list_ = ReturnOrConstruct(list2);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<int> list_ = ReturnOrConstruct(source);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			List<uint> list_ = ReturnOrConstruct(list);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is uint[] array)
		{
			List<uint> list_ = ReturnOrConstruct(array);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<uint> list2)
		{
			List<uint> list_ = ReturnOrConstruct(list2);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<uint> list_ = ReturnOrConstruct(source);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			List<long> list_ = ReturnOrConstruct(list);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is long[] array)
		{
			List<long> list_ = ReturnOrConstruct(array);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<long> list2)
		{
			List<long> list_ = ReturnOrConstruct(list2);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
		else
		{
			List<long> list_ = ReturnOrConstruct(source);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
		}
	}

	internal static int IndexOfMedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (source is mpz_t[] array)
		{
			List<mpz_t> list_ = ReturnOrConstruct(array);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<mpz_t> list2)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list2);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
		else
		{
			List<mpz_t> list_ = ReturnOrConstruct(source);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : IndexOfEnumerable(list_, value);
		}
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
		else
			return IndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int IndexOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (decimal item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			double indicator = 0;
			double f;
			int i = 0;
			foreach (double item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			int indicator = 0;
			int f;
			int i = 0;
			foreach (int item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (uint item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			long indicator = 0;
			long f;
			int i = 0;
			foreach (long item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static int IndexOfMinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
		{
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (mpz_t item in source)
			{
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
				i++;
			}
			return result;
		}
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(IEnumerable<List<TSource>> source)
	{
		if (source is List<List<TSource>> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				List<TSource> item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is List<TSource>[] array)
		{
			List<TSource> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				List<TSource> item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<List<TSource>> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				List<TSource> item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int i = 0;
			foreach (List<TSource> item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
		else
			return JoinIntoSingleEnumerable(new List<List<TSource>>(source));
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(IEnumerable<TSource> source) where TSource : IEnumerable<TResult>
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result.AddRange(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
				result.AddRange(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result.AddRange(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
		else
			return JoinIntoSingleEnumerable<TSource, TResult>(new List<TSource>(source));
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(IEnumerable<TSource[]> source)
	{
		if (source is List<TSource[]> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource[] item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is TSource[][] array)
		{
			List<TSource> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				TSource[] item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<TSource[]> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource[] item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int i = 0;
			foreach (TSource[] item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
		else
			return JoinIntoSingleEnumerable(new List<TSource[]>(source));
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(IEnumerable<G.IList<TSource>> source)
	{
		if (source is List<G.IList<TSource>> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				G.IList<TSource> item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<TSource>[] array)
		{
			List<TSource> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				G.IList<TSource> item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<G.IList<TSource>> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				G.IList<TSource> item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int i = 0;
			foreach (G.IList<TSource> item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
		else
			return JoinIntoSingleEnumerable(new List<G.IList<TSource>>(source));
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(IEnumerable<IEnumerable<TSource>> source)
	{
		if (source is List<IEnumerable<TSource>> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				IEnumerable<TSource> item = list._items[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is IEnumerable<TSource>[] array)
		{
			List<TSource> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				IEnumerable<TSource> item = array[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (source is G.IList<IEnumerable<TSource>> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				IEnumerable<TSource> item = list2[i];
				result.AddRange(item);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int i = 0;
			foreach (IEnumerable<TSource> item in source)
			{
				result.AddRange(item);
				i++;
			}
			return result;
		}
		else
			return JoinIntoSingleEnumerable(new List<IEnumerable<TSource>>(source));
	}

	internal static int LastIndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (item?.Equals(target) ?? false)
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<TSource>(source), target);
	}

	internal static int LastIndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target, IEqualityComparer<TSource> comparer)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = array.Length - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<TSource>(source), target, comparer);
	}

	internal static int LastIndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction)
	{
		var comparer = new EComparer<TSource>(equalFunction);
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = array.Length - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<TSource>(source), target, equalFunction);
	}

	internal static int LastIndexOfEnumerable<TSource>(IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction)
	{
		var comparer = new EComparer<TSource>(equalFunction, hashCodeFunction);
		if (source is List<TSource> list)
		{
			int count = list._size;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is TSource[] array)
		{
			for (int i = array.Length - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (comparer.Equals(item, target))
					return i;
			}
			return -1;
		}
		else
			return LastIndexOfEnumerable(new List<TSource>(source), target, equalFunction, hashCodeFunction);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				decimal item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				decimal item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				decimal item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				double item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				double item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				double item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				int item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				int item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				int item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				uint item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				uint item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				uint item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				long item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				long item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				long item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				mpz_t item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				mpz_t item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				mpz_t item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) > indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMaxEnumerable(new List<mpz_t>(source));
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			List<decimal> list_ = ReturnOrConstruct(list);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is decimal[] array)
		{
			List<decimal> list_ = ReturnOrConstruct(array);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<decimal> list2)
		{
			List<decimal> list_ = ReturnOrConstruct(list2);
			decimal? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			List<double> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is double[] array)
		{
			List<double> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<double> list2)
		{
			List<double> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMeanEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			List<int> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is int[] array)
		{
			List<int> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<int> list2)
		{
			List<int> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			int? value2 = (int?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			List<uint> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is uint[] array)
		{
			List<uint> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<uint> list2)
		{
			List<uint> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			uint? value2 = (uint?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			List<long> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is long[] array)
		{
			List<long> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else if (source is G.IList<long> list2)
		{
			List<long> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			long? value2 = (long?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is mpz_t[] array)
		{
			List<mpz_t> list_ = ReturnOrConstruct(array);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list2);
			double? value = MeanEnumerable(list_);
			mpz_t? value2 = (mpz_t?)value;
			return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : -1;
		}
		else
			return LastIndexOfMeanEnumerable(new List<mpz_t>(source));
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<decimal> list_ = ConvertEnumerable(list, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<decimal> list_ = ConvertEnumerable(array.AsSpan(), function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<decimal> list_ = ConvertEnumerable(list2, function);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<double> list_ = ConvertEnumerable(list, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<double> list_ = ConvertEnumerable(array.AsSpan(), function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<double> list_ = ConvertEnumerable(list2, function);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> list_ = ConvertEnumerable(list, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<int> list_ = ConvertEnumerable(array.AsSpan(), function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> list_ = ConvertEnumerable(list2, function);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<uint> list_ = ConvertEnumerable(list, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<uint> list_ = ConvertEnumerable(array.AsSpan(), function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<uint> list_ = ConvertEnumerable(list2, function);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<long> list_ = ConvertEnumerable(list, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<long> list_ = ConvertEnumerable(array.AsSpan(), function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<long> list_ = ConvertEnumerable(list2, function);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<mpz_t> list_ = ConvertEnumerable(list, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			List<mpz_t> list_ = ConvertEnumerable(array.AsSpan(), function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<mpz_t> list_ = ConvertEnumerable(list2, function);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			List<decimal> list_ = ReturnOrConstruct(list);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is decimal[] array)
		{
			List<decimal> list_ = ReturnOrConstruct(array);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<decimal> list2)
		{
			List<decimal> list_ = ReturnOrConstruct(list2);
			decimal? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			List<double> list_ = ReturnOrConstruct(list);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is double[] array)
		{
			List<double> list_ = ReturnOrConstruct(array);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<double> list2)
		{
			List<double> list_ = ReturnOrConstruct(list2);
			double? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			List<int> list_ = ReturnOrConstruct(list);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is int[] array)
		{
			List<int> list_ = ReturnOrConstruct(array);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<int> list2)
		{
			List<int> list_ = ReturnOrConstruct(list2);
			int? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			List<uint> list_ = ReturnOrConstruct(list);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is uint[] array)
		{
			List<uint> list_ = ReturnOrConstruct(array);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<uint> list2)
		{
			List<uint> list_ = ReturnOrConstruct(list2);
			uint? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			List<long> list_ = ReturnOrConstruct(list);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is long[] array)
		{
			List<long> list_ = ReturnOrConstruct(array);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else if (source is G.IList<long> list2)
		{
			List<long> list_ = ReturnOrConstruct(list2);
			long? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else if (source is mpz_t[] array)
		{
			List<mpz_t> list_ = ReturnOrConstruct(array);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else if (source is G.IList<mpz_t> list2)
		{
			List<mpz_t> list_ = ReturnOrConstruct(list2);
			mpz_t? value = MedianEnumerable(list_);
			return value == null ? -1 : LastIndexOfEnumerable(list_, value);
		}
		else
			return LastIndexOfMedianEnumerable(new List<mpz_t>(source));
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item);
					result = i;
				}
				else if ((f = function(item)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list._items[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = array[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				TSource item = list2[i];
				if (i == 0)
				{
					indicator = function(item, i);
					result = i;
				}
				else if ((f = function(item, i)) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<TSource>(source), function);
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				decimal item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			int count = array.Length;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				decimal item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			int result = -1;
			decimal indicator = 0;
			decimal f;
			for (int i = count - 1; i >= 0; i--)
			{
				decimal item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<decimal>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				double item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is double[] array)
		{
			int count = array.Length;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				double item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			int result = -1;
			double indicator = 0;
			double f;
			for (int i = count - 1; i >= 0; i--)
			{
				double item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<double>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				int item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is int[] array)
		{
			int count = array.Length;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				int item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int result = -1;
			int indicator = 0;
			int f;
			for (int i = count - 1; i >= 0; i--)
			{
				int item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<int>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				uint item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is uint[] array)
		{
			int count = array.Length;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				uint item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			int result = -1;
			uint indicator = 0;
			uint f;
			for (int i = count - 1; i >= 0; i--)
			{
				uint item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<uint>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				long item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is long[] array)
		{
			int count = array.Length;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				long item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			int result = -1;
			long indicator = 0;
			long f;
			for (int i = count - 1; i >= 0; i--)
			{
				long item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<long>(source));
	}

	internal static int LastIndexOfMinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				mpz_t item = list._items[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			int count = array.Length;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				mpz_t item = array[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			int result = -1;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = count - 1; i >= 0; i--)
			{
				mpz_t item = list2[i];
				if (i == 0)
				{
					indicator = item;
					result = i;
				}
				else if ((f = item) < indicator!)
				{
					indicator = f;
					result = i;
				}
			}
			return result;
		}
		else
			return LastIndexOfMinEnumerable(new List<mpz_t>(source));
	}

	internal static decimal MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static double MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static double MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static int MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static int MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static uint MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static uint MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static long MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static long MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t MaxEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MaxEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MaxEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is decimal[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (decimal item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MaxEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is double[] array)
		{
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			int i = 0;
			foreach (double item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MaxEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is int[] array)
		{
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			int indicator = 0;
			int f;
			int i = 0;
			foreach (int item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MaxEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is uint[] array)
		{
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (uint item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MaxEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is long[] array)
		{
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			int i = 0;
			foreach (long item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MaxEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is mpz_t[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (mpz_t item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) > indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static decimal MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			decimal result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			decimal result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += (double)function(list._items[i]);
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
				result += (double)function(array[i]);
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += (double)function(list2[i]);
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += (double)function(item);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += (double)function(item, i);
			}
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += (double)function(item, i);
			}
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += (double)function(item, i);
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += (double)function(item, i);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += (double)function(list._items[i]);
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
				result += (double)function(array[i]);
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += (double)function(list2[i]);
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += (double)function(item);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static double MeanEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += (double)function(item, i);
			}
			return result / list._size;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += (double)function(item, i);
			}
			return result / array.Length;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += (double)function(item, i);
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += (double)function(item, i);
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MeanEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				result += item;
			}
			return result / list._size;
		}
		else if (source is decimal[] array)
		{
			decimal result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				result += item;
			}
			return result / array.Length;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				result += item;
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal result = 0;
			int i = 0;
			foreach (decimal item in source)
			{
				result += item;
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<decimal>(source));
	}

	internal static double MeanEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				result += (double)item;
			}
			return result / list._size;
		}
		else if (source is double[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				result += (double)item;
			}
			return result / array.Length;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				result += (double)item;
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (double item in source)
			{
				result += (double)item;
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<double>(source));
	}

	internal static double MeanEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				result += item;
			}
			return result / list._size;
		}
		else if (source is int[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				result += item;
			}
			return result / array.Length;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				result += item;
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (int item in source)
			{
				result += item;
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<int>(source));
	}

	internal static double MeanEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				result += item;
			}
			return result / list._size;
		}
		else if (source is uint[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				result += item;
			}
			return result / array.Length;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				result += item;
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (uint item in source)
			{
				result += item;
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<uint>(source));
	}

	internal static double MeanEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				result += item;
			}
			return result / list._size;
		}
		else if (source is long[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				result += item;
			}
			return result / array.Length;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				result += item;
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (long item in source)
			{
				result += item;
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<long>(source));
	}

	internal static double MeanEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				result += (double)item;
			}
			return result / list._size;
		}
		else if (source is mpz_t[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				result += (double)item;
			}
			return result / array.Length;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				result += (double)item;
			}
			return result / list2.Count;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (mpz_t item in source)
			{
				result += (double)item;
				i++;
			}
			return result / count;
		}
		else
			return MeanEnumerable(new List<mpz_t>(source));
	}

	internal static decimal MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static double MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static double MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static int MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static int MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static uint MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static uint MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static long MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static long MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t MedianEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? 0 : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? 0 : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? 0 : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MedianEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
			return list._size == 0 ? 0 : new List<decimal>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is decimal[] array)
			return array.Length == 0 ? 0 : new List<decimal>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<decimal> list2)
			return list2.Count == 0 ? 0 : new List<decimal>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : new List<decimal>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<decimal>(source));
	}

	internal static double MedianEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
			return list._size == 0 ? 0 : new List<double>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is double[] array)
			return array.Length == 0 ? 0 : new List<double>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<double> list2)
			return list2.Count == 0 ? 0 : new List<double>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : new List<double>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<double>(source));
	}

	internal static int MedianEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
			return list._size == 0 ? 0 : new List<int>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is int[] array)
			return array.Length == 0 ? 0 : new List<int>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<int> list2)
			return list2.Count == 0 ? 0 : new List<int>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : new List<int>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<int>(source));
	}

	internal static uint MedianEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
			return list._size == 0 ? 0 : new List<uint>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is uint[] array)
			return array.Length == 0 ? 0 : new List<uint>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<uint> list2)
			return list2.Count == 0 ? 0 : new List<uint>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : new List<uint>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<uint>(source));
	}

	internal static long MedianEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
			return list._size == 0 ? 0 : new List<long>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is long[] array)
			return array.Length == 0 ? 0 : new List<long>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<long> list2)
			return list2.Count == 0 ? 0 : new List<long>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : new List<long>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<long>(source));
	}

	internal static mpz_t MedianEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
			return list._size == 0 ? 0 : new List<mpz_t>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is mpz_t[] array)
			return array.Length == 0 ? 0 : new List<mpz_t>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<mpz_t> list2)
			return list2.Count == 0 ? 0 : new List<mpz_t>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? 0 : new List<mpz_t>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<mpz_t>(source));
	}

	internal static TResult? MedianEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? default : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? default : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? default : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? default : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static TResult? MedianEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			return list._size == 0 ? default : ConvertEnumerable(list, function).Sort()._items[(list._size - 1) / 2];
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			return array.Length == 0 ? default : ConvertEnumerable(array.AsSpan(), function).Sort()._items[(array.Length - 1) / 2];
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			return list2.Count == 0 ? default : ConvertEnumerable(list2, function).Sort()._items[(list2.Count - 1) / 2];
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? default : ConvertEnumerable(source, function).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source), function);
	}

	internal static TSource? MedianEnumerable<TSource>(IEnumerable<TSource> source)
	{
		if (source is List<TSource> list)
			return list._size == 0 ? default : new List<TSource>(list).Sort()._items[(list._size - 1) / 2];
		else if (source is TSource[] array)
			return array.Length == 0 ? default : new List<TSource>(array).Sort()._items[(array.Length - 1) / 2];
		else if (source is G.IList<TSource> list2)
			return list2.Count == 0 ? default : new List<TSource>(list2).Sort()._items[(list2.Count - 1) / 2];
		else if (TryGetCountEasilyEnumerable(source, out int count))
			return count == 0 ? default : new List<TSource>(source).Sort()._items[(count - 1) / 2];
		else
			return MedianEnumerable(new List<TSource>(source));
	}

	internal static decimal MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static double MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static double MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double indicator = 0;
			double f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static int MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static int MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int indicator = 0;
			int f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static uint MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static uint MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static long MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static long MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long indicator = 0;
			long f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item);
				else if ((f = function(item)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t MinEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is TSource[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (TSource item in source)
			{
				if (i == 0)
					indicator = function(item, i);
				else if ((f = function(item, i)) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
		else
			return MinEnumerable(new List<TSource>(source), function);
	}

	internal static decimal MinEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is decimal[] array)
		{
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			decimal indicator = 0;
			decimal f;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			decimal indicator = 0;
			decimal f;
			int i = 0;
			foreach (decimal item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static double MinEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is double[] array)
		{
			double indicator = 0;
			double f;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			double indicator = 0;
			double f;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			double indicator = 0;
			double f;
			int i = 0;
			foreach (double item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static int MinEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is int[] array)
		{
			int indicator = 0;
			int f;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int indicator = 0;
			int f;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			int indicator = 0;
			int f;
			int i = 0;
			foreach (int item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static uint MinEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is uint[] array)
		{
			uint indicator = 0;
			uint f;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			uint indicator = 0;
			uint f;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			uint indicator = 0;
			uint f;
			int i = 0;
			foreach (uint item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static long MinEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is long[] array)
		{
			long indicator = 0;
			long f;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			long indicator = 0;
			long f;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			long indicator = 0;
			long f;
			int i = 0;
			foreach (long item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static mpz_t MinEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is mpz_t[] array)
		{
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			mpz_t indicator = 0;
			mpz_t f;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
			}
			return indicator;
		}
		else
		{
			mpz_t indicator = 0;
			mpz_t f;
			int i = 0;
			foreach (mpz_t item in source)
			{
				if (i == 0)
					indicator = item;
				else if ((f = item) < indicator!)
					indicator = f;
				i++;
			}
			return indicator;
		}
	}

	internal static List<TResult> OfTypeEnumerable<TResult>(IEnumerable source)
	{
		List<TResult> result = new();
		foreach (object item in source)
			if (item is TResult resultElement)
				result.Add(resultElement);
		return result;
	}

	internal static TSource? ProgressionEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, TSource> function)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			TSource? result = default;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (result == null || i == 0)
					result = item;
				else
					result = function(result, item);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TSource? result = default;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (result == null || i == 0)
					result = item;
				else
					result = function(result, item);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource? result = default;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (result == null || i == 0)
					result = item;
				else
					result = function(result, item);
			}
			return result;
		}
		else
		{
			TSource? result = default;
			int i = 0;
			foreach (TSource item in source)
			{
				if (result == null || i == 0)
					result = item;
				else
					result = function(result, item);
				i++;
			}
			return result;
		}
	}

	internal static TResult? ProgressionEnumerable<TSource, TResult>(IEnumerable<TSource> source, TResult seed, Func<TResult, TSource, TResult> function)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			TResult? result = seed;
			for (int i = 0; i < count; i++)
				result = function(result, list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			TResult? result = seed;
			for (int i = 0; i < array.Length; i++)
				result = function(result, array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TResult? result = seed;
			for (int i = 0; i < count; i++)
				result = function(result, list2[i]);
			return result;
		}
		else
		{
			TResult? result = seed;
			int i = 0;
			foreach (TSource item in source)
			{
				result = function(result, item);
				i++;
			}
			return result;
		}
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(IEnumerable<TSource> source)
	{
		HashSet<TSource> hs = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(item))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source));
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function, comparer);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function, comparer);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
	{
		HashSet<TSource> hs = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(item))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), comparer);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function, equalFunction);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function, equalFunction);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction)
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(item))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), equalFunction);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function, equalFunction, hashCodeFunction);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(function(item, i)))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), function, equalFunction, hashCodeFunction);
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction)
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (hs.TryAdd(item))
					result._items[j++] = item;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (hs.TryAdd(item))
					result._items[j++] = item;
				i++;
			}
			result._size = j;
			result.TrimExcess();
			return result;
		}
		else
			return RemoveDoublesEnumerable(new List<TSource>(source), equalFunction, hashCodeFunction);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new();
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new();
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2)
	{
		HashSet<TSource> hs = new();
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2));
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(comparer);
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, comparer);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(comparer);
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, comparer);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEqualityComparer<TSource> comparer)
	{
		HashSet<TSource> hs = new(comparer);
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), comparer);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource, bool> equalFunction)
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), equalFunction);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction, hashCodeFunction);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(function(item, i)))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), function, equalFunction, hashCodeFunction);
	}

	internal static (List<TSource>, List<TSource2>) RemoveDoublesEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction)
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list._size, list2._size);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				TSource2 item2 = list2._items[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			List<TSource> result = new(count);
			List<TSource2> result2 = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				if (hs.TryAdd(item))
				{
					result._items[j] = item;
					result2._items[j++] = item2;
				}
			}
			result._size = j;
			result2._size = j;
			result.TrimExcess();
			result2.TrimExcess();
			return (result, result2);
		}
		else
			return RemoveDoublesEnumerable(ReturnOrConstruct(source), ReturnOrConstruct(source2), equalFunction, hashCodeFunction);
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(IEnumerable<TSource> source) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new();
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return RepresentIntoNumbersEnumerable(new List<TSource>(source));
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(comparer);
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return RepresentIntoNumbersEnumerable(new List<TSource>(source), comparer);
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return RepresentIntoNumbersEnumerable(new List<TSource>(source), equalFunction);
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<int> result = new(array.Length);
			int j = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<int> result = new(count);
			int j = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<int> result = new(count);
			int j = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				if (dic.TryGetValue(item, out int value))
					result._items[i] = value;
				else
					dic.Add(item, result._items[i] = j++);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return RepresentIntoNumbersEnumerable(new List<TSource>(source), equalFunction, hashCodeFunction);
	}

	internal static List<TSource> ReverseEnumerable<TSource>(IEnumerable<TSource> source)
	{
		if (source is List<TSource> list)
		{
			int count = list._size;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result._items[^(i + 1)] = item;
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			List<TSource> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[^(i + 1)] = item;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			List<TSource> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[^(i + 1)] = item;
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TSource> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[^(i + 1)] = item;
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return ReverseEnumerable(new List<TSource>(source));
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source)
	{
		List<TResult> result = new();
		foreach (object item in source)
			result.Add((TResult)item);
		return result;
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source, Func<object?, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is ArrayList list)
		{
			int count = list.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list[i]);
			result._size = count;
			return result;
		}
		else if (source is BitArray bitArray)
		{
			List<TResult> result = new(bitArray.Length);
			for (int i = 0; i < bitArray.Length; i++)
				result._items[i] = function(bitArray[i]);
			result._size = bitArray.Length;
			return result;
		}
		else if (source is System.Collections.IList list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list2[i]);
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (object item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = count;
			return result;
		}
		else
		{
			List<TResult> result = new();
			int i = 0;
			foreach (object item in source)
			{
				result.Add(function(item));
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TResult> SetInnerTypeEnumerable<TResult>(IEnumerable source, Func<object?, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is ArrayList list)
		{
			int count = list.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list[i], i);
			result._size = count;
			return result;
		}
		else if (source is BitArray bitArray)
		{
			List<TResult> result = new(bitArray.Length);
			for (int i = 0; i < bitArray.Length; i++)
				result._items[i] = function(bitArray[i], i);
			result._size = bitArray.Length;
			return result;
		}
		else if (source is System.Collections.IList list2)
		{
			int count = list2.Count;
			List<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list2[i], i);
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			List<TResult> result = new(count);
			int i = 0;
			foreach (object item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = count;
			return result;
		}
		else
		{
			List<TResult> result = new();
			int i = 0;
			foreach (object item in source)
			{
				result.Add(function(item, i));
				i++;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TSource> SkipWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (source is List<TSource> list)
			return list.SkipWhile(function);
		else
		{
			List<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			for (; en.MoveNext() && function(en.Current); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result;
		}
	}

	internal static List<TSource> SkipWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (source is List<TSource> list)
			return list.SkipWhile(function);
		else
		{
			List<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			for (; en.MoveNext() && function(en.Current, i); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result;
		}
	}

	internal static List<List<TSource>> SplitIntoEqualEnumerable<TSource>(IEnumerable<TSource> source, int fragmentLength)
	{
		if (fragmentLength <= 0)
			throw new ArgumentException(null, nameof(fragmentLength));
		if (source is List<TSource> list)
		{
			int count = GetArrayLength(list._size, fragmentLength);
			List<List<TSource>> result = new(count);
			int count2 = list._size / fragmentLength;
			int index = 0;
			for (int i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (int j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list._items[index++];
				result._items[i]._size = fragmentLength;
			}
			int rest = list._size % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (int j = 0; j < rest; j++)
					result._items[count2]._items[j] = list._items[index++];
				result._items[count2]._size = rest;
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			int count = GetArrayLength(array.Length, fragmentLength);
			List<List<TSource>> result = new(count);
			int count2 = array.Length / fragmentLength;
			int index = 0;
			for (int i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (int j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = array[index++];
				result._items[i]._size = fragmentLength;
			}
			int rest = array.Length % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (int j = 0; j < rest; j++)
					result._items[count2]._items[j] = array[index++];
				result._items[count2]._size = rest;
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = GetArrayLength(list2.Count, fragmentLength);
			List<List<TSource>> result = new(count);
			int count2 = list2.Count / fragmentLength;
			int index = 0;
			for (int i = 0; i < count2; i++)
			{
				result._items[i] = new(fragmentLength);
				for (int j = 0; j < fragmentLength; j++)
					result._items[i]._items[j] = list2[index++];
				result._items[i]._size = fragmentLength;
			}
			int rest = list2.Count % fragmentLength;
			if (rest != 0)
			{
				result._items[count2] = new(rest);
				for (int j = 0; j < rest; j++)
					result._items[count2]._items[j] = list2[index++];
				result._items[count2]._size = rest;
			}
			result._size = count;
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int count2 = GetArrayLength(count, fragmentLength);
			List<List<TSource>> result = new(count2);
			int i = 0, j = 0, k = 0;
			if (count2 != 0)
				result._items[0] = new(fragmentLength);
			foreach (TSource item in source)
			{
				result._items[j]._items[k++] = item;
				if (k >= fragmentLength)
				{
					result._items[j++]._size = fragmentLength;
					result._items[j] = new(fragmentLength);
					k = 0;
				}
				i++;
			}
			if (k != 0)
				result._items[j]._size = k;
			result._size = count2;
			return result;
		}
		else
			return SplitIntoEqualEnumerable(new List<TSource>(source), fragmentLength);
	}

	internal static decimal SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			decimal result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static decimal SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			decimal result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			decimal result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static double SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static double SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			double result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static int SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static int SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			int result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			int result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			int result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			int result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static uint SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			uint result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static uint SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			uint result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			uint result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			uint result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			uint result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static long SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			long result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static long SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			long result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			long result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			long result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			long result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t result = 0;
			for (int i = 0; i < count; i++)
				result += function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			mpz_t result = 0;
			for (int i = 0; i < array.Length; i++)
				result += function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t result = 0;
			for (int i = 0; i < count; i++)
				result += function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static mpz_t SumEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			mpz_t result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			mpz_t result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result += function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			mpz_t result = 0;
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result += function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			mpz_t result = 0;
			int i = 0;
			foreach (TSource item in source)
			{
				result += function(item, i);
				i++;
			}
			return result;
		}
		else
			return SumEnumerable(new List<TSource>(source), function);
	}

	internal static decimal SumEnumerable(IEnumerable<decimal> source)
	{
		if (source is List<decimal> list)
		{
			int count = list._size;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				decimal item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is decimal[] array)
		{
			decimal result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				decimal item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<decimal> list2)
		{
			int count = list2.Count;
			decimal result = 0;
			for (int i = 0; i < count; i++)
			{
				decimal item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			decimal result = 0;
			int i = 0;
			foreach (decimal item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static double SumEnumerable(IEnumerable<double> source)
	{
		if (source is List<double> list)
		{
			int count = list._size;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				double item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is double[] array)
		{
			double result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				double item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<double> list2)
		{
			int count = list2.Count;
			double result = 0;
			for (int i = 0; i < count; i++)
			{
				double item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			double result = 0;
			int i = 0;
			foreach (double item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static int SumEnumerable(IEnumerable<int> source)
	{
		if (source is List<int> list)
		{
			int count = list._size;
			int result = 0;
			for (int i = 0; i < count; i++)
			{
				int item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is int[] array)
		{
			int result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				int item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<int> list2)
		{
			int count = list2.Count;
			int result = 0;
			for (int i = 0; i < count; i++)
			{
				int item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			int result = 0;
			int i = 0;
			foreach (int item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static uint SumEnumerable(IEnumerable<uint> source)
	{
		if (source is List<uint> list)
		{
			int count = list._size;
			uint result = 0;
			for (int i = 0; i < count; i++)
			{
				uint item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is uint[] array)
		{
			uint result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				uint item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<uint> list2)
		{
			int count = list2.Count;
			uint result = 0;
			for (int i = 0; i < count; i++)
			{
				uint item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			uint result = 0;
			int i = 0;
			foreach (uint item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static long SumEnumerable(IEnumerable<long> source)
	{
		if (source is List<long> list)
		{
			int count = list._size;
			long result = 0;
			for (int i = 0; i < count; i++)
			{
				long item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is long[] array)
		{
			long result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				long item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<long> list2)
		{
			int count = list2.Count;
			long result = 0;
			for (int i = 0; i < count; i++)
			{
				long item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			long result = 0;
			int i = 0;
			foreach (long item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static mpz_t SumEnumerable(IEnumerable<mpz_t> source)
	{
		if (source is List<mpz_t> list)
		{
			int count = list._size;
			mpz_t result = 0;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list._items[i];
				result += item;
			}
			return result;
		}
		else if (source is mpz_t[] array)
		{
			mpz_t result = 0;
			for (int i = 0; i < array.Length; i++)
			{
				mpz_t item = array[i];
				result += item;
			}
			return result;
		}
		else if (source is G.IList<mpz_t> list2)
		{
			int count = list2.Count;
			mpz_t result = 0;
			for (int i = 0; i < count; i++)
			{
				mpz_t item = list2[i];
				result += item;
			}
			return result;
		}
		else
		{
			mpz_t result = 0;
			int i = 0;
			foreach (mpz_t item in source)
			{
				result += item;
				i++;
			}
			return result;
		}
	}

	internal static List<TSource> TakeEnumerable<TSource>(IEnumerable<TSource> source, int count)
	{
		if (count == 0)
			return new();
		else if (source is List<TSource> list)
			return list.Take(count);
		else
		{
			List<TSource> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i++] = item;
				if (i >= count)
					break;
			}
			result._size = i;
			return result;
		}
	}

	internal static List<TSource> TakeWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function)
	{
		if (source is List<TSource> list)
			return list.TakeWhile(function);
		else
		{
			List<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			TSource item;
			for (; en.MoveNext() && function(item = en.Current); i++) result.Add(item);
			return result;
		}
	}

	internal static List<TSource> TakeWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function)
	{
		if (source is List<TSource> list)
			return list.TakeWhile(function);
		else
		{
			List<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			TSource item;
			for (; en.MoveNext() && function(item = en.Current, i); i++) result.Add(item);
			return result;
		}
	}

	internal static TResult[] ToArrayEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TResult[] result = new TResult[count];
			for (int i = 0; i < count; i++)
				result[i] = function(list._items[i]);
			return result;
		}
		else if (source is TSource[] array)
		{
			TResult[] result = new TResult[array.Length];
			for (int i = 0; i < array.Length; i++)
				result[i] = function(array[i]);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TResult[] result = new TResult[count];
			for (int i = 0; i < count; i++)
				result[i] = function(list2[i]);
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TResult[] result = new TResult[count];
			int i = 0;
			foreach (TSource item in source)
			{
				result[i] = function(item);
				i++;
			}
			return result;
		}
		else
			return ToArrayEnumerable(new List<TSource>(source), function);
	}

	internal static TResult[] ToArrayEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list._size;
			TResult[] result = new TResult[count];
			for (int i = 0; i < count; i++)
			{
				TSource item = list._items[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is TSource[] array)
		{
			TResult[] result = new TResult[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TResult[] result = new TResult[count];
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result[i] = function(item, i);
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TResult[] result = new TResult[count];
			int i = 0;
			foreach (TSource item in source)
			{
				result[i] = function(item, i);
				i++;
			}
			return result;
		}
		else
			return ToArrayEnumerable(new List<TSource>(source), function);
	}

	internal static TSource[] ToArrayEnumerable<TSource>(IEnumerable<TSource> source)
	{
		if (source is List<TSource> list)
		{
			return list.ToArray();
		}
		else if (source is TSource[] array)
		{
			TSource[] result = new TSource[array.Length];
			Array.Copy(array, result, array.Length);
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			TSource[] result = new TSource[count];
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result[i] = item;
			}
			return result;
		}
		else if (TryGetCountEasilyEnumerable(source, out int count))
		{
			TSource[] result = new TSource[count];
			int i = 0;
			foreach (TSource item in source)
			{
				result[i] = item;
				i++;
			}
			return result;
		}
		else
			return new List<TSource>(source).ToArray();
	}

	internal static bool TryGetCountEasilyEnumerable<TSource>(IEnumerable<TSource> source, out int count)
	{
		if (source is ICollection<TSource> col)
		{
			count = col.Count;
			return true;
		}
		else if (source is IReadOnlyCollection<TSource> col2)
		{
			count = col2.Count;
			return true;
		}
		else if (source is string s)
		{
			count = s.Length;
			return true;
		}
		else
		{
			count = -1;
			return false;
		}
	}

	internal static bool TryGetCountEasilyEnumerable(IEnumerable source, out int count)
	{
		if (source is ICollection col)
		{
			count = col.Count;
			return true;
		}
		else if (source is string s)
		{
			count = s.Length;
			return true;
		}
		else
		{
			count = -1;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource>(IEnumerable<TSource> source, Func<IEnumerable<TSource>, List<TSource>> function, out List<TSource>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<IEnumerable<TSource>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource>(List<TSource> source, Func<List<TSource>, List<TSource>> function, out List<TSource>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource, TResult>(List<TSource> source, Func<List<TSource>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource>(TSource[] source, Func<TSource[], List<TSource>> function, out List<TSource>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource, TResult>(TSource[] source, Func<TSource[], TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource>(G.IList<TSource> source, Func<G.IList<TSource>, List<TSource>> function, out List<TSource>? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal static bool TryWrapEnumerable<TSource, TResult>(G.IList<TSource> source, Func<G.IList<TSource>, TResult> function, out TResult? result)
	{
		try
		{
			result = function(source);
			return true;
		}
		catch
		{
			result = default;
			return false;
		}
	}

	internal static bool AllEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (!function(source[i]))
				return false;
		return true;
	}

	internal static bool AllEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (!function(source[i], i))
				return false;
		return true;
	}

	internal static bool AnyEnumerable<TSource>(ReadOnlySpan<TSource> source)
	{
		int count = source.Length;
		return count != 0;
	}

	internal static bool AnyEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (function(source[i]))
				return true;
		return false;
	}

	internal static bool AnyEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (function(source[i], i))
				return true;
		return false;
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (List<TSource>, List<TSource2>) BreakEnumerable<TSource, TSource2>(ReadOnlySpan<(TSource, TSource2)> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		List<TSource2> result2 = new(count);
		for (int i = 0; i < count; i++)
			(result._items[i], result2._items[i]) = source[i];
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		List<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		List<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (List<TSource>, List<TSource2>, List<TSource3>) BreakEnumerable<TSource, TSource2, TSource3>(ReadOnlySpan<(TSource, TSource2, TSource3)> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		List<TSource2> result2 = new(count);
		List<TSource3> result3 = new(count);
		for (int i = 0; i < count; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source[i];
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		List<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (List<TResult>, List<TResult2>, List<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		List<TResult2> result2 = new(count);
		List<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source.Length, source2.Length);
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i]);
		result._size = count;
		return result;
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source.Length, source2.Length);
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i], i);
		result._size = count;
		return result;
	}

	internal static List<(TSource, TSource2)> CombineEnumerable<TSource, TSource2>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2)
	{
		int count = Math.Min(source.Length, source2.Length);
		List<(TSource, TSource2)> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = (source[i], source2[i]);
		result._size = count;
		return result;
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i], source3[i]);
		result._size = count;
		return result;
	}

	internal static List<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i], source3[i], i);
		result._size = count;
		return result;
	}

	internal static List<(TSource, TSource2, TSource3)> CombineEnumerable<TSource, TSource2, TSource3>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3)
	{
		int count = MinEnumerable(new[] { source.Length, source2.Length, source3.Length }.AsSpan());
		List<(TSource, TSource2, TSource3)> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = (source[i], source2[i], source3[i]);
		result._size = count;
		return result;
	}

	internal static List<TResult> ConvertEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i]);
		result._size = count;
		return result;
	}

	internal static List<TResult> ConvertEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], i);
		result._size = count;
		return result;
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result.AddRange(function(source[i]));
		return result;
	}

	internal static List<TResult> ConvertAndJoinEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, IEnumerable<TResult>> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result.AddRange(function(source[i], i));
		return result;
	}

	internal static int CountEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = 0;
		for (int i = 0; i < count; i++)
			if (function(source[i]))
				result++;
		return result;
	}

	internal static int CountEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = 0;
		for (int i = 0; i < count; i++)
			if (function(source[i], i))
				result++;
		return result;
	}

	internal static int CountEnumerable<TSource>(ReadOnlySpan<TSource> source, TSource target)
	{
		int count = source.Length;
		int result = 0;
		for (int i = 0; i < count; i++)
			if (source[i]?.Equals(target) ?? false)
				result++;
		return result;
	}

	internal static bool EqualsEnumerable<TSource, TSource2>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source.Length, source2.Length);
		for (int i = 0; i < count; i++)
			if (!function(source[i], source2[i]))
				return false;
		return true;
	}

	internal static bool EqualsEnumerable<TSource, TSource2>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source.Length, source2.Length);
		for (int i = 0; i < count; i++)
			if (!function(source[i], source2[i], i))
				return false;
		return true;
	}

	internal static bool EqualsEnumerable<TSource, TSource2>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2)
	{
		int count = Math.Min(source.Length, source2.Length);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (item == null || !item.Equals(source2[i]))
				return false;
		}
		return true;
	}

	internal static List<TSource> FilterEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (function(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FilterEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (function(item, i))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static TSource? FindEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (function(item))
				return item;
		}
		return default;
	}

	internal static TSource? FindEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (function(item, i))
				return item;
		}
		return default;
	}

	internal static List<TSource> FindAllEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (function(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (function(item, i))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<TSource> FindAllMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? FindAllEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x) => function(x) == value);
	}

	internal static List<TSource> FindAllMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindAllEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> FindAllMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<TSource> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = item;
			}
			else if (f == indicator!)
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
			if (function(source[i]))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
			if (function(source[i], i))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int FindIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (function(source[i]))
				return i;
		return -1;
	}

	internal static int FindIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (function(source[i], i))
				return i;
		return -1;
	}

	internal static int FindLastIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = count - 1; i >= 0; i--)
			if (function(source[i]))
				return i;
		return -1;
	}

	internal static int FindLastIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = count - 1; i >= 0; i--)
			if (function(source[i], i))
				return i;
		return -1;
	}

	internal static TSource? FindLastEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (function(item))
				return item;
		}
		return default;
	}

	internal static TSource? FindLastEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, bool> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (function(item, i))
				return item;
		}
		return default;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindLastMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindLastEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindLastMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindLastEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindLastMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindLastMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindLastIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindLastMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindLastIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindLastMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static TSource? FindMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x) => function(x) == value);
	}

	internal static TSource? FindMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = item;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static TSource? FindMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TSource? result = default;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = item;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = item;
			}
		}
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMaxIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x) => function(x) == value2) : new();
	}

	internal static List<int> FindMeanIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? FindIndexesEnumerable(source, (x, index) => function(x, index) == value2) : new();
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x) => function(x) == value);
	}

	internal static List<int> FindMedianIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindIndexesEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> FindMinIndexesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMaxIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MeanEnumerable(source, function);
		decimal? value2 = value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		double? value2 = value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		int? value2 = (int?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		uint? value2 = (uint?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		long? value2 = (long?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x) => function(x) == value2) : default;
	}

	internal static int FindMeanIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MeanEnumerable(source, function);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? default : value == value2 ? FindIndexEnumerable(source, (x, index) => function(x, index) == value2) : default;
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x) => function(x) == value);
	}

	internal static int FindMedianIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t? value = MedianEnumerable(source, function);
		return FindIndexEnumerable(source, (x, index) => function(x, index) == value);
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int FindMinIndexEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(EqualityComparer<TResult>.Default);
		int count = source.Length;
		List<(TResult Key, int Count)> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = function(source[i]), out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(EqualityComparer<TResult>.Default);
		int count = source.Length;
		List<(TResult Key, int Count)> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = function(source[i], i), out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(ReadOnlySpan<TSource> source) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(EqualityComparer<TSource>.Default);
		int count = source.Length;
		List<(TSource Key, int Count)> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = source[i], out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		int count = source.Length;
		List<(TResult Key, int Count)> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = function(source[i]), out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		int count = source.Length;
		List<(TResult Key, int Count)> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = function(source[i], i), out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		int count = source.Length;
		List<(TSource Key, int Count)> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = source[i], out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<(TResult Key, int Count)> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = function(source[i]), out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TResult Key, int Count)> FrequencyTableEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<(TResult Key, int Count)> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = function(source[i], i), out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<(TSource Key, int Count)> FrequencyTableEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<(TSource Key, int Count)> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			if (dic.TryGetValue(f = source[i], out int value))
				result._items[value].Count++;
			else
			{
				dic.Add(f, j);
				result._items[j++] = (f, 1);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(EqualityComparer<TResult>.Default);
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(EqualityComparer<TResult>.Default);
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item, i), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(ReadOnlySpan<TSource> source) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(EqualityComparer<TSource>.Default);
		int count = source.Length;
		List<Group<TSource, TSource>> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = item, out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(comparer);
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(comparer);
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item, i), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(ReadOnlySpan<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(comparer);
		int count = source.Length;
		List<Group<TSource, TSource>> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = item, out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction));
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item, i), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		int count = source.Length;
		List<Group<TSource, TSource>> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = item, out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TResult>> GroupEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		Dictionary<TResult, int> dic = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<Group<TSource, TResult>> result = new(count);
		int j = 0;
		TResult f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = function(item, i), out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<Group<TSource, TSource>> GroupEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<Group<TSource, TSource>> result = new(count);
		int j = 0;
		TSource f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(f = item, out int value))
				result._items[value].Add(item);
			else
			{
				dic.Add(f, j);
				result._items[j++] = new((List<TSource>)item, f);
			}
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfEnumerable<TSource>(ReadOnlySpan<TSource> source, TSource target)
	{
		int count = source.Length;
		List<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
			if (source[i]?.Equals(target) ?? false)
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MeanEnumerable(list_);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MeanEnumerable(list_);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(list_, value2) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		decimal? value = MeanEnumerable(source);
		decimal? value2 = value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(source, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		double? value = MeanEnumerable(source);
		double? value2 = value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(source, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		double? value = MeanEnumerable(source);
		int? value2 = (int?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(source, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		double? value = MeanEnumerable(source);
		uint? value2 = (uint?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(source, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		double? value = MeanEnumerable(source);
		long? value2 = (long?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(source, value2.Value) : new();
	}

	internal static List<int> IndexesOfMeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		double? value = MeanEnumerable(source);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? new() : value == value2 ? IndexesOfEnumerable(source, value2) : new();
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		int? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		int? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		uint? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		uint? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		long? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		long? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		mpz_t? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value);
	}

	internal static List<int> IndexesOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		mpz_t? value = MedianEnumerable(list_);
		return value == null ? new() : IndexesOfEnumerable(list_, value);
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<decimal> source)
	{
		decimal? value = MedianEnumerable(source);
		return value == null ? new() : IndexesOfEnumerable(source, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<double> source)
	{
		double? value = MedianEnumerable(source);
		return value == null ? new() : IndexesOfEnumerable(source, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<int> source)
	{
		int? value = MedianEnumerable(source);
		return value == null ? new() : IndexesOfEnumerable(source, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<uint> source)
	{
		uint? value = MedianEnumerable(source);
		return value == null ? new() : IndexesOfEnumerable(source, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<long> source)
	{
		long? value = MedianEnumerable(source);
		return value == null ? new() : IndexesOfEnumerable(source, value.Value);
	}

	internal static List<int> IndexesOfMedianEnumerable(ReadOnlySpan<mpz_t> source)
	{
		mpz_t? value = MedianEnumerable(source);
		return value == null ? new() : IndexesOfEnumerable(source, value);
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result._items[j++] = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result._items[j++] = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		decimal indicator = 0;
		int j = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		double indicator = 0;
		int j = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		int indicator = 0;
		int j = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		uint indicator = 0;
		int j = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		long indicator = 0;
		int j = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> IndexesOfMinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		List<int> result = new(count);
		mpz_t indicator = 0;
		int j = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			if (i == 0)
			{
				indicator = item;
				result._items[j++] = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result._items[j = 0] = i;
			}
			else if (f == indicator!)
				result._items[j++] = i;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static int IndexOfEnumerable<TSource>(ReadOnlySpan<TSource> source, TSource target)
	{
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (source[i]?.Equals(target) ?? false)
				return i;
		return -1;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MeanEnumerable(list_);
		decimal? value2 = value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MeanEnumerable(list_);
		decimal? value2 = value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		double? value2 = value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		double? value2 = value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		int? value2 = (int?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		int? value2 = (int?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		uint? value2 = (uint?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		uint? value2 = (uint?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		long? value2 = (long?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		long? value2 = (long?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : default;
	}

	internal static int IndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(list_, value2) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		decimal? value = MeanEnumerable(source);
		decimal? value2 = value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		double? value = MeanEnumerable(source);
		double? value2 = value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		double? value = MeanEnumerable(source);
		int? value2 = (int?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		double? value = MeanEnumerable(source);
		uint? value2 = (uint?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		double? value = MeanEnumerable(source);
		long? value2 = (long?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int IndexOfMeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		double? value = MeanEnumerable(source);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? -1 : value == value2 ? IndexOfEnumerable(source, value2) : default;
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		int? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		int? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		uint? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		uint? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		long? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		long? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value.Value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		mpz_t? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		mpz_t? value = MedianEnumerable(list_);
		return value == null ? -1 : IndexOfEnumerable(list_, value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<decimal> source)
	{
		decimal? value = MedianEnumerable(source);
		return value == null ? -1 : IndexOfEnumerable(source, value.Value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<double> source)
	{
		double? value = MedianEnumerable(source);
		return value == null ? -1 : IndexOfEnumerable(source, value.Value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<int> source)
	{
		int? value = MedianEnumerable(source);
		return value == null ? -1 : IndexOfEnumerable(source, value.Value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<uint> source)
	{
		uint? value = MedianEnumerable(source);
		return value == null ? -1 : IndexOfEnumerable(source, value.Value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<long> source)
	{
		long? value = MedianEnumerable(source);
		return value == null ? -1 : IndexOfEnumerable(source, value.Value);
	}

	internal static int IndexOfMedianEnumerable(ReadOnlySpan<mpz_t> source)
	{
		mpz_t? value = MedianEnumerable(source);
		return value == null ? -1 : IndexOfEnumerable(source, value);
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int IndexOfMinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<List<TSource>> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		for (int i = 0; i < count; i++)
		{
			List<TSource> item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TResult> JoinIntoSingleEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source) where TSource : IEnumerable<TResult>
	{
		int count = source.Length;
		List<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result.AddRange(source[i]);
		return result;
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<TSource[]> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource[] item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<G.IList<TSource>> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		for (int i = 0; i < count; i++)
		{
			G.IList<TSource> item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static List<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<IEnumerable<TSource>> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		for (int i = 0; i < count; i++)
		{
			IEnumerable<TSource> item = source[i];
			result.AddRange(item);
		}
		return result;
	}

	internal static int LastIndexOfEnumerable<TSource>(ReadOnlySpan<TSource> source, TSource target)
	{
		int count = source.Length;
		for (int i = 0; i < count; i++)
			if (source[i]?.Equals(target) ?? false)
				return i;
		return -1;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			decimal item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			double item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			int item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			uint item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			long item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			mpz_t item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) > indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MeanEnumerable(list_);
		decimal? value2 = value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MeanEnumerable(list_);
		decimal? value2 = value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		double? value2 = value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		double? value2 = value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		int? value2 = (int?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		int? value2 = (int?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		uint? value2 = (uint?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		uint? value2 = (uint?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		long? value2 = (long?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		long? value2 = (long?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : default;
	}

	internal static int LastIndexOfMeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		double? value = MeanEnumerable(list_);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(list_, value2) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<decimal> source)
	{
		decimal? value = MeanEnumerable(source);
		decimal? value2 = value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<double> source)
	{
		double? value = MeanEnumerable(source);
		double? value2 = value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<int> source)
	{
		double? value = MeanEnumerable(source);
		int? value2 = (int?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<uint> source)
	{
		double? value = MeanEnumerable(source);
		uint? value2 = (uint?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<long> source)
	{
		double? value = MeanEnumerable(source);
		long? value2 = (long?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(source, value2.Value) : default;
	}

	internal static int LastIndexOfMeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		double? value = MeanEnumerable(source);
		mpz_t? value2 = (mpz_t?)value;
		return value2 == null ? -1 : value == value2 ? LastIndexOfEnumerable(source, value2) : default;
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<decimal> list_ = ConvertEnumerable(source, function);
		decimal? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<double> list_ = ConvertEnumerable(source, function);
		double? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		int? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<int> list_ = ConvertEnumerable(source, function);
		int? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		uint? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<uint> list_ = ConvertEnumerable(source, function);
		uint? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		long? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<long> list_ = ConvertEnumerable(source, function);
		long? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		mpz_t? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		List<mpz_t> list_ = ConvertEnumerable(source, function);
		mpz_t? value = MedianEnumerable(list_);
		return value == null ? -1 : LastIndexOfEnumerable(list_, value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<decimal> source)
	{
		decimal? value = MedianEnumerable(source);
		return value == null ? -1 : LastIndexOfEnumerable(source, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<double> source)
	{
		double? value = MedianEnumerable(source);
		return value == null ? -1 : LastIndexOfEnumerable(source, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<int> source)
	{
		int? value = MedianEnumerable(source);
		return value == null ? -1 : LastIndexOfEnumerable(source, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<uint> source)
	{
		uint? value = MedianEnumerable(source);
		return value == null ? -1 : LastIndexOfEnumerable(source, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<long> source)
	{
		long? value = MedianEnumerable(source);
		return value == null ? -1 : LastIndexOfEnumerable(source, value.Value);
	}

	internal static int LastIndexOfMedianEnumerable(ReadOnlySpan<mpz_t> source)
	{
		mpz_t? value = MedianEnumerable(source);
		return value == null ? -1 : LastIndexOfEnumerable(source, value);
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item);
				result = i;
			}
			else if ((f = function(item)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			TSource item = source[i];
			if (i == 0)
			{
				indicator = function(item, i);
				result = i;
			}
			else if ((f = function(item, i)) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		int result = -1;
		decimal indicator = 0;
		decimal f;
		for (int i = count - 1; i >= 0; i--)
		{
			decimal item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		int result = -1;
		double indicator = 0;
		double f;
		for (int i = count - 1; i >= 0; i--)
		{
			double item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int result = -1;
		int indicator = 0;
		int f;
		for (int i = count - 1; i >= 0; i--)
		{
			int item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		int result = -1;
		uint indicator = 0;
		uint f;
		for (int i = count - 1; i >= 0; i--)
		{
			uint item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		int result = -1;
		long indicator = 0;
		long f;
		for (int i = count - 1; i >= 0; i--)
		{
			long item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static int LastIndexOfMinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		int result = -1;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = count - 1; i >= 0; i--)
		{
			mpz_t item = source[i];
			if (i == 0)
			{
				indicator = item;
				result = i;
			}
			else if ((f = item) < indicator!)
			{
				indicator = f;
				result = i;
			}
		}
		return result;
	}

	internal static decimal MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MaxEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MaxEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MaxEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MaxEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MaxEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MaxEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MaxEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) > indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static decimal MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += (double)function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += (double)function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += (double)function(source[i]);
		return result / source.Length;
	}

	internal static double MeanEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += (double)function(source[i], i);
		return result / source.Length;
	}

	internal static decimal MeanEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		decimal result = 0;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			result += (double)item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			result += item;
		}
		return result / source.Length;
	}

	internal static double MeanEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			result += (double)item;
		}
		return result / source.Length;
	}

	internal static decimal MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<decimal>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static decimal MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<decimal>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static double MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<double>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static double MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<double>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static int MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<int>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static int MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<int>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static uint MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<uint>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static uint MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<uint>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static long MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<long>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static long MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? default : List<long>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static mpz_t MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? 0 : List<mpz_t>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static mpz_t MedianEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		return source.Length == 0 ? 0 : List<mpz_t>.ConvertEnumerable(source, function).Sort()[(source.Length - 1) / 2];
	}

	internal static decimal MedianEnumerable(ReadOnlySpan<decimal> source) => source.Length == 0 ? default : new List<decimal>(source).Sort()[(source.Length - 1) / 2];

	internal static double MedianEnumerable(ReadOnlySpan<double> source) => source.Length == 0 ? default : new List<double>(source).Sort()[(source.Length - 1) / 2];

	internal static int MedianEnumerable(ReadOnlySpan<int> source) => source.Length == 0 ? default : new List<int>(source).Sort()[(source.Length - 1) / 2];

	internal static uint MedianEnumerable(ReadOnlySpan<uint> source) => source.Length == 0 ? default : new List<uint>(source).Sort()[(source.Length - 1) / 2];

	internal static long MedianEnumerable(ReadOnlySpan<long> source) => source.Length == 0 ? default : new List<long>(source).Sort()[(source.Length - 1) / 2];

	internal static mpz_t MedianEnumerable(ReadOnlySpan<mpz_t> source) => source.Length == 0 ? 0 : new List<mpz_t>(source).Sort()[(source.Length - 1) / 2];

	internal static TSource? MedianEnumerable<TSource>(ReadOnlySpan<TSource> source) => source.Length == 0 ? default : new List<TSource>(source).Sort()[(source.Length - 1) / 2];

	internal static decimal MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item);
			else if ((f = function(item)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MinEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (i == 0)
				indicator = function(item, i);
			else if ((f = function(item, i)) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static decimal MinEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		decimal indicator = 0;
		decimal f;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static double MinEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		double indicator = 0;
		double f;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static int MinEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int indicator = 0;
		int f;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static uint MinEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		uint indicator = 0;
		uint f;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static long MinEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		long indicator = 0;
		long f;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static mpz_t MinEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		mpz_t indicator = 0;
		mpz_t f;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			if (i == 0)
				indicator = item;
			else if ((f = item) < indicator!)
				indicator = f;
		}
		return indicator;
	}

	internal static TSource? ProgressionEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, TSource> function)
	{
		int count = source.Length;
		TSource? result = default;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (result == null)
				result = item;
			else
				result = function(result, item);
		}
		return result;
	}

	internal static TResult? ProgressionEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, TResult seed, Func<TResult, TSource, TResult> function)
	{
		int count = source.Length;
		TResult? result = default;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (result == null)
				result = seed;
			else
				result = function(result, item);
		}
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(function(item)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(function(item, i)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(ReadOnlySpan<TSource> source)
	{
		HashSet<TSource> hs = new(EqualityComparer<TSource>.Default);
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(function(item)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(function(item, i)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction)
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(function(item)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(function(item, i)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<TSource> RemoveDoublesEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction)
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (hs.TryAdd(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(ReadOnlySpan<TSource> source) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(EqualityComparer<TSource>.Default);
		int count = source.Length;
		List<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(item, out int value))
				result._items[i] = value;
			else
				dic.Add(item, result._items[i] = j++);
		}
		result._size = count;
		return result;
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		int count = source.Length;
		List<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(item, out int value))
				result._items[i] = value;
			else
				dic.Add(item, result._items[i] = j++);
		}
		result._size = count;
		return result;
	}

	internal static List<int> RepresentIntoNumbersEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		int count = source.Length;
		List<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			if (dic.TryGetValue(item, out int value))
				result._items[i] = value;
			else
				dic.Add(item, result._items[i] = j++);
		}
		result._size = count;
		return result;
	}

	internal static List<TSource> ReverseEnumerable<TSource>(ReadOnlySpan<TSource> source)
	{
		int count = source.Length;
		List<TSource> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[^(i + 1)] = source[i];
		result._size = count;
		return result;
	}

	internal static decimal SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result;
	}

	internal static decimal SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		decimal result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result;
	}

	internal static double SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result;
	}

	internal static double SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, double> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result;
	}

	internal static int SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result;
	}

	internal static int SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, int> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		int result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result;
	}

	internal static uint SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result;
	}

	internal static uint SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, uint> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		uint result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result;
	}

	internal static long SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result;
	}

	internal static long SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, long> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		long result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result;
	}

	internal static mpz_t SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i]);
		return result;
	}

	internal static mpz_t SumEnumerable<TSource>(ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		mpz_t result = 0;
		for (int i = 0; i < count; i++)
			result += function(source[i], i);
		return result;
	}

	internal static decimal SumEnumerable(ReadOnlySpan<decimal> source)
	{
		int count = source.Length;
		decimal result = 0;
		for (int i = 0; i < count; i++)
		{
			decimal item = source[i];
			result += item;
		}
		return result;
	}

	internal static double SumEnumerable(ReadOnlySpan<double> source)
	{
		int count = source.Length;
		double result = 0;
		for (int i = 0; i < count; i++)
		{
			double item = source[i];
			result += item;
		}
		return result;
	}

	internal static int SumEnumerable(ReadOnlySpan<int> source)
	{
		int count = source.Length;
		int result = 0;
		for (int i = 0; i < count; i++)
		{
			int item = source[i];
			result += item;
		}
		return result;
	}

	internal static uint SumEnumerable(ReadOnlySpan<uint> source)
	{
		int count = source.Length;
		uint result = 0;
		for (int i = 0; i < count; i++)
		{
			uint item = source[i];
			result += item;
		}
		return result;
	}

	internal static long SumEnumerable(ReadOnlySpan<long> source)
	{
		int count = source.Length;
		long result = 0;
		for (int i = 0; i < count; i++)
		{
			long item = source[i];
			result += item;
		}
		return result;
	}

	internal static mpz_t SumEnumerable(ReadOnlySpan<mpz_t> source)
	{
		int count = source.Length;
		mpz_t result = 0;
		for (int i = 0; i < count; i++)
		{
			mpz_t item = source[i];
			result += item;
		}
		return result;
	}

	internal static TResult[] ToArrayEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TResult[] result = new TResult[count];
		for (int i = 0; i < count; i++)
			result[i] = function(source[i]);
		return result;
	}

	internal static TResult[] ToArrayEnumerable<TSource, TResult>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function)
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		TResult[] result = new TResult[count];
		for (int i = 0; i < count; i++)
			result[i] = function(source[i], i);
		return result;
	}

	internal static IEnumerable<TResult> ConvertAndJoin<TSource, TCollection, TResult>(IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, int, TResult> resultSelector)
	{
		int i = 0, j = 0;
		return Enumerable.SelectMany(source, x => collectionSelector(x, i++), (x, y) => resultSelector(x, y, j++));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), comparer);
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++));
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), comparer);
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), (x, y) => resultSelector(x, y, j++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupBy(source, x => keySelector(x, i++), x => elementSelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.GroupJoin(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), comparer);
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction));
	}

	internal static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction)
	{
		int i = 0, j = 0, k = 0;
		return Enumerable.Join(outer, inner, x => outerKeySelector(x, i++), x => innerKeySelector(x, j++), (x, y) => resultSelector(x, y, k++), new EComparer<TKey>(equalFunction, hashCodeFunction));
	}

	internal static TResult? Max<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		int i = 0;
		return Enumerable.Max(source, x => function(x, i++));
	}

	internal static TResult? Min<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		int i = 0;
		return Enumerable.Min(source, x => function(x, i++));
	}

	internal static IEnumerable<TSource> Sort<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		int i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++));
	}

	internal static IEnumerable<TSource> Sort<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, IComparer<TResult> comparer)
	{
		int i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++), comparer);
	}

	internal static IEnumerable<TSource> Sort<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, int> compareFunction)
	{
		int i = 0;
		return Enumerable.OrderBy(source, x => function(x, i++), new Comparer<TResult>(compareFunction));
	}

	internal static IEnumerable<TSource> SortDesc<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function)
	{
		int i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++));
	}

	internal static IEnumerable<TSource> SortDesc<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, IComparer<TResult> comparer)
	{
		int i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++), comparer);
	}

	internal static IEnumerable<TSource> SortDesc<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, int> compareFunction)
	{
		int i = 0;
		return Enumerable.OrderByDescending(source, x => function(x, i++), new Comparer<TResult>(compareFunction));
	}
}

public unsafe partial class NList<T>
{
	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2);
	}

	internal static (NList<TSource>, NList<TSource2>) BreakEnumerable<TSource, TSource2>(IEnumerable<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged
	{
		if (source is List<(TSource, TSource2)> list)
		{
			int count = list.Length;
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i]) = list[i];
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is (TSource, TSource2)[] array)
		{
			int count = array.Length;
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i]) = array[i];
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<(TSource, TSource2)> list2)
		{
			int count = list2.Count;
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i]) = list2[i];
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			int i = 0;
			foreach ((TSource, TSource2) item in source)
			{
				(result._items[i], result2._items[i]) = item;
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<(TSource, TSource2)>(source));
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i]) = function(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i]) = function(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			return (result, result2);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item);
				result2._items[i] = function2(item);
				result3._items[i] = function3(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2, function3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item, i);
				result2._items[i] = function2(item, i);
				result3._items[i] = function3(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function, function2, function3);
	}

	internal static (NList<TSource>, NList<TSource2>, NList<TSource3>) BreakEnumerable<TSource, TSource2, TSource3>(IEnumerable<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged
	{
		if (source is List<(TSource, TSource2, TSource3)> list)
		{
			int count = list.Length;
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			NList<TSource3> result3 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list[i];
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is (TSource, TSource2, TSource3)[] array)
		{
			int count = array.Length;
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			NList<TSource3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
				(result._items[i], result2._items[i], result3._items[i]) = array[i];
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<(TSource, TSource2, TSource3)> list2)
		{
			int count = list2.Count;
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			NList<TSource3> result3 = new(count);
			for (int i = 0; i < count; i++)
				(result._items[i], result2._items[i], result3._items[i]) = list2[i];
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TSource> result = new(count);
			NList<TSource2> result2 = new(count);
			NList<TSource3> result3 = new(count);
			int i = 0;
			foreach ((TSource, TSource2, TSource3) item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = item;
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<(TSource, TSource2, TSource3)>(source));
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is TSource[] array)
		{
			int count = array.Length;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			NList<TResult2> result2 = new(count);
			NList<TResult3> result3 = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
				i++;
			}
			result._size = count;
			result2._size = count;
			result3._size = count;
			return (result, result2, result3);
		}
		else
			return BreakEnumerable(new List<TSource>(source), function);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TSource>, NList<TSource2>) BreakEnumerable<TSource, TSource2>(ReadOnlySpan<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged
	{
		int count = source.Length;
		NList<TSource> result = new(count);
		NList<TSource2> result2 = new(count);
		for (int i = 0; i < count; i++)
			(result._items[i], result2._items[i]) = source[i];
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TSource>, NList<TSource2>, NList<TSource3>) BreakEnumerable<TSource, TSource2, TSource3>(ReadOnlySpan<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged
	{
		int count = source.Length;
		NList<TSource> result = new(count);
		NList<TSource2> result2 = new(count);
		NList<TSource3> result3 = new(count);
		for (int i = 0; i < count; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source[i];
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source.Length;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(NList<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(NList<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TSource>, NList<TSource2>) BreakEnumerable<TSource, TSource2>(NList<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged
	{
		int count = source._size;
		NList<TSource> result = new(count);
		NList<TSource2> result2 = new(count);
		for (int i = 0; i < count; i++)
			(result._items[i], result2._items[i]) = source._items[i];
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(NList<TSource> source, Func<TSource, (TResult, TResult2)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			(result._items[i], result2._items[i]) = function(item);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>) BreakEnumerable<TSource, TResult, TResult2>(NList<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			(result._items[i], result2._items[i]) = function(item, i);
		}
		result._size = count;
		result2._size = count;
		return (result, result2);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(NList<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		if (function3 == null)
			throw new ArgumentNullException(nameof(function3));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			result._items[i] = function(item);
			result2._items[i] = function2(item);
			result3._items[i] = function3(item);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(NList<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (function2 == null)
			throw new ArgumentNullException(nameof(function2));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			result._items[i] = function(item, i);
			result2._items[i] = function2(item, i);
			result3._items[i] = function3(item, i);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TSource>, NList<TSource2>, NList<TSource3>) BreakEnumerable<TSource, TSource2, TSource3>(NList<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged
	{
		int count = source._size;
		NList<TSource> result = new(count);
		NList<TSource2> result2 = new(count);
		NList<TSource3> result3 = new(count);
		for (int i = 0; i < count; i++)
			(result._items[i], result2._items[i], result3._items[i]) = source._items[i];
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(NList<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static (NList<TResult>, NList<TResult2>, NList<TResult3>) BreakEnumerable<TSource, TResult, TResult2, TResult3>(NList<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		NList<TResult2> result2 = new(count);
		NList<TResult3> result3 = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			(result._items[i], result2._items[i], result3._items[i]) = function(item, i);
		}
		result._size = count;
		result2._size = count;
		result3._size = count;
		return (result, result2, result3);
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list.Length, list2.Length);
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				TSource2 item2 = list2[i];
				result._items[i] = function(item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				result._items[i] = function(item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				result._items[i] = function(item, item2);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(List<TSource>.ReturnOrConstruct(source), List<TSource2>.ReturnOrConstruct(source2), function);
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list.Length, list2.Length);
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				TSource2 item2 = list2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				result._items[i] = function(item, item2, i);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(List<TSource>.ReturnOrConstruct(source), List<TSource2>.ReturnOrConstruct(source2), function);
	}

	internal static NList<(TSource, TSource2)> CombineEnumerable<TSource, TSource2>(IEnumerable<TSource> source, IEnumerable<TSource2> source2) where TSource : unmanaged where TSource2 : unmanaged
	{
		if (source is List<TSource> list && source2 is List<TSource2> list2)
		{
			int count = Math.Min(list.Length, list2.Length);
			NList<(TSource, TSource2)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				TSource2 item2 = list2[i];
				result._items[i] = (item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2)
		{
			int count = Math.Min(array.Length, array2.Length);
			NList<(TSource, TSource2)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				result._items[i] = (item, item2);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2)
		{
			int count = Math.Min(list2_.Count, list2_2.Count);
			NList<(TSource, TSource2)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				result._items[i] = (item, item2);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(List<TSource>.ReturnOrConstruct(source), List<TSource2>.ReturnOrConstruct(source2));
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2 && source3 is List<TSource3> list3)
		{
			int count = List<int>.MinEnumerable(new[] { list.Length, list2.Length, list3.Length }.AsSpan());
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				TSource2 item2 = list2[i];
				TSource3 item3 = list3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2 && source3 is TSource3[] array3)
		{
			int count = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				TSource3 item3 = array3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2 && source3 is G.IList<TSource3> list2_3)
		{
			int count = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				TSource3 item3 = list2_3[i];
				result._items[i] = function(item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(List<TSource>.ReturnOrConstruct(source), List<TSource2>.ReturnOrConstruct(source2), List<TSource3>.ReturnOrConstruct(source3), function);
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list && source2 is List<TSource2> list2 && source3 is List<TSource3> list3)
		{
			int count = List<int>.MinEnumerable(new[] { list.Length, list2.Length, list3.Length }.AsSpan());
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				TSource2 item2 = list2[i];
				TSource3 item3 = list3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2 && source3 is TSource3[] array3)
		{
			int count = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				TSource3 item3 = array3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2 && source3 is G.IList<TSource3> list2_3)
		{
			int count = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				TSource3 item3 = list2_3[i];
				result._items[i] = function(item, item2, item3, i);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(List<TSource>.ReturnOrConstruct(source), List<TSource2>.ReturnOrConstruct(source2), List<TSource3>.ReturnOrConstruct(source3), function);
	}

	internal static NList<(TSource, TSource2, TSource3)> CombineEnumerable<TSource, TSource2, TSource3>(IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged
	{
		if (source is List<TSource> list && source2 is List<TSource2> list2 && source3 is List<TSource3> list3)
		{
			int count = List<int>.MinEnumerable(new[] { list.Length, list2.Length, list3.Length }.AsSpan());
			NList<(TSource, TSource2, TSource3)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				TSource2 item2 = list2[i];
				TSource3 item3 = list3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array && source2 is TSource2[] array2 && source3 is TSource3[] array3)
		{
			int count = List<int>.MinEnumerable(new[] { array.Length, array2.Length, array3.Length }.AsSpan());
			NList<(TSource, TSource2, TSource3)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = array[i];
				TSource2 item2 = array2[i];
				TSource3 item3 = array3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else if (source is G.IList<TSource> list2_ && source2 is G.IList<TSource2> list2_2 && source3 is G.IList<TSource3> list2_3)
		{
			int count = List<int>.MinEnumerable(new[] { list2_.Count, list2_2.Count, list2_3.Count }.AsSpan());
			NList<(TSource, TSource2, TSource3)> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2_[i];
				TSource2 item2 = list2_2[i];
				TSource3 item3 = list2_3[i];
				result._items[i] = (item, item2, item3);
			}
			result._size = count;
			return result;
		}
		else
			return CombineEnumerable(List<TSource>.ReturnOrConstruct(source), List<TSource2>.ReturnOrConstruct(source2), List<TSource3>.ReturnOrConstruct(source3));
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source.Length, source2.Length);
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source.Length, source2.Length);
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i], i);
		result._size = count;
		return result;
	}

	internal static NList<(TSource, TSource2)> CombineEnumerable<TSource, TSource2>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2) where TSource : unmanaged where TSource2 : unmanaged
	{
		int count = Math.Min(source.Length, source2.Length);
		NList<(TSource, TSource2)> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = (source[i], source2[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source.Length, source2.Length, source3.Length });
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i], source3[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source.Length, source2.Length, source3.Length });
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source[i], source2[i], source3[i], i);
		result._size = count;
		return result;
	}

	internal static NList<(TSource, TSource2, TSource3)> CombineEnumerable<TSource, TSource2, TSource3>(ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged
	{
		int count = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source.Length, source2.Length, source3.Length });
		NList<(TSource, TSource2, TSource3)> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = (source[i], source2[i], source3[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TResult>(NList<TSource> source, NList<TSource2> source2, Func<TSource, TSource2, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source._size, source2._size);
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source._items[i], source2._items[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TResult>(NList<TSource> source, NList<TSource2> source2, Func<TSource, TSource2, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = Math.Min(source._size, source2._size);
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source._items[i], source2._items[i], i);
		result._size = count;
		return result;
	}

	internal static NList<(TSource, TSource2)> CombineEnumerable<TSource, TSource2>(NList<TSource> source, NList<TSource2> source2) where TSource : unmanaged where TSource2 : unmanaged
	{
		int count = Math.Min(source._size, source2._size);
		NList<(TSource, TSource2)> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = (source._items[i], source2._items[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(NList<TSource> source, NList<TSource2> source2, NList<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source._size, source2._size, source3._size });
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source._items[i], source2._items[i], source3._items[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> CombineEnumerable<TSource, TSource2, TSource3, TResult>(NList<TSource> source, NList<TSource2> source2, NList<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source._size, source2._size, source3._size });
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source._items[i], source2._items[i], source3._items[i], i);
		result._size = count;
		return result;
	}

	internal static NList<(TSource, TSource2, TSource3)> CombineEnumerable<TSource, TSource2, TSource3>(NList<TSource> source, NList<TSource2> source2, NList<TSource3> source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged
	{
		int count = List<int>.MinEnumerable((ReadOnlySpan<int>)new[] { source._size, source2._size, source3._size });
		NList<(TSource, TSource2, TSource3)> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = (source._items[i], source2._items[i], source3._items[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> ConvertEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, TResult> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list[i]);
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			NList<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
				result._items[i] = function(array[i]);
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
				result._items[i] = function(list2[i]);
			result._size = count;
			return result;
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return ConvertEnumerable(new NList<TSource>(source), function);
	}

	internal static NList<TResult> ConvertEnumerable<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		if (source is List<TSource> list)
		{
			int count = list.Length;
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list[i];
				result._items[i] = function(item, i);
			}
			result._size = count;
			return result;
		}
		else if (source is TSource[] array)
		{
			NList<TResult> result = new(array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				TSource item = array[i];
				result._items[i] = function(item, i);
			}
			result._size = array.Length;
			return result;
		}
		else if (source is G.IList<TSource> list2)
		{
			int count = list2.Count;
			NList<TResult> result = new(count);
			for (int i = 0; i < count; i++)
			{
				TSource item = list2[i];
				result._items[i] = function(item, i);
			}
			result._size = count;
			return result;
		}
		else if (List<TSource>.TryGetCountEasilyEnumerable(source, out int count))
		{
			NList<TResult> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i] = function(item, i);
				i++;
			}
			result._size = count;
			return result;
		}
		else
			return ConvertEnumerable(new NList<TSource>(source), function);
	}

	internal static NList<TResult> ConvertEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, TResult> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[i] = function(source._items[i]);
		result._size = count;
		return result;
	}

	internal static NList<TResult> ConvertEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, int, TResult> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			result._items[i] = function(item, i);
		}
		result._size = count;
		return result;
	}

	internal static NList<TResult> ConvertAndJoinEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, IEnumerable<TResult>> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result.AddRange(function(source._items[i]));
		return result;
	}

	internal static NList<TResult> ConvertAndJoinEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, int, IEnumerable<TResult>> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TResult> result = new(count);
		for (int i = 0; i < count; i++)
			result.AddRange(function(source._items[i], i));
		return result;
	}

	internal static NList<TSource> FilterEnumerable<TSource>(NList<TSource> source, Func<TSource, bool> function) where TSource : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (function(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> FilterEnumerable<TSource>(NList<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (function(item, i))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> FindAllEnumerable<TSource>(NList<TSource> source, Func<TSource, bool> function) where TSource : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (function(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> FindAllEnumerable<TSource>(NList<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (function(item, i))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> IndexesOfEnumerable<TSource>(NList<TSource> source, TSource target) where TSource : unmanaged
	{
		int count = source._size;
		NList<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
			if (source._items[i].Equals(target))
				result._items[j++] = i;
		result._size = j;
		result.TrimExcess();
		return result;
	}

	//internal static NList<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<NList<TSource>> source) where TSource : unmanaged
	//{
	//	int _size = source._size;
	//	NList<TSource> result = new(_size);
	//	for (int i = 0; i < _size; i++)
	//	{
	//		NList<TSource> item = source._items[i];
	//		result.AddRange(item);
	//	}
	//	return result;
	//}

	//internal static NList<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<TSource[]> source) where TSource : unmanaged
	//{
	//	int _size = source._size;
	//	NList<TSource> result = new(_size);
	//	for (int i = 0; i < _size; i++)
	//	{
	//		TSource[] item = source._items[i];
	//		result.AddRange(item);
	//	}
	//	return result;
	//}

	//internal static NList<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<G.IList<TSource>> source) where TSource : unmanaged
	//{
	//	int _size = source._size;
	//	NList<TSource> result = new(_size);
	//	for (int i = 0; i < _size; i++)
	//	{
	//		G.IList<TSource> item = source._items[i];
	//		result.AddRange(item);
	//	}
	//	return result;
	//}

	//internal static NList<TSource> JoinIntoSingleEnumerable<TSource>(ReadOnlySpan<IEnumerable<TSource>> source) where TSource : unmanaged
	//{
	//	int _size = source._size;
	//	NList<TSource> result = new(_size);
	//	for (int i = 0; i < _size; i++)
	//	{
	//		IEnumerable<TSource> item = source._items[i];
	//		result.AddRange(item);
	//	}
	//	return result;
	//}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, TResult> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(function(item)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, int, TResult> function) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(EqualityComparer<TResult>.Default);
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource>(NList<TSource> source) where TSource : unmanaged
	{
		HashSet<TSource> hs = new(EqualityComparer<TSource>.Default);
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(function(item)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource>(NList<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : unmanaged
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(function(item)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource, TResult>(NList<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TSource : unmanaged where TResult : unmanaged
	{
		if (function == null)
			throw new ArgumentNullException(nameof(function));
		HashSet<TResult> hs = new(new EComparer<TResult>(equalFunction, hashCodeFunction));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(function(item, i)))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<TSource> RemoveDoublesEnumerable<TSource>(NList<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : unmanaged
	{
		HashSet<TSource> hs = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		int count = source._size;
		NList<TSource> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (hs.TryAdd(item))
				result._items[j++] = item;
		}
		result._size = j;
		result.TrimExcess();
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable<TSource>(NList<TSource> source) where TSource : unmanaged
	{
		Dictionary<TSource, int> dic = new(EqualityComparer<TSource>.Default);
		int count = source._size;
		NList<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (dic.TryGetValue(item, out int value))
				result._items[i] = value;
			else
				dic.Add(item, result._items[i] = j++);
		}
		result._size = count;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable<TSource>(NList<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : unmanaged
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction));
		int count = source._size;
		NList<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (dic.TryGetValue(item, out int value))
				result._items[i] = value;
			else
				dic.Add(item, result._items[i] = j++);
		}
		result._size = count;
		return result;
	}

	internal static NList<int> RepresentIntoNumbersEnumerable<TSource>(NList<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : unmanaged
	{
		Dictionary<TSource, int> dic = new(new EComparer<TSource>(equalFunction, hashCodeFunction));
		int count = source._size;
		NList<int> result = new(count);
		int j = 0;
		for (int i = 0; i < count; i++)
		{
			TSource item = source._items[i];
			if (dic.TryGetValue(item, out int value))
				result._items[i] = value;
			else
				dic.Add(item, result._items[i] = j++);
		}
		result._size = count;
		return result;
	}

	internal static NList<TSource> ReverseEnumerable<TSource>(NList<TSource> source) where TSource : unmanaged
	{
		int count = source._size;
		NList<TSource> result = new(count);
		for (int i = 0; i < count; i++)
			result._items[source._size - 1 - i] = source._items[i];
		result._size = count;
		return result;
	}

	internal static NList<TSource> SkipWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function) where TSource : unmanaged
	{
		if (source is NList<TSource> list)
			return list.SkipWhile(function);
		else
		{
			NList<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			for (; en.MoveNext() && function(en.Current); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result;
		}
	}

	internal static NList<TSource> SkipWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged
	{
		if (source is NList<TSource> list)
			return list.SkipWhile(function);
		else
		{
			NList<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			for (; en.MoveNext() && function(en.Current, i); i++) ;
			for (; en.MoveNext(); i++) result.Add(en.Current);
			return result;
		}
	}

	internal static List<NList<TSource>> SplitIntoEqualEnumerable<TSource>(NList<TSource> source, int fragmentLength) where TSource : unmanaged
	{
		if (fragmentLength <= 0)
			throw new ArgumentException(null, nameof(fragmentLength));
		int count = GetArrayLength(source._size, fragmentLength);
		List<NList<TSource>> result = new(count);
		int count2 = source._size / fragmentLength;
		int index = 0;
		for (int i = 0; i < count2; i++)
		{
			result.Add((NList<TSource>)(new(fragmentLength)));
			for (int j = 0; j < fragmentLength; j++)
				result[i]._items[j] = source[index++];
			result[i]._size = fragmentLength;
		}
		int rest = source._size % fragmentLength;
		if (rest != 0)
		{
			result.Add((NList<TSource>)(new(rest)));
			for (int j = 0; j < rest; j++)
				result[count2]._items[j] = source[index++];
			result[count2]._size = rest;
		}
		return result;
	}

	internal static NList<TSource> TakeEnumerable<TSource>(IEnumerable<TSource> source, int count) where TSource : unmanaged
	{
		if (count == 0)
			return new();
		else if (source is NList<TSource> list)
			return list.Take(count);
		else
		{
			NList<TSource> result = new(count);
			int i = 0;
			foreach (TSource item in source)
			{
				result._items[i++] = item;
				if (i >= count)
					break;
			}
			result._size = i;
			return result;
		}
	}

	internal static NList<TSource> TakeWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, bool> function) where TSource : unmanaged
	{
		if (source is NList<TSource> list)
			return list.TakeWhile(function);
		else
		{
			NList<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			TSource item;
			for (; en.MoveNext() && function(item = en.Current); i++) result.Add(item);
			return result;
		}
	}

	internal static NList<TSource> TakeWhileEnumerable<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged
	{
		if (source is NList<TSource> list)
			return list.TakeWhile(function);
		else
		{
			NList<TSource> result = new();
			IEnumerator<TSource> en = source.GetEnumerator();
			int i = 0;
			TSource item;
			for (; en.MoveNext() && function(item = en.Current, i); i++) result.Add(item);
			return result;
		}
	}
}

public static class OptimizedLinq
{
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.AllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.AllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TResult>(this IEnumerable<TResult> source) => List<TResult>.AnyEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.AnyEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.AnyEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> AsEnumerable<TSource>(this IEnumerable<TSource> source) => source;
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Span<TSource> AsSpan<TSource>(this IEnumerable<TSource> source) => List<TSource>.ReturnOrConstruct(source).AsSpan();
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Span<TSource> AsSpan<TSource>(this IEnumerable<TSource> source, int index) => List<TSource>.ReturnOrConstruct(source).AsSpan(index);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Span<TSource> AsSpan<TSource>(this IEnumerable<TSource> source, int index, int count) => List<TSource>.ReturnOrConstruct(source).AsSpan(index, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) => List<TSource>.BreakEnumerable(source, function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) => List<TSource>.BreakEnumerable(source, function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) Break<TSource, TSource2>(this IEnumerable<(TSource, TSource2)> source) => List<TSource>.BreakEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, (TResult, TResult2)> function) => List<TSource>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2)> function) => List<TSource>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) => List<TSource>.BreakEnumerable(source, function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) => List<TSource>.BreakEnumerable(source, function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>, List<TSource3>) Break<TSource, TSource2, TSource3>(this IEnumerable<(TSource, TSource2, TSource3)> source) => List<TSource>.BreakEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) => List<TSource>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) => List<TSource>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, TResult> function) => List<TResult>.CombineEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, int, TResult> function) => List<TResult>.CombineEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2)> Combine<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2) => List<(TSource, TSource2)>.CombineEnumerable(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) => List<TResult>.CombineEnumerable(source, source2, source3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) => List<TResult>.CombineEnumerable(source, source2, source3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2, TSource3)> Combine<TSource, TSource2, TSource3>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEnumerable<TSource3> source3) => List<(TSource, TSource2, TSource3)>.CombineEnumerable(source, source2, source3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TSource2, TResult> function) => List<TResult>.CombineEnumerable(source.Item1, source.Item2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TSource2, int, TResult> function) => List<TResult>.CombineEnumerable(source.Item1, source.Item2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2)> Combine<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source) => List<(TSource, TSource2)>.CombineEnumerable(source.Item1, source.Item2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>, IEnumerable<TSource3>) source, Func<TSource, TSource2, TSource3, TResult> function) => List<TResult>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>, IEnumerable<TSource3>) source, Func<TSource, TSource2, TSource3, int, TResult> function) => List<TResult>.CombineEnumerable(source.Item1, source.Item2, source.Item3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2, TSource3)> Combine<TSource, TSource2, TSource3>(this (IEnumerable<TSource>, IEnumerable<TSource2>, IEnumerable<TSource3>) source) => List<(TSource, TSource2, TSource3)>.CombineEnumerable(source.Item1, source.Item2, source.Item3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Concat<TSource>(this IEnumerable<TSource> source, params IEnumerable<TSource>[] collections) => List<TSource>.ConcatEnumerable(source, collections);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource target) => List<bool>.ContainsEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource target, IEqualityComparer<TSource> comparer) => List<bool>.ContainsEnumerable(source, target, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction) => List<bool>.ContainsEnumerable(source, target, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<bool>.ContainsEnumerable(source, target, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) => List<TResult>.ConvertEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.ConvertEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> ConvertAndJoin<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector) => Enumerable.SelectMany(source, collectionSelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> ConvertAndJoin<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, int, TResult> resultSelector) => List<TResult>.ConvertAndJoin(source, collectionSelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<List<TSource>> CopyDoubleList<TSource>(this List<List<TSource>> source) => source.Convert<List<TSource>>(x => new List<TSource>(x));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<List<List<TSource>>> CopyTripleList<TSource>(this List<List<List<TSource>>> source) => source.Convert<List<List<TSource>>>(x => x.CopyDoubleList());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this IEnumerable<TSource> source) => List<int>.CountEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<int>.CountEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<int>.CountEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this IEnumerable<TSource> source, TSource target) => List<int>.CountEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource?> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source) => Enumerable.DefaultIfEmpty(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source, TSource defaultValue) => Enumerable.DefaultIfEmpty(source, defaultValue);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int index) => Enumerable.ElementAt(source, index);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, int index) => Enumerable.ElementAtOrDefault(source, index);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource?> Empty<TSource>() => Enumerable.Empty<TSource>();
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, bool> function) => List<bool>.EqualsEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource2, int, bool> function) => List<bool>.EqualsEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2) => List<bool>.EqualsEnumerable(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> source2) => Enumerable.Except(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer) => Enumerable.Except(source, source2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Fill<TResult>(TResult elem, int count) => List<TResult>.FillEnumerable(elem, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Fill<TResult>(Func<int, TResult> function, int count) => List<TResult>.FillEnumerable(function, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Fill<TResult>(int count, Func<int, TResult> function) => List<TResult>.FillEnumerable(function, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] FillArray<TResult>(TResult elem, int count) => List<TResult>.FillArrayEnumerable(elem, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] FillArray<TResult>(Func<int, TResult> function, int count) => List<TResult>.FillArrayEnumerable(function, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] FillArray<TResult>(int count, Func<int, TResult> function) => List<TResult>.FillArrayEnumerable(function, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FilterEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FilterEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FindEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FindAllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindAllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FindIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FindIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FindLastEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindLastEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<bool>.FindLastIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindLastIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this IEnumerable<TSource> source) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this IEnumerable<TSource> source) where TSource : notnull => List<TSource>.GroupEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull => List<TSource>.GroupEnumerable(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.GroupEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector) => Enumerable.GroupBy(source, keySelector, elementSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector) => List<TSource>.Group(source, keySelector, elementSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, elementSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, IEqualityComparer<TKey> comparer) => List<TSource>.Group(source, keySelector, elementSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction) => List<TSource>.Group(source, keySelector, elementSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<IGrouping<TKey, TElement>> Group<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TSource>.Group(source, keySelector, elementSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector) => Enumerable.GroupBy(source, keySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector) => List<TSource>.Group(source, keySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<TSource>.Group(source, keySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, resultSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<TSource>.Group(source, keySelector, resultSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TKey, IEnumerable<TSource>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TSource>.Group(source, keySelector, resultSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector) => List<TSource>.Group(source, keySelector, elementSelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<TSource>.Group(source, keySelector, elementSelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<TSource>.Group(source, keySelector, elementSelector, resultSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupBy(source, keySelector, elementSelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Group<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TKey> keySelector, Func<TSource, int, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TSource>.Group(source, keySelector, elementSelector, resultSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector) => List<TResult>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<TResult>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<TResult>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TResult>.GroupJoin(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector) => List<TResult>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<TResult>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<TResult>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TResult>.GroupJoin(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOf<TSource>(this IEnumerable<TSource> source, TSource target) => List<int>.IndexesOfEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this IEnumerable<double> source) => List<double>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this IEnumerable<int> source) => List<int>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this IEnumerable<uint> source) => List<int>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this IEnumerable<long> source) => List<long>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this IEnumerable<double> source) => List<double>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this IEnumerable<int> source) => List<int>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this IEnumerable<uint> source) => List<int>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this IEnumerable<long> source) => List<long>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this IEnumerable<double> source) => List<double>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this IEnumerable<int> source) => List<int>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this IEnumerable<uint> source) => List<int>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this IEnumerable<long> source) => List<long>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this IEnumerable<decimal> source) => List<decimal>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this IEnumerable<double> source) => List<double>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this IEnumerable<int> source) => List<int>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this IEnumerable<uint> source) => List<int>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this IEnumerable<long> source) => List<long>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this IEnumerable<TSource> source, TSource target) => List<int>.IndexOfEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this IEnumerable<TSource> source, TSource target, IEqualityComparer<TSource> comparer) => List<int>.IndexOfEnumerable(source, target, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction) => List<int>.IndexOfEnumerable(source, target, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<int>.IndexOfEnumerable(source, target, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this IEnumerable<decimal> source) => List<decimal>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this IEnumerable<double> source) => List<double>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this IEnumerable<int> source) => List<int>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this IEnumerable<uint> source) => List<int>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this IEnumerable<long> source) => List<long>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this IEnumerable<decimal> source) => List<decimal>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this IEnumerable<double> source) => List<double>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this IEnumerable<int> source) => List<int>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this IEnumerable<uint> source) => List<int>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this IEnumerable<long> source) => List<long>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this IEnumerable<decimal> source) => List<decimal>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this IEnumerable<double> source) => List<double>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this IEnumerable<int> source) => List<int>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this IEnumerable<uint> source) => List<int>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this IEnumerable<long> source) => List<long>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this IEnumerable<decimal> source) => List<decimal>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this IEnumerable<double> source) => List<double>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this IEnumerable<int> source) => List<int>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this IEnumerable<uint> source) => List<int>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this IEnumerable<long> source) => List<long>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this IEnumerable<mpz_t> source) => List<mpz_t>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> source2) => Enumerable.Intersect(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer) => Enumerable.Intersect(source, source2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector) => List<TResult>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<TResult>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<TResult>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TResult>.Join(outer, inner, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector) => List<TResult>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, IEqualityComparer<TKey> comparer) => List<TResult>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction) => List<TResult>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => Enumerable.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, new EComparer<TKey>(equalFunction, hashCodeFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this (IEnumerable<TOuter>, IEnumerable<TInner>) source, Func<TOuter, int, TKey> outerKeySelector, Func<TInner, int, TKey> innerKeySelector, Func<TOuter, TInner, int, TResult> resultSelector, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) => List<TResult>.Join(source.Item1, source.Item2, outerKeySelector, innerKeySelector, resultSelector, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this IEnumerable<List<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this IEnumerable<TSource[]> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this IEnumerable<G.IList<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this IEnumerable<IEnumerable<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> JoinIntoSingle<TSource, TResult>(this IEnumerable<TSource> source) where TSource : IEnumerable<TResult> => List<TSource>.JoinIntoSingleEnumerable<TSource, TResult>(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this IEnumerable<TSource> source, TSource target) => List<int>.LastIndexOfEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this IEnumerable<TSource> source, TSource target, IEqualityComparer<TSource> comparer) => List<int>.LastIndexOfEnumerable(source, target, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction) => List<int>.LastIndexOfEnumerable(source, target, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this IEnumerable<TSource> source, TSource target, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<int>.LastIndexOfEnumerable(source, target, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this IEnumerable<double> source) => List<double>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this IEnumerable<int> source) => List<int>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this IEnumerable<uint> source) => List<int>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this IEnumerable<long> source) => List<long>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this IEnumerable<double> source) => List<double>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this IEnumerable<int> source) => List<int>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this IEnumerable<uint> source) => List<int>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this IEnumerable<long> source) => List<long>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this IEnumerable<double> source) => List<double>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this IEnumerable<int> source) => List<int>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this IEnumerable<uint> source) => List<int>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this IEnumerable<long> source) => List<long>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this IEnumerable<decimal> source) => List<decimal>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this IEnumerable<double> source) => List<double>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this IEnumerable<int> source) => List<int>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this IEnumerable<uint> source) => List<int>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this IEnumerable<long> source) => List<long>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this IEnumerable<mpz_t> source) => List<mpz_t>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max(this IEnumerable<decimal> source) => List<decimal>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max(this IEnumerable<double> source) => List<double>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max(this IEnumerable<int> source) => List<int>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max(this IEnumerable<uint> source) => List<int>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max(this IEnumerable<long> source) => List<long>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max(this IEnumerable<mpz_t> source) => List<mpz_t>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) => Enumerable.Max(source, selector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector) => List<TResult>.Max(source, selector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Max<TSource>(this IEnumerable<TSource> source) => Enumerable.Max(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max(params decimal[] source) => List<decimal>.MaxEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max(params double[] source) => List<double>.MaxEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max(params int[] source) => List<int>.MaxEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max(params uint[] source) => List<uint>.MaxEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max(params long[] source) => List<long>.MaxEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max(params mpz_t[] source) => List<mpz_t>.MaxEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Max<TSource>(params TSource?[] source) => Enumerable.Max(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean(this IEnumerable<decimal> source) => List<decimal>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this IEnumerable<double> source) => List<double>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this IEnumerable<int> source) => List<int>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this IEnumerable<uint> source) => List<int>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this IEnumerable<long> source) => List<long>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this IEnumerable<mpz_t> source) => List<mpz_t>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean(params decimal[] source) => List<decimal>.MeanEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(params double[] source) => List<double>.MeanEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(params int[] source) => List<int>.MeanEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(params uint[] source) => List<uint>.MeanEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(params long[] source) => List<long>.MeanEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(params mpz_t[] source) => List<mpz_t>.MeanEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median(this IEnumerable<decimal> source) => List<decimal>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median(this IEnumerable<double> source) => List<double>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median(this IEnumerable<int> source) => List<int>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median(this IEnumerable<uint> source) => List<int>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median(this IEnumerable<long> source) => List<long>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median(this IEnumerable<mpz_t> source) => List<mpz_t>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Median<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) => List<TResult>.MedianEnumerable(source, selector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Median<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector) => List<TResult>.MedianEnumerable(source, selector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Median<TSource>(this IEnumerable<TSource> source) => List<TSource>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median(params decimal[] source) => List<decimal>.MedianEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median(params double[] source) => List<double>.MedianEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median(params int[] source) => List<int>.MedianEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median(params uint[] source) => List<uint>.MedianEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median(params long[] source) => List<long>.MedianEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median(params mpz_t[] source) => List<mpz_t>.MedianEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Median<TSource>(params TSource?[] source) => List<TSource>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min(this IEnumerable<decimal> source) => List<decimal>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min(this IEnumerable<double> source) => List<double>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min(this IEnumerable<int> source) => List<int>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min(this IEnumerable<uint> source) => List<int>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min(this IEnumerable<long> source) => List<long>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min(this IEnumerable<mpz_t> source) => List<mpz_t>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) => Enumerable.Min(source, selector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector) => List<TResult>.Min(source, selector);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Min<TSource>(this IEnumerable<TSource> source) => Enumerable.Min(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min(params decimal[] source) => List<decimal>.MinEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min(params double[] source) => List<double>.MinEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min(params int[] source) => List<int>.MinEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min(params uint[] source) => List<uint>.MinEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min(params long[] source) => List<long>.MinEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min(params mpz_t[] source) => List<mpz_t>.MinEnumerable(source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Min<TSource>(params TSource?[] source) => Enumerable.Min(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> OfType<TResult>(this IEnumerable source) => List<TResult>.OfTypeEnumerable<TResult>(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element) => Enumerable.Prepend(source, element);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Progression<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> function) => List<TSource>.ProgressionEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Progression<TSource, TResult>(this IEnumerable<TSource> source, TResult seed, Func<TResult, TSource, TResult> function) => List<TResult>.ProgressionEnumerable(source, seed, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this IEnumerable<TSource> source) => List<TSource>.RemoveDoublesEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) => List<TSource>.RemoveDoublesEnumerable(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) => List<TSource>.RemoveDoublesEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<TSource>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2) => List<TSource>.RemoveDoublesEnumerable(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, source2, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, source2, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEqualityComparer<TSource> comparer) => List<TSource>.RemoveDoublesEnumerable(source, source2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, source2, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, source2, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource, bool> equalFunction) => List<TSource>.RemoveDoublesEnumerable(source, source2, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source, source2, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<TSource>.RemoveDoublesEnumerable(source, source2, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, int, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source) => List<TSource>.RemoveDoublesEnumerable(source.Item1, source.Item2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, IEqualityComparer<TSource> comparer) => List<TSource>.RemoveDoublesEnumerable(source.Item1, source.Item2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TSource, bool> equalFunction) => List<TSource>.RemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2, TResult>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.RemoveDoublesEnumerable(source.Item1, source.Item2, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) RemoveDoubles<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<TSource>.RemoveDoublesEnumerable(source.Item1, source.Item2, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this IEnumerable<TSource> source) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Reverse<TSource>(this IEnumerable<TSource> source) => List<TSource>.ReverseEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source) => List<TResult>.SetInnerTypeEnumerable<TResult>(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source, Func<object?, TResult> function) => List<TResult>.SetInnerTypeEnumerable<TResult>(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> SetInnerType<TResult>(this IEnumerable source, Func<object?, int, TResult> function) => List<TResult>.SetInnerTypeEnumerable<TResult>(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Skip<TSource>(this IEnumerable<TSource> source, int count) => Enumerable.Skip(source, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SkipLast<TSource>(this IEnumerable<TSource> source, int count) => Enumerable.SkipLast(source, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<TSource>.SkipWhileEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<TSource>.SkipWhileEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Sort<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) => Enumerable.OrderBy(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Sort<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) => List<TSource>.Sort(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Sort<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, IComparer<TResult> comparer) => Enumerable.OrderBy(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Sort<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, IComparer<TResult> comparer) => List<TSource>.Sort(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Sort<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, int> compareFunction) => Enumerable.OrderBy(source, function, new Comparer<TResult>(compareFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Sort<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, int> compareFunction) => List<TSource>.Sort(source, function, compareFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SortDesc<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) => Enumerable.OrderByDescending(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SortDesc<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) => List<TSource>.SortDesc(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SortDesc<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, IComparer<TResult> comparer) => Enumerable.OrderByDescending(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SortDesc<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, IComparer<TResult> comparer) => List<TSource>.SortDesc(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SortDesc<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, int> compareFunction) => Enumerable.OrderByDescending(source, function, new Comparer<TResult>(compareFunction));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> SortDesc<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, int> compareFunction) => List<TSource>.SortDesc(source, function, compareFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<List<TSource>> SplitIntoEqual<TSource>(this IEnumerable<TSource> source, int fragmentLength) => List<TSource>.SplitIntoEqualEnumerable(source, fragmentLength);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> function) => List<decimal>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double> function) => List<double>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int, double> function) => List<double>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> function) => List<int>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int, int> function) => List<int>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, uint> function) => List<int>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int, uint> function) => List<int>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long> function) => List<long>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int, long> function) => List<long>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum(this IEnumerable<decimal> source) => List<decimal>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum(this IEnumerable<double> source) => List<double>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum(this IEnumerable<int> source) => List<int>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum(this IEnumerable<uint> source) => List<int>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum(this IEnumerable<long> source) => List<long>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum(this IEnumerable<mpz_t> source) => List<mpz_t>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Take<TSource>(this IEnumerable<TSource> source, int count) => List<TSource>.TakeEnumerable(source, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Take<TSource>(this IEnumerable<TSource> source, Range range) => Enumerable.Take(source, range);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> TakeLast<TSource>(this IEnumerable<TSource> source, int count) => Enumerable.TakeLast(source, count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) => List<TSource>.TakeWhileEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) => List<TSource>.TakeWhileEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] ToArray<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) => List<TSource>.ToArrayEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] ToArray<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) => List<TSource>.ToArrayEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source) => List<TSource>.ToArrayEnumerable(source);
	public static Compact2dList<TSource> ToCompact2dList<TSource>(this IEnumerable<List<TSource>> source) => Compact2dList<TSource>.ReturnOrConstruct(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> function, Func<TSource, TValue> function2) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, TKey> function, Func<TSource, int, TValue> function2) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> function, Func<TSource, TValue> function2, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, TKey> function, Func<TSource, int, TValue> function2, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> function, Func<TSource, TValue> function2, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, TKey> function, Func<TSource, int, TValue> function2, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> function, Func<TSource, TValue> function2, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, TKey> function, Func<TSource, int, TValue> function2, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), List<TSource>.ConvertEnumerable(source, function2), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, (TKey, TValue)> function) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, (TKey, TValue)> function) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, (TKey, TValue)> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, (TKey, TValue)> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, (TKey, TValue)> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, KeyValuePair<TKey, TValue>> function) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, KeyValuePair<TKey, TValue>> function) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, KeyValuePair<TKey, TValue>> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, KeyValuePair<TKey, TValue>> function, IEqualityComparer<TKey> comparer) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TKey, TValue> ToDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, int, KeyValuePair<TKey, TValue>> function, Func<TKey, TKey, bool> equalFunction, Func<TKey, int> hashCodeFunction) where TKey : notnull => new(List<TSource>.ConvertEnumerable(source, function), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2) where TSource : notnull => new(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, IEqualityComparer<TSource> comparer) where TSource : notnull => new(source, source2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => new(source, source2, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<TSource> source, IEnumerable<TSource2> source2, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => new(source, source2, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source) where TSource : notnull => new(source.Item1, source.Item2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, IEqualityComparer<TSource> comparer) where TSource : notnull => new(source.Item1, source.Item2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => new(source.Item1, source.Item2, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this (IEnumerable<TSource>, IEnumerable<TSource2>) source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => new(source.Item1, source.Item2, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<(TSource, TSource2)> source) where TSource : notnull => new(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<(TSource, TSource2)> source, IEqualityComparer<TSource> comparer) where TSource : notnull => new(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<(TSource, TSource2)> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => new(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<(TSource, TSource2)> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => new(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<KeyValuePair<TSource, TSource2>> source) where TSource : notnull => new(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<KeyValuePair<TSource, TSource2>> source, IEqualityComparer<TSource> comparer) where TSource : notnull => new(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<KeyValuePair<TSource, TSource2>> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => new(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static Dictionary<TSource, TSource2> ToDictionary<TSource, TSource2>(this IEnumerable<KeyValuePair<TSource, TSource2>> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => new(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static HashSet<TSource> ToHashSet<TSource>(this IEnumerable<TSource> source) => new(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source) => List<TSource>.ReturnOrConstruct(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static string ToString<TSource>(this IEnumerable<TSource> source, Func<TSource, char> function) => new(List<TSource>.ToArrayEnumerable(source, function));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static string ToString<TSource>(this IEnumerable<TSource> source, Func<TSource, int, char> function) => new(List<TSource>.ToArrayEnumerable(source, function));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static string ToString(this IEnumerable<char> source) => new(List<char>.ToArrayEnumerable(source));
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<List<TSource>> Transpose<TSource>(this List<List<TSource>> source, bool widen = false) => List<TSource>.Transpose(source, widen);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryGetCountEasily<TSource>(this IEnumerable<TSource> source, out int count) => List<TSource>.TryGetCountEasilyEnumerable(source, out count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryGetCountEasily<TSource>(this IEnumerable source, out int count) => List<TSource>.TryGetCountEasilyEnumerable(source, out count);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource>(this IEnumerable<TSource> source, Func<IEnumerable<TSource>, List<TSource>> function, out List<TSource>? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource, TResult>(this IEnumerable<TSource> source, Func<IEnumerable<TSource>, TResult> function, out TResult? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource>(this List<TSource> source, Func<List<TSource>, List<TSource>> function, out List<TSource>? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource, TResult>(this List<TSource> source, Func<List<TSource>, TResult> function, out TResult? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource>(this TSource[] source, Func<TSource[], List<TSource>> function, out List<TSource>? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource, TResult>(this TSource[] source, Func<TSource[], TResult> function, out TResult? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource>(this G.IList<TSource> source, Func<G.IList<TSource>, List<TSource>> function, out List<TSource>? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool TryWrap<TSource, TResult>(this G.IList<TSource> source, Func<G.IList<TSource>, TResult> function, out TResult? result) => List<TSource>.TryWrapEnumerable(source, function, out result);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> source2) => Enumerable.Union(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer) => Enumerable.Union(source, source2, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Wrap<TSource>(this IEnumerable<TSource> source, Func<IEnumerable<TSource>, List<TSource>> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult Wrap<TSource, TResult>(this IEnumerable<TSource> source, Func<IEnumerable<TSource>, TResult> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Wrap<TSource>(this List<TSource> source, Func<List<TSource>, List<TSource>> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult Wrap<TSource, TResult>(this List<TSource> source, Func<List<TSource>, TResult> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Wrap<TSource>(this TSource[] source, Func<TSource[], List<TSource>> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult Wrap<TSource, TResult>(this TSource[] source, Func<TSource[], TResult> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Wrap<TSource>(this G.IList<TSource> source, Func<G.IList<TSource>, List<TSource>> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult Wrap<TSource, TResult>(this G.IList<TSource> source, Func<G.IList<TSource>, TResult> function) => function(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.AllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.AllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.AllEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.AllEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.AllEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool All<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.AllEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TResult>(this ReadOnlySpan<TResult> source) => List<TResult>.AnyEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TResult>(this Span<TResult> source) => List<TResult>.AnyEnumerable((ReadOnlySpan<TResult>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TResult>(this TResult[] source) => List<TResult>.AnyEnumerable((ReadOnlySpan<TResult>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.AnyEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.AnyEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.AnyEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.AnyEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.AnyEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Any<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.AnyEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) => List<TResult>.BreakEnumerable(source, function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) => List<TResult>.BreakEnumerable(source, function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) Break<TSource, TSource2>(this ReadOnlySpan<(TSource, TSource2)> source) => List<TSource>.BreakEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) Break<TSource, TSource2>(this Span<(TSource, TSource2)> source) => List<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2)>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>) Break<TSource, TSource2>(this (TSource, TSource2)[] source) => List<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2)>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2)> function) => List<TResult>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2)> function) => List<TResult>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, (TResult, TResult2)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, int, (TResult, TResult2)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, (TResult, TResult2)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>) Break<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, int, (TResult, TResult2)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) => List<TResult>.BreakEnumerable(source, function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) => List<TResult>.BreakEnumerable(source, function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2, function3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>, List<TSource3>) Break<TSource, TSource2, TSource3>(this ReadOnlySpan<(TSource, TSource2, TSource3)> source) => List<TSource>.BreakEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>, List<TSource3>) Break<TSource, TSource2, TSource3>(this Span<(TSource, TSource2, TSource3)> source) => List<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2, TSource3)>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TSource>, List<TSource2>, List<TSource3>) Break<TSource, TSource2, TSource3>(this (TSource, TSource2, TSource3)[] source) => List<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2, TSource3)>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) => List<TResult>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) => List<TResult>.BreakEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, (TResult, TResult2, TResult3)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static (List<TResult>, List<TResult2>, List<TResult3>) Break<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, int, (TResult, TResult2, TResult3)> function) => List<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, TResult> function) => List<TResult>.CombineEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, int, TResult> function) => List<TResult>.CombineEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this Span<TSource> source, Span<TSource2> source2, Func<TSource, TSource2, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this Span<TSource> source, Span<TSource2> source2, Func<TSource, TSource2, int, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this TSource[] source, TSource2[] source2, Func<TSource, TSource2, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TResult>(this TSource[] source, TSource2[] source2, Func<TSource, TSource2, int, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2)> Combine<TSource, TSource2>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2) => List<TSource>.CombineEnumerable(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2)> Combine<TSource, TSource2>(this Span<TSource> source, Span<TSource2> source2) => List<TSource>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2)> Combine<TSource, TSource2>(this TSource[] source, TSource2[] source2) => List<TSource>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) => List<TResult>.CombineEnumerable(source, source2, source3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) => List<TResult>.CombineEnumerable(source, source2, source3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this Span<TSource> source, Span<TSource2> source2, Span<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, (ReadOnlySpan<TSource3>)source3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this Span<TSource> source, Span<TSource2> source2, Span<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, (ReadOnlySpan<TSource3>)source3, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this TSource[] source, TSource2[] source2, TSource3[] source3, Func<TSource, TSource2, TSource3, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), (ReadOnlySpan<TSource3>)source3.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Combine<TSource, TSource2, TSource3, TResult>(this TSource[] source, TSource2[] source2, TSource3[] source3, Func<TSource, TSource2, TSource3, int, TResult> function) => List<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), (ReadOnlySpan<TSource3>)source3.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2, TSource3)> Combine<TSource, TSource2, TSource3>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3) => List<TSource>.CombineEnumerable(source, source2, source3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2, TSource3)> Combine<TSource, TSource2, TSource3>(this Span<TSource> source, Span<TSource2> source2, Span<TSource3> source3) => List<TSource>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, (ReadOnlySpan<TSource3>)source3);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource, TSource2, TSource3)> Combine<TSource, TSource2, TSource3>(this TSource[] source, TSource2[] source2, TSource3[] source3) => List<TSource>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), (ReadOnlySpan<TSource3>)source3.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function) => List<TResult>.ConvertEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.ConvertEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function) => List<TResult>.ConvertEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.ConvertEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function) => List<TResult>.ConvertEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> Convert<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function) => List<TResult>.ConvertEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this Span<TSource> source, Func<TSource, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this Span<TSource> source, Func<TSource, int, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this TSource[] source, Func<TSource, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> ConvertAndJoin<TSource, TResult>(this TSource[] source, Func<TSource, int, IEnumerable<TResult>> function) => List<TResult>.ConvertAndJoinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.CountEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.CountEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.CountEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.CountEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.CountEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Count<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.CountEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, bool> function) => List<bool>.EqualsEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, int, bool> function) => List<bool>.EqualsEnumerable(source, source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this Span<TSource> source, Span<TSource2> source2, Func<TSource, TSource2, bool> function) => List<bool>.EqualsEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this Span<TSource> source, Span<TSource2> source2, Func<TSource, TSource2, int, bool> function) => List<bool>.EqualsEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this TSource[] source, TSource2[] source2, Func<TSource, TSource2, bool> function) => List<bool>.EqualsEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this TSource[] source, TSource2[] source2, Func<TSource, TSource2, int, bool> function) => List<bool>.EqualsEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2) => List<bool>.EqualsEnumerable(source, source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this Span<TSource> source, Span<TSource2> source2) => List<bool>.EqualsEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static bool Equals<TSource, TSource2>(this TSource[] source, TSource2[] source2) => List<bool>.EqualsEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.FilterEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.FilterEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.FilterEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.FilterEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.FilterEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Filter<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.FilterEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.FindEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.FindEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.FindEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Find<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.FindEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.FindAllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindAllEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.FindAllEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindAllEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.FindAllEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAll<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.FindAllEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMax<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMedian<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> FindAllMin<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindAllMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, bool> function) => List<bool>.FindLastEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindLastEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this Span<TSource> source, Func<TSource, bool> function) => List<bool>.FindLastEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this Span<TSource> source, Func<TSource, int, bool> function) => List<bool>.FindLastEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this TSource[] source, Func<TSource, bool> function) => List<bool>.FindLastEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLast<TSource>(this TSource[] source, Func<TSource, int, bool> function) => List<bool>.FindLastEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMax<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMedian<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindLastMin<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMaxIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMeanIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMedianIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindLastMinIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindLastMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMax<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMedian<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? FindMin<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMaxIndexes<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMeanIndexes<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMedianIndexes<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> FindMinIndexes<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMaxIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMaxIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMeanIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMeanIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMedianIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMedianIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int FindMinIndex<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.FindMinIndexEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this ReadOnlySpan<TSource> source) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this Span<TSource> source) where TSource : notnull => List<TSource>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this TSource[] source) where TSource : notnull => List<TSource>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TResult Key, int Count)> FrequencyTable<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<(TSource Key, int Count)> FrequencyTable<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.FrequencyTableEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this ReadOnlySpan<TSource> source) where TSource : notnull => List<TSource>.GroupEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this Span<TSource> source) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this TSource[] source) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, IEqualityComparer<TResult> comparer) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this ReadOnlySpan<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull => List<TSource>.GroupEnumerable(source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this Span<TSource> source, IEqualityComparer<TSource> comparer) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source, comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this TSource[] source, IEqualityComparer<TSource> comparer) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), comparer);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.GroupEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TResult>> Group<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TResult : notnull => List<TResult>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.GroupEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<Group<TSource, TSource>> Group<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<TSource>.GroupEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOf<TSource>(this ReadOnlySpan<TSource> source, TSource target) => List<int>.IndexesOfEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOf<TSource>(this Span<TSource> source, TSource target) => List<int>.IndexesOfEnumerable((ReadOnlySpan<TSource>)source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOf<TSource>(this TSource[] source, TSource target) => List<int>.IndexesOfEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this Span<decimal> source) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this decimal[] source) => List<decimal>.IndexesOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this ReadOnlySpan<double> source) => List<double>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this Span<double> source) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this double[] source) => List<double>.IndexesOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this ReadOnlySpan<int> source) => List<int>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this Span<int> source) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this int[] source) => List<int>.IndexesOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this Span<uint> source) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this uint[] source) => List<uint>.IndexesOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this ReadOnlySpan<long> source) => List<long>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this Span<long> source) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this long[] source) => List<long>.IndexesOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMax(this mpz_t[] source) => List<mpz_t>.IndexesOfMaxEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this Span<decimal> source) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this decimal[] source) => List<decimal>.IndexesOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this ReadOnlySpan<double> source) => List<double>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this Span<double> source) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this double[] source) => List<double>.IndexesOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this ReadOnlySpan<int> source) => List<int>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this Span<int> source) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this int[] source) => List<int>.IndexesOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this Span<uint> source) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this uint[] source) => List<uint>.IndexesOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this ReadOnlySpan<long> source) => List<long>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this Span<long> source) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this long[] source) => List<long>.IndexesOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMean(this mpz_t[] source) => List<mpz_t>.IndexesOfMeanEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this Span<decimal> source) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this decimal[] source) => List<decimal>.IndexesOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this ReadOnlySpan<double> source) => List<double>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this Span<double> source) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this double[] source) => List<double>.IndexesOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this ReadOnlySpan<int> source) => List<int>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this Span<int> source) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this int[] source) => List<int>.IndexesOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this Span<uint> source) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this uint[] source) => List<uint>.IndexesOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this ReadOnlySpan<long> source) => List<long>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this Span<long> source) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this long[] source) => List<long>.IndexesOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMedian(this mpz_t[] source) => List<mpz_t>.IndexesOfMedianEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this Span<decimal> source) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this decimal[] source) => List<decimal>.IndexesOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this ReadOnlySpan<double> source) => List<double>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this Span<double> source) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this double[] source) => List<double>.IndexesOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this ReadOnlySpan<int> source) => List<int>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this Span<int> source) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this int[] source) => List<int>.IndexesOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this ReadOnlySpan<uint> source) => List<uint>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this Span<uint> source) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this uint[] source) => List<uint>.IndexesOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this ReadOnlySpan<long> source) => List<long>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this Span<long> source) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this long[] source) => List<long>.IndexesOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexesOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this Span<mpz_t> source) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> IndexesOfMin(this mpz_t[] source) => List<mpz_t>.IndexesOfMinEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this ReadOnlySpan<TSource> source, TSource target) => List<int>.IndexOfEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this Span<TSource> source, TSource target) => List<int>.IndexOfEnumerable((ReadOnlySpan<TSource>)source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOf<TSource>(this TSource[] source, TSource target) => List<int>.IndexOfEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this Span<decimal> source) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this decimal[] source) => List<decimal>.IndexOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this ReadOnlySpan<double> source) => List<double>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this Span<double> source) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this double[] source) => List<double>.IndexOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this ReadOnlySpan<int> source) => List<int>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this Span<int> source) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this int[] source) => List<int>.IndexOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this Span<uint> source) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this uint[] source) => List<uint>.IndexOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this ReadOnlySpan<long> source) => List<long>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this Span<long> source) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this long[] source) => List<long>.IndexOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this Span<mpz_t> source) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMax(this mpz_t[] source) => List<mpz_t>.IndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this Span<decimal> source) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this decimal[] source) => List<decimal>.IndexOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this ReadOnlySpan<double> source) => List<double>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this Span<double> source) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this double[] source) => List<double>.IndexOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this ReadOnlySpan<int> source) => List<int>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this Span<int> source) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this int[] source) => List<int>.IndexOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this Span<uint> source) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this uint[] source) => List<uint>.IndexOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this ReadOnlySpan<long> source) => List<long>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this Span<long> source) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this long[] source) => List<long>.IndexOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this Span<mpz_t> source) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMean(this mpz_t[] source) => List<mpz_t>.IndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this Span<decimal> source) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this decimal[] source) => List<decimal>.IndexOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this ReadOnlySpan<double> source) => List<double>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this Span<double> source) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this double[] source) => List<double>.IndexOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this ReadOnlySpan<int> source) => List<int>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this Span<int> source) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this int[] source) => List<int>.IndexOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this Span<uint> source) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this uint[] source) => List<uint>.IndexOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this ReadOnlySpan<long> source) => List<long>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this Span<long> source) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this long[] source) => List<long>.IndexOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this Span<mpz_t> source) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMedian(this mpz_t[] source) => List<mpz_t>.IndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this Span<decimal> source) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this decimal[] source) => List<decimal>.IndexOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this ReadOnlySpan<double> source) => List<double>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this Span<double> source) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this double[] source) => List<double>.IndexOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this ReadOnlySpan<int> source) => List<int>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this Span<int> source) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this int[] source) => List<int>.IndexOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this ReadOnlySpan<uint> source) => List<uint>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this Span<uint> source) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this uint[] source) => List<uint>.IndexOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this ReadOnlySpan<long> source) => List<long>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this Span<long> source) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this long[] source) => List<long>.IndexOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.IndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this Span<mpz_t> source) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int IndexOfMin(this mpz_t[] source) => List<mpz_t>.IndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this ReadOnlySpan<List<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this Span<List<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<List<TSource>>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this List<TSource>[] source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<List<TSource>>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this ReadOnlySpan<TSource[]> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this Span<TSource[]> source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<TSource[]>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this TSource[][] source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<TSource[]>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this ReadOnlySpan<G.IList<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this Span<G.IList<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<TSource>>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this G.IList<TSource>[] source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<G.IList<TSource>>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this ReadOnlySpan<IEnumerable<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this Span<IEnumerable<TSource>> source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<TSource>>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> JoinIntoSingle<TSource>(this IEnumerable<TSource>[] source) => List<TSource>.JoinIntoSingleEnumerable((ReadOnlySpan<IEnumerable<TSource>>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> JoinIntoSingle<TSource, TResult>(this ReadOnlySpan<TSource> source) where TSource : IEnumerable<TResult> => List<TSource>.JoinIntoSingleEnumerable<TSource, TResult>(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> JoinIntoSingle<TSource, TResult>(this Span<TSource> source) where TSource : IEnumerable<TResult> => List<TSource>.JoinIntoSingleEnumerable<TSource, TResult>((ReadOnlySpan<TSource>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TResult> JoinIntoSingle<TSource, TResult>(this TSource[] source) where TSource : IEnumerable<TResult> => List<TSource>.JoinIntoSingleEnumerable<TSource, TResult>((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this ReadOnlySpan<TSource> source, TSource target) => List<int>.LastIndexOfEnumerable(source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this Span<TSource> source, TSource target) => List<int>.LastIndexOfEnumerable((ReadOnlySpan<TSource>)source, target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOf<TSource>(this TSource[] source, TSource target) => List<int>.LastIndexOfEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), target);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this Span<decimal> source) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this decimal[] source) => List<decimal>.LastIndexOfMaxEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this Span<double> source) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this double[] source) => List<double>.LastIndexOfMaxEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this Span<int> source) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this int[] source) => List<int>.LastIndexOfMaxEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this Span<uint> source) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this uint[] source) => List<uint>.LastIndexOfMaxEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this Span<long> source) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this long[] source) => List<long>.LastIndexOfMaxEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMax(this mpz_t[] source) => List<mpz_t>.LastIndexOfMaxEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this Span<decimal> source) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this decimal[] source) => List<decimal>.LastIndexOfMeanEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this Span<double> source) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this double[] source) => List<double>.LastIndexOfMeanEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this Span<int> source) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this int[] source) => List<int>.LastIndexOfMeanEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this Span<uint> source) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this uint[] source) => List<uint>.LastIndexOfMeanEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this Span<long> source) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this long[] source) => List<long>.LastIndexOfMeanEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMean(this mpz_t[] source) => List<mpz_t>.LastIndexOfMeanEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this Span<decimal> source) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this decimal[] source) => List<decimal>.LastIndexOfMedianEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this Span<double> source) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this double[] source) => List<double>.LastIndexOfMedianEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this Span<int> source) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this int[] source) => List<int>.LastIndexOfMedianEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this Span<uint> source) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this uint[] source) => List<uint>.LastIndexOfMedianEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this Span<long> source) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this long[] source) => List<long>.LastIndexOfMedianEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMedian(this mpz_t[] source) => List<mpz_t>.LastIndexOfMedianEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this ReadOnlySpan<decimal> source) => List<decimal>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this Span<decimal> source) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this decimal[] source) => List<decimal>.LastIndexOfMinEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this ReadOnlySpan<double> source) => List<double>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this Span<double> source) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this double[] source) => List<double>.LastIndexOfMinEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this ReadOnlySpan<int> source) => List<int>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this Span<int> source) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this int[] source) => List<int>.LastIndexOfMinEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this ReadOnlySpan<uint> source) => List<uint>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this Span<uint> source) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this uint[] source) => List<uint>.LastIndexOfMinEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this ReadOnlySpan<long> source) => List<long>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this Span<long> source) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this long[] source) => List<long>.LastIndexOfMinEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.LastIndexOfMinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this Span<mpz_t> source) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int LastIndexOfMin(this mpz_t[] source) => List<mpz_t>.LastIndexOfMinEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MaxEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MaxEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MaxEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max(this ReadOnlySpan<decimal> source) => List<decimal>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Max(this Span<decimal> source) => List<decimal>.MaxEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max(this ReadOnlySpan<double> source) => List<double>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Max(this Span<double> source) => List<double>.MaxEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max(this ReadOnlySpan<int> source) => List<int>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Max(this Span<int> source) => List<int>.MaxEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max(this ReadOnlySpan<uint> source) => List<uint>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Max(this Span<uint> source) => List<uint>.MaxEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max(this ReadOnlySpan<long> source) => List<long>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Max(this Span<long> source) => List<long>.MaxEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MaxEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Max(this Span<mpz_t> source) => List<mpz_t>.MaxEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MeanEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MeanEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MeanEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean(this ReadOnlySpan<decimal> source) => List<decimal>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Mean(this Span<decimal> source) => List<decimal>.MeanEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this ReadOnlySpan<double> source) => List<double>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this Span<double> source) => List<double>.MeanEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this ReadOnlySpan<int> source) => List<int>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this Span<int> source) => List<int>.MeanEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this ReadOnlySpan<uint> source) => List<uint>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this Span<uint> source) => List<uint>.MeanEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this ReadOnlySpan<long> source) => List<long>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this Span<long> source) => List<long>.MeanEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MeanEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Mean(this Span<mpz_t> source) => List<mpz_t>.MeanEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MedianEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MedianEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MedianEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median(this ReadOnlySpan<decimal> source) => List<decimal>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Median(this Span<decimal> source) => List<decimal>.MedianEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median(this ReadOnlySpan<double> source) => List<double>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Median(this Span<double> source) => List<double>.MedianEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median(this ReadOnlySpan<int> source) => List<int>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Median(this Span<int> source) => List<int>.MedianEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median(this ReadOnlySpan<uint> source) => List<uint>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Median(this Span<uint> source) => List<uint>.MedianEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median(this ReadOnlySpan<long> source) => List<long>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Median(this Span<long> source) => List<long>.MedianEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MedianEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Median(this Span<mpz_t> source) => List<mpz_t>.MedianEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MinEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MinEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.MinEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min(this ReadOnlySpan<decimal> source) => List<decimal>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Min(this Span<decimal> source) => List<decimal>.MinEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min(this ReadOnlySpan<double> source) => List<double>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Min(this Span<double> source) => List<double>.MinEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min(this ReadOnlySpan<int> source) => List<int>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Min(this Span<int> source) => List<int>.MinEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min(this ReadOnlySpan<uint> source) => List<uint>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Min(this Span<uint> source) => List<uint>.MinEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min(this ReadOnlySpan<long> source) => List<long>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Min(this Span<long> source) => List<long>.MinEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.MinEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Min(this Span<mpz_t> source) => List<mpz_t>.MinEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Progression<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, TSource> function) => List<TSource>.ProgressionEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Progression<TSource>(this Span<TSource> source, Func<TSource, TSource, TSource> function) => List<TSource>.ProgressionEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TSource? Progression<TSource>(this TSource[] source, Func<TSource, TSource, TSource> function) => List<TSource>.ProgressionEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Progression<TSource, TResult>(this ReadOnlySpan<TSource> source, TResult seed, Func<TResult, TSource, TResult> function) => List<TResult>.ProgressionEnumerable(source, seed, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Progression<TSource, TResult>(this Span<TSource> source, TResult seed, Func<TResult, TSource, TResult> function) => List<TResult>.ProgressionEnumerable((ReadOnlySpan<TSource>)source, seed, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult? Progression<TSource, TResult>(this TSource[] source, TResult seed, Func<TResult, TSource, TResult> function) => List<TResult>.ProgressionEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), seed, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.RemoveDoublesEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this ReadOnlySpan<TSource> source) => List<TSource>.RemoveDoublesEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this Span<TSource> source) => List<TSource>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this TSource[] source) => List<TSource>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) => List<TSource>.RemoveDoublesEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction) => List<TSource>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction) => List<TSource>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<TResult>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this TSource[] source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource, TResult>(this TSource[] source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) => List<TResult>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<TSource>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<TSource>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> RemoveDoubles<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) => List<TSource>.RemoveDoublesEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this ReadOnlySpan<TSource> source) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this Span<TSource> source) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable((ReadOnlySpan<TSource>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this TSource[] source) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable((ReadOnlySpan<TSource>)source, equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this Span<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable((ReadOnlySpan<TSource>)source, equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<int> RepresentIntoNumbers<TSource>(this TSource[] source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : notnull => List<int>.RepresentIntoNumbersEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), equalFunction, hashCodeFunction);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Reverse<TSource>(this ReadOnlySpan<TSource> source) => List<TSource>.ReverseEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Reverse<TSource>(this Span<TSource> source) => List<TSource>.ReverseEnumerable((ReadOnlySpan<TSource>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static List<TSource> Reverse<TSource>(this TSource[] source) => List<TSource>.ReverseEnumerable((ReadOnlySpan<TSource>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, decimal> function) => List<decimal>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this Span<TSource> source, Func<TSource, decimal> function) => List<decimal>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this Span<TSource> source, Func<TSource, int, decimal> function) => List<decimal>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this TSource[] source, Func<TSource, decimal> function) => List<decimal>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum<TSource>(this TSource[] source, Func<TSource, int, decimal> function) => List<decimal>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, double> function) => List<double>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, double> function) => List<double>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this Span<TSource> source, Func<TSource, double> function) => List<double>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this Span<TSource> source, Func<TSource, int, double> function) => List<double>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this TSource[] source, Func<TSource, double> function) => List<double>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum<TSource>(this TSource[] source, Func<TSource, int, double> function) => List<double>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int> function) => List<int>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, int> function) => List<int>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this Span<TSource> source, Func<TSource, int> function) => List<int>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this Span<TSource> source, Func<TSource, int, int> function) => List<int>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this TSource[] source, Func<TSource, int> function) => List<int>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum<TSource>(this TSource[] source, Func<TSource, int, int> function) => List<int>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, uint> function) => List<uint>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, uint> function) => List<uint>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this Span<TSource> source, Func<TSource, uint> function) => List<uint>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this Span<TSource> source, Func<TSource, int, uint> function) => List<uint>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this TSource[] source, Func<TSource, uint> function) => List<uint>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum<TSource>(this TSource[] source, Func<TSource, int, uint> function) => List<uint>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, long> function) => List<long>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, long> function) => List<long>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this Span<TSource> source, Func<TSource, long> function) => List<long>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this Span<TSource> source, Func<TSource, int, long> function) => List<long>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this TSource[] source, Func<TSource, long> function) => List<long>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum<TSource>(this TSource[] source, Func<TSource, int, long> function) => List<long>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this ReadOnlySpan<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.SumEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this Span<TSource> source, Func<TSource, mpz_t> function) => List<mpz_t>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this Span<TSource> source, Func<TSource, int, mpz_t> function) => List<mpz_t>.SumEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this TSource[] source, Func<TSource, mpz_t> function) => List<mpz_t>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum<TSource>(this TSource[] source, Func<TSource, int, mpz_t> function) => List<mpz_t>.SumEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum(this ReadOnlySpan<decimal> source) => List<decimal>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum(this Span<decimal> source) => List<decimal>.SumEnumerable((ReadOnlySpan<decimal>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static decimal Sum(this decimal[] source) => List<decimal>.SumEnumerable((ReadOnlySpan<decimal>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum(this ReadOnlySpan<double> source) => List<double>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum(this Span<double> source) => List<double>.SumEnumerable((ReadOnlySpan<double>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static double Sum(this double[] source) => List<double>.SumEnumerable((ReadOnlySpan<double>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum(this ReadOnlySpan<int> source) => List<int>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum(this Span<int> source) => List<int>.SumEnumerable((ReadOnlySpan<int>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static int Sum(this int[] source) => List<int>.SumEnumerable((ReadOnlySpan<int>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum(this ReadOnlySpan<uint> source) => List<uint>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum(this Span<uint> source) => List<uint>.SumEnumerable((ReadOnlySpan<uint>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static uint Sum(this uint[] source) => List<uint>.SumEnumerable((ReadOnlySpan<uint>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum(this ReadOnlySpan<long> source) => List<long>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum(this Span<long> source) => List<long>.SumEnumerable((ReadOnlySpan<long>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static long Sum(this long[] source) => List<long>.SumEnumerable((ReadOnlySpan<long>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum(this ReadOnlySpan<mpz_t> source) => List<mpz_t>.SumEnumerable(source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum(this Span<mpz_t> source) => List<mpz_t>.SumEnumerable((ReadOnlySpan<mpz_t>)source);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static mpz_t Sum(this mpz_t[] source) => List<mpz_t>.SumEnumerable((ReadOnlySpan<mpz_t>)source.AsSpan());
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] ToArray<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function) => List<TResult>.ToArrayEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] ToArray<TSource, TResult>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.ToArrayEnumerable(source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] ToArray<TSource, TResult>(this Span<TSource> source, Func<TSource, TResult> function) => List<TResult>.ToArrayEnumerable((ReadOnlySpan<TSource>)source, function);
	[DllExport(CallingConvention = CallingConvention.Cdecl)]
	public static TResult[] ToArray<TSource, TResult>(this Span<TSource> source, Func<TSource, int, TResult> function) => List<TResult>.ToArrayEnumerable((ReadOnlySpan<TSource>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2);
	public static (NList<TSource>, NList<TSource2>) NBreak<TSource, TSource2>(this IEnumerable<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged => NList<TSource>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TSource>, NList<TSource2>, NList<TSource3>) NBreak<TSource, TSource2, TSource3>(this IEnumerable<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<TSource>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this IEnumerable<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2);
	public static (NList<TSource>, NList<TSource2>) NBreak<TSource, TSource2>(this ReadOnlySpan<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged => NList<TSource>.BreakEnumerable(source);
	public static (NList<TSource>, NList<TSource2>) NBreak<TSource, TSource2>(this Span<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged => NList<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2)>)source);
	public static (NList<TSource>, NList<TSource2>) NBreak<TSource, TSource2>(this (TSource, TSource2)[] source) where TSource : unmanaged where TSource2 : unmanaged => NList<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2)>)source.AsSpan());
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this Span<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this TSource[] source, Func<TSource, int, (TResult, TResult2)> function) where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function, function2, function3);
	public static (NList<TSource>, NList<TSource2>, NList<TSource3>) NBreak<TSource, TSource2, TSource3>(this ReadOnlySpan<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<TSource>.BreakEnumerable(source);
	public static (NList<TSource>, NList<TSource2>, NList<TSource3>) NBreak<TSource, TSource2, TSource3>(this Span<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2, TSource3)>)source);
	public static (NList<TSource>, NList<TSource2>, NList<TSource3>) NBreak<TSource, TSource2, TSource3>(this (TSource, TSource2, TSource3)[] source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<TSource>.BreakEnumerable((ReadOnlySpan<(TSource, TSource2, TSource3)>)source.AsSpan());
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this ReadOnlySpan<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this Span<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this TSource[] source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this NList<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this NList<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2);
	public static (NList<TSource>, NList<TSource2>) NBreak<TSource, TSource2>(this NList<(TSource, TSource2)> source) where TSource : unmanaged where TSource2 : unmanaged => NList<TSource>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this NList<TSource> source, Func<TSource, (TResult, TResult2)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>) NBreak<TSource, TResult, TResult2>(this NList<TSource> source, Func<TSource, int, (TResult, TResult2)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this NList<TSource> source, Func<TSource, TResult> function, Func<TSource, TResult2> function2, Func<TSource, TResult3> function3) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this NList<TSource> source, Func<TSource, int, TResult> function, Func<TSource, int, TResult2> function2, Func<TSource, int, TResult3> function3) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function, function2, function3);
	public static (NList<TSource>, NList<TSource2>, NList<TSource3>) NBreak<TSource, TSource2, TSource3>(this NList<(TSource, TSource2, TSource3)> source) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<TSource>.BreakEnumerable(source);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this NList<TSource> source, Func<TSource, (TResult, TResult2, TResult3)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static (NList<TResult>, NList<TResult2>, NList<TResult3>) NBreak<TSource, TResult, TResult2, TResult3>(this NList<TSource> source, Func<TSource, int, (TResult, TResult2, TResult3)> function) where TSource : unmanaged where TResult : unmanaged where TResult2 : unmanaged where TResult3 : unmanaged => NList<TResult>.BreakEnumerable(source, function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, Func<TSource, TSource2, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this Span<TSource> source, Span<TSource2> source2, Func<TSource, TSource2, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this Span<TSource> source, Span<TSource2> source2, Func<TSource, TSource2, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this TSource[] source, TSource2[] source2, Func<TSource, TSource2, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this TSource[] source, TSource2[] source2, Func<TSource, TSource2, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), function);
	public static NList<(TSource, TSource2)> NCombine<TSource, TSource2>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2) where TSource : unmanaged where TSource2 : unmanaged => NList<(TSource, TSource2)>.CombineEnumerable(source, source2);
	public static NList<(TSource, TSource2)> NCombine<TSource, TSource2>(this Span<TSource> source, Span<TSource2> source2) where TSource : unmanaged where TSource2 : unmanaged => NList<(TSource, TSource2)>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2);
	public static NList<(TSource, TSource2)> NCombine<TSource, TSource2>(this TSource[] source, TSource2[] source2) where TSource : unmanaged where TSource2 : unmanaged => NList<(TSource, TSource2)>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan());
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this Span<TSource> source, Span<TSource2> source2, Span<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, (ReadOnlySpan<TSource3>)source3, function);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this Span<TSource> source, Span<TSource2> source2, Span<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, (ReadOnlySpan<TSource3>)source3, function);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this TSource[] source, TSource2[] source2, TSource3[] source3, Func<TSource, TSource2, TSource3, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), (ReadOnlySpan<TSource3>)source3.AsSpan(), function);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this TSource[] source, TSource2[] source2, TSource3[] source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), (ReadOnlySpan<TSource3>)source3.AsSpan(), function);
	public static NList<(TSource, TSource2, TSource3)> NCombine<TSource, TSource2, TSource3>(this ReadOnlySpan<TSource> source, ReadOnlySpan<TSource2> source2, ReadOnlySpan<TSource3> source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<(TSource, TSource2, TSource3)>.CombineEnumerable(source, source2, source3);
	public static NList<(TSource, TSource2, TSource3)> NCombine<TSource, TSource2, TSource3>(this Span<TSource> source, Span<TSource2> source2, Span<TSource3> source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<(TSource, TSource2, TSource3)>.CombineEnumerable((ReadOnlySpan<TSource>)source, (ReadOnlySpan<TSource2>)source2, (ReadOnlySpan<TSource3>)source3);
	public static NList<(TSource, TSource2, TSource3)> NCombine<TSource, TSource2, TSource3>(this TSource[] source, TSource2[] source2, TSource3[] source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<(TSource, TSource2, TSource3)>.CombineEnumerable((ReadOnlySpan<TSource>)source.AsSpan(), (ReadOnlySpan<TSource2>)source2.AsSpan(), (ReadOnlySpan<TSource3>)source3.AsSpan());
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this NList<TSource> source, NList<TSource2> source2, Func<TSource, TSource2, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, function);
	public static NList<TResult> NCombine<TSource, TSource2, TResult>(this NList<TSource> source, NList<TSource2> source2, Func<TSource, TSource2, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, function);
	public static NList<(TSource, TSource2)> NCombine<TSource, TSource2>(this NList<TSource> source, NList<TSource2> source2) where TSource : unmanaged where TSource2 : unmanaged => NList<(TSource, TSource2)>.CombineEnumerable(source, source2);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this NList<TSource> source, NList<TSource2> source2, NList<TSource3> source3, Func<TSource, TSource2, TSource3, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, source3, function);
	public static NList<TResult> NCombine<TSource, TSource2, TSource3, TResult>(this NList<TSource> source, NList<TSource2> source2, NList<TSource3> source3, Func<TSource, TSource2, TSource3, int, TResult> function) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged where TResult : unmanaged => NList<TResult>.CombineEnumerable(source, source2, source3, function);
	public static NList<(TSource, TSource2, TSource3)> NCombine<TSource, TSource2, TSource3>(this NList<TSource> source, NList<TSource2> source2, NList<TSource3> source3) where TSource : unmanaged where TSource2 : unmanaged where TSource3 : unmanaged => NList<(TSource, TSource2, TSource3)>.CombineEnumerable(source, source2, source3);
	public static NList<TResult> NConvert<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> function) where TSource : unmanaged where TResult : unmanaged => NList<TResult>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> function) where TSource : unmanaged where TResult : unmanaged => NList<TResult>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<TSource, TResult>(this NList<TSource> source, Func<TSource, TResult> function) where TSource : unmanaged where TResult : unmanaged => NList<TResult>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvert<TSource, TResult>(this NList<TSource> source, Func<TSource, int, TResult> function) where TSource : unmanaged where TResult : unmanaged => NList<TResult>.ConvertEnumerable(source, function);
	public static NList<TResult> NConvertAndJoin<TSource, TResult>(this NList<TSource> source, Func<TSource, IEnumerable<TResult>> function) where TSource : unmanaged where TResult : unmanaged => NList<TResult>.ConvertAndJoinEnumerable(source, function);
	public static NList<TResult> NConvertAndJoin<TSource, TResult>(this NList<TSource> source, Func<TSource, int, IEnumerable<TResult>> function) where TSource : unmanaged where TResult : unmanaged => NList<TResult>.ConvertAndJoinEnumerable(source, function);
	public static NList<TSource> NFilter<TSource>(this NList<TSource> source, Func<TSource, bool> function) where TSource : unmanaged => NList<TSource>.FilterEnumerable(source, function);
	public static NList<TSource> NFilter<TSource>(this NList<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged => NList<TSource>.FilterEnumerable(source, function);
	public static NList<TSource> NFindAll<TSource>(this NList<TSource> source, Func<TSource, bool> function) where TSource : unmanaged => NList<TSource>.FindAllEnumerable(source, function);
	public static NList<TSource> NFindAll<TSource>(this NList<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged => NList<TSource>.FindAllEnumerable(source, function);
	public static NList<int> NIndexesOf<TSource>(this NList<TSource> source, TSource target) where TSource : unmanaged => NList<TSource>.IndexesOfEnumerable(source, target);
	//public static NList<TSource> NJoinIntoSingle<TSource>(this ReadOnlySpan<NList<TSource>> source) where TSource : unmanaged => NList<TSource>.JoinIntoSingleEnumerable(source);
	//public static NList<TSource> NJoinIntoSingle<TSource>(this ReadOnlySpan<TSource[]> source) where TSource : unmanaged => NList<TSource>.JoinIntoSingleEnumerable(source);
	//public static NList<TSource> NJoinIntoSingle<TSource>(this ReadOnlySpan<G.IList<TSource>> source) where TSource : unmanaged => NList<TSource>.JoinIntoSingleEnumerable(source);
	//public static NList<TSource> NJoinIntoSingle<TSource>(this ReadOnlySpan<IEnumerable<TSource>> source) where TSource : unmanaged => NList<TSource>.JoinIntoSingleEnumerable(source);
	public static NList<TSource> NRemoveDoubles<TSource, TResult>(this NList<TSource> source, Func<TSource, TResult> function) where TSource : unmanaged where TResult : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, function);
	public static NList<TSource> NRemoveDoubles<TSource, TResult>(this NList<TSource> source, Func<TSource, int, TResult> function) where TSource : unmanaged where TResult : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, function);
	public static NList<TSource> NRemoveDoubles<TSource>(this NList<TSource> source) where TSource : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source);
	public static NList<TSource> NRemoveDoubles<TSource, TResult>(this NList<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction) where TSource : unmanaged where TResult : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static NList<TSource> NRemoveDoubles<TSource, TResult>(this NList<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction) where TSource : unmanaged where TResult : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, function, equalFunction);
	public static NList<TSource> NRemoveDoubles<TSource>(this NList<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, equalFunction);
	public static NList<TSource> NRemoveDoubles<TSource, TResult>(this NList<TSource> source, Func<TSource, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TSource : unmanaged where TResult : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static NList<TSource> NRemoveDoubles<TSource, TResult>(this NList<TSource> source, Func<TSource, int, TResult> function, Func<TResult, TResult, bool> equalFunction, Func<TResult, int> hashCodeFunction) where TSource : unmanaged where TResult : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, function, equalFunction, hashCodeFunction);
	public static NList<TSource> NRemoveDoubles<TSource>(this NList<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : unmanaged => NList<TSource>.RemoveDoublesEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<int> NRepresentIntoNumbers<TSource>(this NList<TSource> source) where TSource : unmanaged => NList<TSource>.RepresentIntoNumbersEnumerable(source);
	public static NList<int> NRepresentIntoNumbers<TSource>(this NList<TSource> source, Func<TSource, TSource, bool> equalFunction) where TSource : unmanaged => NList<TSource>.RepresentIntoNumbersEnumerable(source, equalFunction);
	public static NList<int> NRepresentIntoNumbers<TSource>(this NList<TSource> source, Func<TSource, TSource, bool> equalFunction, Func<TSource, int> hashCodeFunction) where TSource : unmanaged => NList<TSource>.RepresentIntoNumbersEnumerable(source, equalFunction, hashCodeFunction);
	public static NList<TSource> NReverse<TSource>(this NList<TSource> source) where TSource : unmanaged => NList<TSource>.ReverseEnumerable(source);
	public static NList<TSource> NSkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) where TSource : unmanaged => NList<TSource>.SkipWhileEnumerable(source, function);
	public static NList<TSource> NSkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged => NList<TSource>.SkipWhileEnumerable(source, function);
	public static List<NList<TSource>> NSplitIntoEqual<TSource>(this NList<TSource> source, int fragmentLength) where TSource : unmanaged => NList<TSource>.SplitIntoEqualEnumerable(source, fragmentLength);
	public static NList<TSource> NTake<TSource>(this IEnumerable<TSource> source, int count) where TSource : unmanaged => NList<TSource>.TakeEnumerable(source, count);
	public static NList<TSource> NTakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> function) where TSource : unmanaged => NList<TSource>.TakeWhileEnumerable(source, function);
	public static NList<TSource> NTakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> function) where TSource : unmanaged => NList<TSource>.TakeWhileEnumerable(source, function);
}
